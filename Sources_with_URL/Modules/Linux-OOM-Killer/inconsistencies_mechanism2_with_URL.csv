;Decision1;Rationale1;URL1;Decision2;Rationale2;URL2;Relationship;Alpha;similarity_rationales
0;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Contradicts;0.994510531425476;0.3513171672821045
1;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Contradicts;0.9556928277015686;0.6442734003067017
2;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Contradicts;0.9155578017234802;0.533965528011322
3;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;Contradicts;0.917155921459198;0.5130186080932617
4;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;Contradicts;0.9238361716270448;0.5783705115318298
5;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.9981389045715332;0.4873455166816711
6;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.9986255168914796;0.7172040939331055
7;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.9806713461875916;0.5560683012008667
8;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.9362782835960388;0.5510857701301575
9;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.9122530221939088;0.5657375454902649
10;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9121739268302916;0.5375957489013672
11;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.9694297909736632;0.7433531284332275
12;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.9510989189147948;0.4435310065746307
13;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9982798099517822;0.5074784755706787
14;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9411827921867372;0.6612657904624939
15;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.9311471581459044;0.6042991280555725
16;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.95354425907135;0.6710247993469238
17;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.9218712449073792;0.501911997795105
18;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.9767622351646424;0.5243174433708191
19;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.972334623336792;0.5001663565635681
20;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.9572837948799132;0.5501887202262878
21;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9396885633468628;0.7918394207954407
22;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Contradicts;0.9966832995414734;0.625108540058136
23;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Contradicts;0.9638046622276306;0.2073611468076706
24;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Contradicts;0.9203083515167236;0.6393542885780334
25;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.9507530331611632;0.1580354124307632
26;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.9361679553985596;0.4732512533664703
27;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.9911165237426758;0.4035516381263733
28;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.9738510847091676;0.3664954900741577
29;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.9439813494682312;0.541922926902771
30;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.9006791710853577;0.4987284541130066
31;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.9475558996200562;0.3640215396881103
32;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9779118299484252;0.3849809169769287
33;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.987362265586853;0.557060956954956
34;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9813884496688844;0.3509739339351654
35;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.94785737991333;0.4519057869911194
36;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.9819970726966858;0.3928925096988678
37;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.9531184434890748;0.245049700140953
38;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.9295704364776612;0.1929548531770706
39;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.9917199611663818;0.3469239175319671
40;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.918536365032196;0.5110605955123901
41;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;https://github.com/torvalds/linux/commit/1da4db0cd5c8a31d4468ec906b413e75e604b465;Contradicts;0.9703565239906312;0.4538509249687195
42;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This patch fixes the problem and should be backported into stable/LTS.;Fixes the problem, should be backported into stable/LTS.;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.9750211238861084;0.4228405952453613
43;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This patch fixes the issue by introducing a new MMF_OOM_KILLED mm flag which is set in oom_kill_process atomically and oom reaper is disabled if the flag was already set.;Fixes the issue by introducing a new MMF_OOM_KILLED mm flag and disabling the oom reaper if the flag was already set.;https://github.com/torvalds/linux/commit/855b018325737f7691f9b7d86339df40aa4e47c3;Contradicts;0.9187994599342346;0.3819544315338135
44;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.9243658185005188;0.5262293219566345
45;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9019536375999452;0.7267969846725464
46;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.958897054195404;0.4733479022979736
47;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9940211176872252;0.4765758216381073
48;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.9812545776367188;0.7478291988372803
49;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.9551612138748168;0.3977554440498352
50;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.944205641746521;0.5014489889144897
51;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.9412422776222228;0.2722945511341095
52;Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9296677708625792;0.3931823670864105
53;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.955550730228424;0.3483200967311859
54;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.9055674076080322;0.2671939134597778
55;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;Contradicts;0.9210808873176576;0.4314886331558227
56;protect oom_reaper_list using simpler way;simpler way;https://github.com/torvalds/linux/commit/bb29902a7515208846114b3b36a4281a9bbf766a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.926712691783905;0.6845275163650513
57;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Contradicts;0.9194631576538086;0.6243868470191956
58;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.9947677850723268;0.5377988219261169
59;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;Contradicts;0.9950201511383056;0.2956618368625641
60;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9274020195007324;0.4937617182731628
61;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.9835031032562256;0.3113015294075012
62;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;prevent unnecessary oom kills or kernel panics;unnecessary oom kills or kernel panics;https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.9552693367004396;0.5495343208312988
63;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.913429856300354;0.4635313749313354
64;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.9717594981193542;0.404422402381897
65;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9910535216331482;0.6281253695487976
66;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.9200347065925598;0.4593247771263122
67;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.9365676641464232;0.3442694544792175
68;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9117072224617004;0.2841200828552246
69;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9834356904029846;0.5039005875587463
70;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9266798496246338;0.4439580142498016
71;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.9339048862457277;0.6395903825759888
72;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9185174703598022;0.5501934289932251
73;The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.953536868095398;0.4270715117454529
74;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9029066562652588;0.6972072720527649
75;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9812068343162536;0.4337922930717468
76;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.9070448279380798;0.541796863079071
77;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Contradicts;0.9113215208053588;0.1615631133317947
78;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.9338172078132628;0.1908904165029525
79;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Contradicts;0.9693599343299866;0.4431153535842895
80;oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.932440221309662;0.2966847121715545
81;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9319572448730468;0.457722008228302
82;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9083641767501832;0.6798741221427917
83;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9082111716270448;0.4170066714286804
84;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.90660297870636;0.3294698297977447
85;As this conversion needs to touch large number of source files;needs to touch large number of source files;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.907711148262024;0.3628905415534973
86;only the necessary includes are there;necessary;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.9689728021621704;0.666863203048706
87;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.9610901474952698;0.3020467460155487
88;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9280883073806764;0.6464522480964661
89;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.9687054753303528;0.6222831606864929
90;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.9203228950500488;0.4068776071071625
91;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9721770882606506;0.1032780483365058
92;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.9142308235168456;0.6387748718261719
93;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9219648838043212;0.5499894618988037
94;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9120756387710572;0.7725107073783875
95;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9637935161590576;0.4651119112968445
96;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.901354432106018;0.4366766214370727
97;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9587295055389404;0.5014350414276123
98;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.9952272176742554;0.7670942544937134
99;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9478530883789062;0.6160848736763
100;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.9067856669425964;0.3911569714546203
101;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.9453167915344238;0.3020467460155487
102;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9370294213294984;0.6464522480964661
103;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.9617614150047302;0.6222831606864929
104;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9897860288619996;0.5993276834487915
105;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.9335047602653505;0.6275131106376648
106;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.9800918102264404;0.533928632736206
107;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.975940763950348;0.5106099843978882
108;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.92540442943573;0.5187196731567383
109;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.92230486869812;0.6237803101539612
110;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.9117246270179749;0.3767188787460327
111;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.939628541469574;0.375580757856369
112;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9921058416366576;0.2903532981872558
113;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9236894845962524;0.5029193162918091
114;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.973744571208954;0.4215561747550964
115;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.9530337452888488;0.3681064546108246
116;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.9394241571426392;0.2547192573547363
117;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.9351270794868468;0.4473336637020111
118;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.928763747215271;0.2022536695003509
119;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9225919246673584;0.2971974015235901
120;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.997624695301056;0.4849392771720886
121;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.9701551795005798;0.2289293706417083
122;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9396225214004515;0.669535756111145
123;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.9171719551086426;0.449058324098587
124;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.9478389620780944;0.1872682869434356
125;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9971392154693604;0.4763265252113342
126;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.9149708151817322;0.7414597272872925
127;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9071820378303528;0.6589586138725281
128;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.9045703411102296;0.2846100926399231
129;Provides more debug info when the system is OOM;More debug info, system is OOM;https://github.com/torvalds/linux/commit/578c2fd6a7f378434655e5c480e23152a3994404;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9212200045585632;0.4198616147041321
130;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.9225598573684692;0.3819530010223388
131;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.926486313343048;0.4352397322654724
132;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.968532383441925;0.1772514432668686
133;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.9838082194328308;0.6323288679122925
134;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.9075447916984558;0.3524984717369079
135;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Contradicts;0.9211438894271852;0.481751024723053
136;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9285837411880492;0.4647562503814697
137;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Contradicts;0.9179094433784484;0.690596342086792
138;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.9664448499679564;0.5291460752487183
139;consider vfork();we dont have any reason;https://github.com/torvalds/linux/commit/19b4586cd9c8ed642798902e55c6f61ed576ad93;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.9032042622566224;0.2620831429958343
140;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.961542546749115;0.5794790983200073
141;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.9616995453834534;0.5025919675827026
142;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9295799732208252;0.5172664523124695
143;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9455313682556152;0.5319722890853882
144;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9552862048149108;0.5185385346412659
145;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.9206472039222716;0.5340383052825928
146;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.9920228719711304;0.5483670830726624
147;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.9051265716552734;0.619225263595581
148;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9846404790878296;0.5492734909057617
149;Fix it.;Fixes;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9506991505622864;0.5563599467277527
150;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9529120922088624;0.4641072750091553
151;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.9072422981262208;0.2948006987571716
152;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;delete the corresponding comment;it will be checked in oom_unkillable_task();https://github.com/torvalds/linux/commit/f8159c13905bba26f3e1782a521dacf7a66fc1ce;Contradicts;0.9446593523025512;0.5160759091377258
153;Remove the redundancy in __oom_kill_task();redundancy;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9072669148445128;0.4862862825393677
154;Remove the redundancy in __oom_kill_task();redundancy;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9576603770256042;0.5704202651977539
155;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9155205488204956;0.7241931557655334
156;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;save roots task;better to save;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.9393123388290404;0.7170867919921875
157;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.9010602831840516;0.1697644144296646
158;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.9363425970077516;0.3908557295799255
159;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9369191527366638;0.3567129075527191
160;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.9496417045593262;0.3350146412849426
161;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.9438066482543944;0.5061671137809753
162;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.9410224556922911;0.5368397235870361
163;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.956520676612854;0.5053021311759949
164;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9141089916229248;0.3025177121162414
165;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9057732820510864;0.0545464158058166
166;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9931730628013612;0.4827367961406708
167;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9116172194480896;0.4138206243515014
168;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.9136754870414734;0.7201592922210693
169;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.938182294368744;0.3137561380863189
170;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;Contradicts;0.9034539461135864;0.6912137269973755
171;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9950359463691713;0.5823999047279358
172;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9097198843955994;0.3873930275440216
173;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.9895562529563904;0.628413200378418
174;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9322550296783448;0.3940968513488769
175;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.9425869584083556;0.4311906397342682
176;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9942891597747804;0.2942288219928741
177;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.933809220790863;0.7100688219070435
178;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9601075053215028;0.5691930055618286
179;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.9162005186080932;0.5604156851768494
180;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.9159671664237976;0.5358348488807678
181;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.9248720407485962;0.210115298628807
182;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9189197421073914;0.2760796844959259
183;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.9063016176223756;0.3219446539878845
184;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.9021994471549988;0.1567294001579284
185;fix uninitialized oc->constraint;uninitialized;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9463487863540648;0.6511762738227844
186;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9049578309059144;0.6535994410514832
187;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.91290944814682;0.3536840379238128
188;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.9684728980064392;0.4987874627113342
189;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9363452196121216;0.5085208415985107
190;Preventing the livelock;caring more about preventing the livelock;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.906271517276764;0.5097132325172424
191;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.9202899932861328;0.6458963751792908
192;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.9114421010017396;0.5517367720603943
193;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9684464931488036;0.5118328332901001
194;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9809746742248536;0.4885974526405334
195;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.9103249311447144;0.443839818239212
196;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.9004099369049072;0.3061453402042389
197;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9204038977622986;0.2988651990890503
198;save roots task;better to save;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.920467495918274;0.4046308994293213
199;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9855388402938844;0.5246537923812866
200;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9678029417991638;0.6030383706092834
201;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Contradicts;0.9701312780380248;0.6138247847557068
202;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.9638588428497314;0.5694321393966675
203;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9093525409698486;0.6853006482124329
204;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;improve that even further;there is a common pattern to do a range lookup first and then do something about that;https://github.com/torvalds/linux/commit/93065ac753e4443840a057bfef4be71ec766fde9;Contradicts;0.9647380709648132;0.5565631985664368
205;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;https://github.com/torvalds/linux/commit/7c5f64f84483bd13886348edda8b3e7b799a7fdb;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9395585656166076;0.624091386795044
206;fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();https://github.com/torvalds/linux/commit/f33e6f0671b3ba81acef4d7c078af86afcc855c4;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.935595154762268;0.628041684627533
207;fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();https://github.com/torvalds/linux/commit/f33e6f0671b3ba81acef4d7c078af86afcc855c4;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9070180058479308;0.6527209281921387
208;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.9196491241455078;0.3717186152935028
209;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9666697978973388;0.4506945013999939
210;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.9888556599617004;0.3851701021194458
211;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.96465665102005;0.3785098195075989
212;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.980414867401123;0.2576318383216858
213;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.9637911915779114;0.1132256686687469
214;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9239727258682252;0.1810496002435684
215;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.9602887630462646;0.2256835401058197
216;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Contradicts;0.9313011169433594;0.2751572430133819
217;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.928740382194519;0.4327395558357239
218;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.9512616991996764;0.4038890600204468
219;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.9584692120552064;0.1804729998111724
220;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9884097576141356;0.3564581871032715
221;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.9511706829071044;0.4469456076622009
222;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.9252411127090454;0.3739727735519409
223;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.93562513589859;0.2701407670974731
224;make sure that the mmput_async is only called;when we do not back off and reap some memory;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9187334775924684;0.7717176675796509
225;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9820636510849;0.3644872009754181
226;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9289954900741576;0.5850855112075806
227;avoid pointless atomic_inc_not_zero usage;pointless;https://github.com/torvalds/linux/commit/9df10fb7b80bc2f540956ba01b5e7ee1012001a5;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.908858835697174;0.4908073544502258
228;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.94746994972229;0.3621935248374939
229;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.9431933760643004;0.4984875321388244
230;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9132379293441772;0.492793321609497
231;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.951137125492096;0.4231599569320678
232;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.9903081059455872;0.4576836824417114
233;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9716376066207886;0.4946576654911041
234;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.9105663299560548;-0.0242639444768428
235;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.9958349466323853;0.4350532293319702
236;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9140267968177797;0.4261039495468139
237;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9478787183761596;0.6707035899162292
238;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.9629665613174438;0.5451340079307556
239;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.937024176120758;0.3833261728286743
240;fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;https://github.com/torvalds/linux/commit/ff05b6f7ae762b6eb464183eec994b28ea09f6dd;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9294591546058656;0.3414736092090606
241;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9759669899940492;0.4848656356334686
242;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9420555233955384;0.6923775672912598
243;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9374249577522278;0.4308104515075683
244;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.9654608964920044;0.4205236732959747
245;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9761455059051514;0.1448292881250381
246;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;https://github.com/torvalds/linux/commit/e1e12d2f3104be886073ac6c5c4678f30b1b9e51;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.93052339553833;0.4622876048088074
247;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;allocate, detach its mm, and free the memory it represents;quickly;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.9028419852256776;0.4061727523803711
248;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9063417315483092;0.6268671751022339
249;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9884184002876282;0.4986031949520111
250;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.9203295707702636;0.3557396531105041
251;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.9206064343452454;0.638706624507904
252;allocate, detach its mm, and free the memory it represents;quickly;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.945212185382843;0.5054140686988831
253;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9276539087295532;0.3056136071681976
254;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.984666347503662;0.4601130187511444
255;remove deprecated oom_adj;deprecated;https://github.com/torvalds/linux/commit/01dc52ebdf472f77cca623ca693ca24cfc0f1bbe;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9342368245124816;0.5239015817642212
256;try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.925212025642395;0.4607633948326111
257;try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9486982226371764;0.3519814312458038
258;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9570054411888124;0.5999139547348022
259;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;Use a single linked list;Save a word in task_struct;https://github.com/torvalds/linux/commit/29c696e1c6eceb5db6b21f0c89495fcfcd40c0eb;Contradicts;0.9543251991271972;0.5751737952232361
260;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9029240012168884;0.6696438789367676
261;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9091047048568726;0.4129285812377929
262;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9825337529182434;0.5245556831359863
263;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.9112305641174316;0.4461860060691833
264;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.911827802658081;0.5077396035194397
265;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.990230143070221;0.4974355101585388
266;Fix this by always printing the nodemask;always printing the nodemask;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9318891763687134;0.3270499408245086
267;allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;https://github.com/torvalds/linux/commit/1b51e65eab64fac72cab009691e8ca9915624876;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.9798327684402466;0.6034200191497803
268;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9199142456054688;0.7590330839157104
269;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9050251841545104;0.5519145727157593
270;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9337302446365356;0.6047807335853577
271;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Contradicts;0.9882718920707704;0.252322793006897
272;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9197731614112854;0.7134137749671936
273;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.9594812393188475;0.5662749409675598
274;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9370751976966858;0.4396429061889648
275;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9803080558776855;0.5876011848449707
276;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9292899966239928;0.256197988986969
277;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.935390055179596;0.7588878870010376
278;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.9157922267913818;0.3665023148059845
279;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.9854045510292052;0.7173383235931396
280;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9272308945655824;0.4196726381778717
281;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.951196312904358;0.4262049794197082
282;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.9262938499450684;0.3305443227291107
283;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.991957187652588;0.6926071643829346
284;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.918355405330658;0.2720878422260284
285;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9566550850868224;0.6147642135620117
286;reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9665529727935792;0.4804818332195282
287;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.900128960609436;0.198676198720932
288;cleanup messages;oom;https://github.com/torvalds/linux/commit/f3af38d30c18538d069a95e624a3db7c3d486a1e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9621453881263732;0.5794790983200073
289;Clean up the OOM killer messages;to be more consistent;https://github.com/torvalds/linux/commit/f3af38d30c18538d069a95e624a3db7c3d486a1e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.919236421585083;0.6318217515945435
290;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.955142080783844;0.6385079622268677
291;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9585501551628112;0.450311541557312
292;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9679521322250366;0.2800542712211609
293;OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9073941111564636;0.4910101890563965
294;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.9272918105125428;0.4577324986457824
295;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.915763795375824;0.5372055172920227
296;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.9428384304046632;0.1265038400888443
297;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.9407508969306946;0.514310359954834
298;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.932293713092804;0.3970974683761596
299;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.9099040031433104;0.5319805145263672
300;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.957390069961548;0.1153382807970047
301;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9769178628921508;0.505157470703125
302;fix constraint deadlock;constraint deadlock;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9190106391906738;0.7159571647644043
303;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.965901792049408;0.3298351466655731
304;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9001967906951904;0.5836867094039917
305;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9828407764434814;0.69297194480896
306;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.9327003359794616;0.3781924247741699
307;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.9527525305747986;0.3110459446907043
308;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.9714672565460204;0.276891142129898
309;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9047002792358398;0.6674348711967468
310;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9565737843513488;0.5903347134590149
311;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.9214563965797424;0.3471165895462036
312;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.9701785445213318;0.3164063096046448
313;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.915830373764038;0.3024577796459198
314;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9127612113952636;0.315589427947998
315;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9861618280410768;0.2269664704799652
316;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9115613698959352;0.2712492346763611
317;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.956749677658081;0.588358998298645
318;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.947385311126709;0.5520622730255127
319;adding some tracepoints ;might help with debugging of similar issues;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.9259649515151978;0.7091347575187683
320;problem mentioned above can be found;How it works in practice;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.9081377983093262;0.4248166680335998
321;problem mentioned above can be found;How it works in practice;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.993499517440796;0.6574879884719849
322;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9504000544548036;0.5648692846298218
323;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9097524285316468;0.5213069915771484
324;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.9688856601715088;0.4784911870956421
325;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9462817311286926;0.6771805286407471
326;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9350807070732116;0.4963778853416443
327;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9718299508094788;0.4651621878147125
328;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.944820761680603;0.3369547724723816
329;remove the wrong check along with pr_info();wrong check along with pr_info();https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9059136509895324;0.6177865862846375
330;remove the wrong check along with pr_info();wrong check along with pr_info();https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.918196439743042;0.4902476668357849
331;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9012643694877625;0.4380047023296356
332;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9221621751785278;0.5958489775657654
333;get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9526646733283995;0.5007600784301758
334;"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9883641004562378;0.4568356275558471
335;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.9425826072692872;0.64117830991745
336;Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();https://github.com/torvalds/linux/commit/da51b14adb671829077da3aeb9e9edd6f8c80afe;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9638263583183287;0.5249496698379517
337;Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();https://github.com/torvalds/linux/commit/da51b14adb671829077da3aeb9e9edd6f8c80afe;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.9784886837005616;0.5003950595855713
338;fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;https://github.com/torvalds/linux/commit/5a2d41961dd6815b874b5c0afec0ac96cd90eea4;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9415245652198792;0.2129153311252594
339;fixes the arg for mem_cgroup_print_oom_info();fixes;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9839550256729126;0.6739756464958191
340;fixes the arg for mem_cgroup_print_oom_info();fixes;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9349274039268494;0.3994367122650146
341;Print information of mem_cgroup;The task being killed, not current, belongs to mem_cgroup;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9873342514038086;0.5046935081481934
342;fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.935887098312378;0.5371987819671631
343;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9400403499603271;0.4221995770931244
344;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.980338215827942;0.2762891054153442
345;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.9627922773361206;0.5092288851737976
346;select_bad_process();it makes consistency more and makes speed up;https://github.com/torvalds/linux/commit/495789a51a91cb8c015d8d77fecbac1caf20b186;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.906706154346466;0.5374101400375366
347;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9276869297027588;0.5000079870223999
348;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9333836436271667;0.6594198346138
349;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.9186636209487916;0.605677604675293
350;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.978388011455536;0.4145413637161255
351;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.93816739320755;0.1131467372179031
352;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.943445920944214;0.3504028022289276
353;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.9137211441993712;0.6280591487884521
354;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9563543796539308;0.1064758673310279
355;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9098841547966005;0.6197777986526489
356;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.913314938545227;0.3434808254241943
357;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.922973930835724;0.3692268431186676
358;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;remove unnecessary exit_state check;unnecessary;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.9047065377235411;0.5209470391273499
359;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.9073082208633424;0.4941120147705078
360;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.9312220215797424;0.2967004477977752
361;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9202320575714112;0.5382360816001892
362;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.9458023905754088;0.1028559878468513
363;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;delete unlock_range();exit_mmap() does not need locked_vm updates;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.9550231099128724;0.207011342048645
364;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9137638211250304;0.3181135654449463
365;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.902287483215332;0.2863472402095794
366;Moving the test down;will give the desired behaviour;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.9501559138298036;0.8217399716377258
367;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.9363641142845154;0.4171121716499328
368;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.9382614493370056;0.4605051577091217
369;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.9728145599365234;0.4466234147548675
370;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.9074370861053468;0.4937523901462555
371;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.979034662246704;0.5275194048881531
372;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.9892059564590454;0.570049524307251
373;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9443918466567992;0.8529704809188843
374;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.9408663511276244;0.4068427979946136
375;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.9345135688781738;0.5928387641906738
376;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.9321715235710144;0.7028859257698059
377;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.92571222782135;0.4336210489273071
378;check all threads which could share the same ->mm;to make it more or less correct;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.9057413935661316;0.6171071529388428
379;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.961441159248352;0.5016546249389648
380;accounting for a fourth would be better than for half of it;we could debate;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.9914054870605468;0.5997684001922607
381;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9623907804489136;0.4265776574611664
382;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;The oom killer does not want to defer in this case;there is no guarantee that thread will ever exit without intervention;https://github.com/torvalds/linux/commit/edd45544c6f09550df0a5491aa8a07af24767e73;Contradicts;0.9442152976989746;0.4748856425285339
383;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.9363251328468324;0.4040486812591553
384;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.966275990009308;0.3596267700195312
385;Provide more precise dump info while memcg oom happening;more precise dump info;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9643287658691406;0.2836747765541076
386;The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.9037548303604126;0.3463020026683807
387;Add SPDX license identifier for missed files;SPDX license identifier for missed files;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9951748847961426;0.3189627528190613
388;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.9125581979751588;0.4094612002372741
389;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.9835196137428284;0.5047639012336731
390;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.9569292068481444;0.4058987498283386
391;OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9405930638313292;0.3046024739742279
392;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;https://github.com/torvalds/linux/commit/337546e83fc7e50917f44846beee936abb9c9f1f;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.9390047192573548;0.6153717041015625
393;Print the tasks cpuset name for informational purposes;for informational purposes;https://github.com/torvalds/linux/commit/75aa199410359dc5fbcf9025ff7af98a9d20f0d5;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9422451853752136;0.7043279409408569
394;fallback allocations when the target/preferred node has no free pages;target/preferred node has no free pages;https://github.com/torvalds/linux/commit/54a6eb5c4765aa573a030ceeba2c14e3d2ea5706;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.90188729763031;0.3283511698246002
395;This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;avoid attempting to kill init sharing same memory;avoid attempting to kill init;https://github.com/torvalds/linux/commit/a2b829d95958da2025ef844c0f53ac15ad720fac;Contradicts;0.92942476272583;0.6985150575637817
