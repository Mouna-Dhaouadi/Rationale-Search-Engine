;Decision1;Rationale1;URL1;Decision2;Rationale2;URL2;Relationship;Alpha
0;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.5990683436393738
1;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.5752081274986267
2;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.6709030866622925
3;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Contradicts;0.5062636733055115
4;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.6405929923057556
5;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5546959638595581
6;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6090050935745239
7;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;fix constraint deadlock;constraint deadlock;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.7066870927810669
8;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.6512245535850525
9;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5625301003456116
10;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5166118741035461
11;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8962968587875366
12;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6939772367477417
13;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5617384910583496
14;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8040061593055725
15;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5710026025772095
16;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;mm locking fix;oom-kill;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.5820884704589844
17;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5238509178161621
18;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7834425568580627
19;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.5637125968933105
20;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.6272343993186951
21;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;dump stack of victim when reaping failed;reaping failed;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.5102951526641846
22;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.547498345375061
23;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5240192413330078
24;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.505247175693512
25;speed up select_bad_process() loop;mm, oom;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5156200528144836
26;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.894819974899292
27;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.7321236729621887
28;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5378387570381165
29;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.8434686064720154
30;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7474036812782288
31;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.8528431057929993
32;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5126088261604309
33;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5125724673271179
34;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6142014265060425
35;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8256665468215942
36;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6335657835006714
37;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.8719528317451477
38;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6679354310035706
39;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7692376375198364
40;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5861647725105286
41;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.646752655506134
42;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.6140869855880737
43;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5322325229644775
44;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.816951334476471
45;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7478606104850769
46;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.550162672996521
47;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5154388546943665
48;Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6141901016235352
49;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Contradicts;0.7822984457015991
50;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Contradicts;0.994510531425476
51;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Contradicts;0.9556928277015686
52;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Contradicts;0.6125971078872681
53;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Contradicts;0.7391332387924194
54;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Contradicts;0.5282205939292908
55;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Contradicts;0.9155578017234802
56;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.8485736846923828
57;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Contradicts;0.8728078007698059
58;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Contradicts;0.875335693359375
59;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.8288981318473816
60;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;Contradicts;0.6326473355293274
61;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.7601117491722107
62;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Contradicts;0.5188351273536682
63;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;put those freeable pages in inactive file LRU;it would make sense to;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Contradicts;0.5597824454307556
64;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Contradicts;0.5640569925308228
65;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;Contradicts;0.5329278707504272
66;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;Contradicts;0.917155921459198
67;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Contradicts;0.5098869204521179
68;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;Contradicts;0.5669341087341309
69;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.8596396446228027
70;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.7071806192398071
71;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.8744167685508728
72;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Contradicts;0.7158554196357727
73;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Contradicts;0.6721364259719849
74;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.7061522006988525
75;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.6154334545135498
76;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Share the same oom_score_adj;As a result;https://github.com/torvalds/linux/commit/44a70adec910d6929689e42b6e5cee5b7d202d20;Contradicts;0.5138040781021118
77;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6652995347976685
78;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.7774709463119507
79;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.6538623571395874
80;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;Contradicts;0.5288402438163757
81;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;Contradicts;0.9238361716270448
82;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.9981389045715332
83;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.9986255168914796
84;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;Contradicts;0.5007063746452332
85;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;remove deprecated oom_adj;deprecated;https://github.com/torvalds/linux/commit/01dc52ebdf472f77cca623ca693ca24cfc0f1bbe;Contradicts;0.8045188188552856
86;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.6298248767852783
87;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Fix this by always printing the nodemask;always printing the nodemask;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;Contradicts;0.6960492730140686
88;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.5661903023719788
89;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.9806713461875916
90;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.5008293986320496
91;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.9362782835960388
92;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.710712194442749
93;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.505039393901825
94;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Contradicts;0.706887423992157
95;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.786687970161438
96;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;Contradicts;0.5328000783920288
97;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.9122530221939088
98;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7724829316139221
99;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9121739268302916
100;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;Contradicts;0.6550315618515015
101;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.5796716213226318
102;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Contradicts;0.5725714564323425
103;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;Contradicts;0.6003844738006592
104;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;Contradicts;0.584601640701294
105;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.9694297909736632
106;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;remove the wrong check along with pr_info();wrong check along with pr_info();https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Contradicts;0.8814011812210083
107;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.581727921962738
108;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;remove unnecessary variable;unnecessary;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;Contradicts;0.5319815278053284
109;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.9510989189147948
110;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7292488813400269
111;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.8364743590354919
112;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7165673971176147
113;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9982798099517822
114;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.7761568427085876
115;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;remove pointless kthread_run() error check;pointless;https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7682705521583557
116;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6767060160636902
117;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.8266218304634094
118;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9411827921867372
119;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;Contradicts;0.5618190765380859
120;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.7750676274299622
121;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;https://github.com/torvalds/linux/commit/b460cbc581a53cc088ceba80608021dd49c63c43;Contradicts;0.5855803489685059
122;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.9311471581459044
123;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.95354425907135
124;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7854273319244385
125;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.7406228184700012
126;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.8235911130905151
127;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;https://github.com/torvalds/linux/commit/2314b42db67be30b747122d65c6cd2c85da34538;Contradicts;0.5277389883995056
128;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8539357781410217
129;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;remove unnecessary exit_state check;unnecessary;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.6647443175315857
130;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.671226441860199
131;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.8897309899330139
132;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.7547094225883484
133;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.747614324092865
134;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.7296482920646667
135;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.633201003074646
136;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.6711586713790894
137;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;it now iterates threads instead;leads to ambiguity;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.6646363735198975
138;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5955362319946289
139;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5671178698539734
140;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6701342463493347
141;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Change oom_kill.c to use for_each_thread();rather than the racy while_each_thread() which can loop forever if we race with exit;https://github.com/torvalds/linux/commit/1da4db0cd5c8a31d4468ec906b413e75e604b465;Contradicts;0.6966086626052856
142;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.9218712449073792
143;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.838927686214447
144;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6911022067070007
145;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.6084901690483093
146;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.8836236000061035
147;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.55525803565979
148;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5211588740348816
149;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.8902783989906311
150;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.7640795707702637
151;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;Contradicts;0.5905908942222595
152;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.838307797908783
153;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.8089990019798279
154;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;https://github.com/torvalds/linux/commit/dc6c9a35b66b520cf67e05d8ca60ebecad3b0479;Contradicts;0.8156700134277344
155;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6664442420005798
156;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.681914210319519
157;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.800771951675415
158;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.6448466777801514
159;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;delete unlock_range();exit_mmap() does not need locked_vm updates;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5135859251022339
160;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Contradicts;0.6274981498718262
161;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Change __task_will_free_mem to test signal->core_state instead of the flag SIGNAL_GROUP_COREDUMP;In preparation for removing the flag SIGNAL_GROUP_COREDUMP;https://github.com/torvalds/linux/commit/98b24b16b2aebffabf5b8670f44f19666c1e029f;Contradicts;0.5864359736442566
162;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.6249017715454102
163;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.5702596306800842
164;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.9767622351646424
165;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.6773090362548828
166;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Introduce a struct zoneref to store a zone pointer and a zone index;Store a zone pointer and a zone index;https://github.com/torvalds/linux/commit/dd1a239f6f2d4d3eedd318583ec319aa145b324c;Contradicts;0.69687819480896
167;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;Contradicts;0.5597879886627197
168;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.8495542407035828
169;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.8241966366767883
170;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.8366668224334717
171;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.972334623336792
172;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.8379882574081421
173;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.9572837948799132
174;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5674243569374084
175;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7332208752632141
176;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Use a single linked list;Save a word in task_struct;https://github.com/torvalds/linux/commit/29c696e1c6eceb5db6b21f0c89495fcfcd40c0eb;Contradicts;0.6775363683700562
177;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;This patch fixes the issue by introducing a new MMF_OOM_KILLED mm flag which is set in oom_kill_process atomically and oom reaper is disabled if the flag was already set.;Fixes the issue by introducing a new MMF_OOM_KILLED mm flag and disabling the oom reaper if the flag was already set.;https://github.com/torvalds/linux/commit/855b018325737f7691f9b7d86339df40aa4e47c3;Contradicts;0.5614741444587708
178;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5392852425575256
179;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.8690351843833923
180;"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();https://github.com/torvalds/linux/commit/f44666b04605d1c7fd94ab90b7ccf633e7eff228;adds MM_SHMEMPAGES counter to mm_rss_stat;to account for shmem pages separately from MM_FILEPAGES;https://github.com/torvalds/linux/commit/eca56ff906bdd0239485e8b47154a6e73dd9a2f3;Contradicts;0.8885346055030823
181;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Contradicts;0.6727662086486816
182;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.5989738702774048
183;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.7776078581809998
184;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.7160595655441284
185;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.7554869651794434
186;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5932019948959351
187;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.511362612247467
188;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.5024238228797913
189;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5835567116737366
190;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7124754190444946
191;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7510360479354858
192;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5931209921836853
193;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.7210493087768555
194;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7767588496208191
195;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6712334156036377
196;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5246307253837585
197;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5230076313018799
198;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.7168590426445007
199;strive for making this context as reliable and independent on other subsystems;as much as possible;https://github.com/torvalds/linux/commit/ec8d7c14ea14922fe21945b458a75e39f11dd832;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9396885633468628
200;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Contradicts;0.9966832995414734
201;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Contradicts;0.7578295469284058
202;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Contradicts;0.9638046622276306
203;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Contradicts;0.5941295027732849
204;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;https://github.com/torvalds/linux/commit/4358997ae38a1901498d128d6508119d9f318b36;Contradicts;0.6349170804023743
205;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Contradicts;0.5174017548561096
206;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Contradicts;0.5088992714881897
207;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Contradicts;0.9203083515167236
208;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Contradicts;0.5816338062286377
209;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Contradicts;0.5086758732795715
210;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.8544471263885498
211;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;Contradicts;0.7229362726211548
212;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.596187949180603
213;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Contradicts;0.8181211948394775
214;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Contradicts;0.8255009055137634
215;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;Contradicts;0.676793098449707
216;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6173444390296936
217;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.5264031887054443
218;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;make it as simple and predictable as possible;so the results are better understood and we end up killing the task which will lead to the most memory freeing while still respecting the fine-tuning from userspace;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.6478832364082336
219;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.9507530331611632
220;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Using SCHED_FIFO:1 with the lowest RT priority;This task wont interfere with any running RT task;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Contradicts;0.5797135233879089
221;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.9361679553985596
222;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.9911165237426758
223;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Share the same oom_score_adj;As a result;https://github.com/torvalds/linux/commit/44a70adec910d6929689e42b6e5cee5b7d202d20;Contradicts;0.7898758053779602
224;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6116501688957214
225;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;Contradicts;0.767618715763092
226;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.9738510847091676
227;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.9439813494682312
228;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;https://github.com/torvalds/linux/commit/e1e12d2f3104be886073ac6c5c4678f30b1b9e51;Contradicts;0.5319575667381287
229;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;remove deprecated oom_adj;deprecated;https://github.com/torvalds/linux/commit/01dc52ebdf472f77cca623ca693ca24cfc0f1bbe;Contradicts;0.8621535301208496
230;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.5464189052581787
231;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.8402546048164368
232;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Contradicts;0.5544295907020569
233;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.8213157653808594
234;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.8245332837104797
235;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;do not attempt to reap a task twice;do not attempt to reap a task twice;https://github.com/torvalds/linux/commit/8496afaba93ece80a83cbd096f0675a1020ddfc4;Contradicts;0.5731094479560852
236;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.9006791710853577
237;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.6431556344032288
238;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.8117415904998779
239;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.9475558996200562
240;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5613440871238708
241;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.5072160363197327
242;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.7852793335914612
243;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.6834812164306641
244;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.8454820513725281
245;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9779118299484252
246;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;Contradicts;0.5510949492454529
247;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.6284799575805664
248;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;Contradicts;0.7982139587402344
249;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.987362265586853
250;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;Contradicts;0.6132139563560486
251;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;remove the wrong check along with pr_info();wrong check along with pr_info();https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Contradicts;0.8091573119163513
252;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5316396355628967
253;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;remove unnecessary variable;unnecessary;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;Contradicts;0.6552190780639648
254;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.7368077635765076
255;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6543951034545898
256;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5876936316490173
257;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9813884496688844
258;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.7786041498184204
259;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;remove pointless kthread_run() error check;pointless;https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7495121359825134
260;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.8148419260978699
261;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.6188775300979614
262;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7575823664665222
263;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;hold tasklist_lock;tsk->sighand is not guarded by RCU, just as what out_of_memory() does.;https://github.com/torvalds/linux/commit/e115f2d89253490fb2dbf304b627f8d908df26f1;Contradicts;0.6349077820777893
264;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.7714052796363831
265;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.6939276456832886
266;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.802994966506958
267;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.5217251777648926
268;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.8125206828117371
269;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.648474395275116
270;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.8152616024017334
271;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;https://github.com/torvalds/linux/commit/2314b42db67be30b747122d65c6cd2c85da34538;Contradicts;0.6286446452140808
272;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7190294861793518
273;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;remove unnecessary exit_state check;unnecessary;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.859663724899292
274;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5926604866981506
275;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.7677332162857056
276;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6476388573646545
277;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5970980525016785
278;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.8113580942153931
279;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5478546023368835
280;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5778185725212097
281;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.7096055150032043
282;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Change oom_kill.c to use for_each_thread();rather than the racy while_each_thread() which can loop forever if we race with exit;https://github.com/torvalds/linux/commit/1da4db0cd5c8a31d4468ec906b413e75e604b465;Contradicts;0.5169075131416321
283;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;convert it to atomic_long_t;to avoid races;https://github.com/torvalds/linux/commit/e1f56c89b040134add93f686931cc266541d239a;Contradicts;0.7749158143997192
284;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.94785737991333
285;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.8550904989242554
286;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Remove the unused arguments and update all callers.;unused.;https://github.com/torvalds/linux/commit/a72afd873089c697053e9daa85ff343b3140d2e7;Contradicts;0.7721549272537231
287;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Remove the unused arguments and update all callers.;unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;Contradicts;0.7721549272537231
288;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.5211247801780701
289;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.6555965542793274
290;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.8211069107055664
291;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5923219323158264
292;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;Contradicts;0.7868519425392151
293;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6510270833969116
294;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6877041459083557
295;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.609764575958252
296;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7421265244483948
297;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.550682008266449
298;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.8805572986602783
299;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.5161606669425964
300;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.9819970726966858
301;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.6007627844810486
302;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;delete unlock_range();exit_mmap() does not need locked_vm updates;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.6800089478492737
303;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.8752052783966064
304;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;no reason to invoke it again from the #PF path;if the OOM killer has been already invoked;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.5136901140213013
305;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.5883660912513733
306;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;https://github.com/torvalds/linux/commit/337546e83fc7e50917f44846beee936abb9c9f1f;Contradicts;0.5043007135391235
307;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.9531184434890748
308;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.545067310333252
309;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;Contradicts;0.746599555015564
310;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.8128507733345032
311;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.8856900930404663
312;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.9295704364776612
313;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.9917199611663818
314;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.918536365032196
315;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.7220906019210815
316;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.893593966960907
317;"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;https://github.com/torvalds/linux/commit/3ef22dfff2390e75b379f9715388a852aa56e0d5;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6947693824768066
318;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;Contradicts;0.5555909276008606
319;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.7105792760848999
320;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6798891425132751
321;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5736898183822632
322;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.7288244962692261
323;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5744442939758301
324;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;https://github.com/torvalds/linux/commit/1da4db0cd5c8a31d4468ec906b413e75e604b465;Contradicts;0.9703565239906312
325;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;improve that even further;there is a common pattern to do a range lookup first and then do something about that;https://github.com/torvalds/linux/commit/93065ac753e4443840a057bfef4be71ec766fde9;Contradicts;0.5532675385475159
326;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This patch fixes the problem and should be backported into stable/LTS.;Fixes the problem, should be backported into stable/LTS.;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.9750211238861084
327;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5353365540504456
328;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.6219654679298401
329;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This patch fixes the issue by introducing a new MMF_OOM_KILLED mm flag which is set in oom_kill_process atomically and oom reaper is disabled if the flag was already set.;Fixes the issue by introducing a new MMF_OOM_KILLED mm flag and disabling the oom reaper if the flag was already set.;https://github.com/torvalds/linux/commit/855b018325737f7691f9b7d86339df40aa4e47c3;Contradicts;0.9187994599342346
330;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5682768821716309
331;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;https://github.com/torvalds/linux/commit/4358997ae38a1901498d128d6508119d9f318b36;Contradicts;0.5274351239204407
332;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.7349801063537598
333;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Contradicts;0.5619752407073975
334;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.7297375798225403
335;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Provides more debug info when the system is OOM;More debug info, system is OOM;https://github.com/torvalds/linux/commit/578c2fd6a7f378434655e5c480e23152a3994404;Contradicts;0.555236279964447
336;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.5667310953140259
337;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Contradicts;0.6155425906181335
338;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;moves the kernel log message to a higher level;verbosity is not always emitted here;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;Contradicts;0.5995448231697083
339;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Contradicts;0.7013276219367981
340;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.7249562740325928
341;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.6747375130653381
342;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.5137771368026733
343;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.8574560284614563
344;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.8430608510971069
345;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6747250556945801
346;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.6640658378601074
347;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.9243658185005188
348;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Contradicts;0.523321270942688
349;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.7685357928276062
350;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.5344153046607971
351;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Contradicts;0.6024497747421265
352;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5620603561401367
353;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5863880515098572
354;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5866098999977112
355;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.5490986108779907
356;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.777397632598877
357;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;Contradicts;0.6081773042678833
358;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9019536375999452
359;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.7181154489517212
360;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.958897054195404
361;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;Contradicts;0.6192123293876648
362;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9940211176872252
363;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5091769695281982
364;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.5167148113250732
365;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.9812545776367188
366;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5780810117721558
367;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.8985994458198547
368;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5000444650650024
369;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5255672931671143
370;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.527386486530304
371;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.9551612138748168
372;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5545119047164917
373;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.8922604322433472
374;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5759927034378052
375;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Contradicts;0.7211065888404846
376;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;Contradicts;0.7166565656661987
377;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.798308253288269
378;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5352754592895508
379;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5935094356536865
380;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.944205641746521
381;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.8423307538032532
382;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.59750896692276
383;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.743386447429657
384;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.9412422776222228
385;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Contradicts;0.6973139047622681
386;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.7450696229934692
387;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.874068021774292
388;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5587760806083679
389;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8268438577651978
390;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5094000697135925
391;Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.8141553997993469
392;Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.7353084683418274
393;Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5450001955032349
394;Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.5609498620033264
395;Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.507479190826416
396;Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7263230085372925
397;Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5832400321960449
398;Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9296677708625792
399;Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5839280486106873
400;Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6012836694717407
401;Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5323866605758667
402;Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.750801682472229
403;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.8050363063812256
404;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Provides more debug info when the system is OOM;More debug info, system is OOM;https://github.com/torvalds/linux/commit/578c2fd6a7f378434655e5c480e23152a3994404;Contradicts;0.6117565631866455
405;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;https://github.com/torvalds/linux/commit/ad915c432eccb482427c1bbd77c74e6f7bfe60b3;Contradicts;0.5492246747016907
406;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.5633801221847534
407;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.6310483813285828
408;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.8841930031776428
409;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.6439679265022278
410;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.955550730228424
411;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.9055674076080322
412;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Contradicts;0.5586622357368469
413;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;Contradicts;0.5997211933135986
414;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.6425846219062805
415;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;problem mentioned above can be found;How it works in practice;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;Contradicts;0.7083243131637573
416;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.7708680629730225
417;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5679534673690796
418;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;Contradicts;0.9210808873176576
419;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.536471426486969
420;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5031397342681885
421;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5447218418121338
422;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Contradicts;0.70512855052948
423;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.8159652352333069
424;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5239763855934143
425;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.8237172365188599
426;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.8829024434089661
427;ruling out the OOM killer;lockup machine in most of the cases;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.7469611167907715
428;callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Contradicts;0.543114185333252
429;callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.5316619277000427
430;callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.688370943069458
431;callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.5070953965187073
432;callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5367239713668823
433;callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.8498472571372986
434;callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.5607653856277466
435;callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.527880847454071
436;callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6525472402572632
437;callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.899870753288269
438;callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7719972729682922
439;callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;Contradicts;0.550973117351532
440;callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.633259117603302
441;callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.7195439338684082
442;callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.8615826368331909
443;callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;https://github.com/torvalds/linux/commit/3da88fb3bacfaa33ff9d13730d17110bb2d9604d;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6818185448646545
444;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Contradicts;0.5272354483604431
445;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Contradicts;0.7529492974281311
446;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.7673123478889465
447;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5176301598548889
448;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.7197060585021973
449;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6388785243034363
450;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6414482593536377
451;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6533641815185547
452;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8405305743217468
453;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7654532194137573
454;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.6679751873016357
455;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6772664189338684
456;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6822404265403748
457;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5938832759857178
458;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.6149768829345703
459;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.8463346362113953
460;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.7921278476715088
461;Fix the condition by checking for the head as well;checking for the head as well;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8678032755851746
462;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Contradicts;0.5720473527908325
463;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.6047490835189819
464;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.5105314254760742
465;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.5892204642295837
466;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Contradicts;0.5207965970039368
467;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Contradicts;0.5989581346511841
468;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Contradicts;0.5251595377922058
469;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.5677165985107422
470;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Share the same oom_score_adj;As a result;https://github.com/torvalds/linux/commit/44a70adec910d6929689e42b6e5cee5b7d202d20;Contradicts;0.5026683807373047
471;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.773030161857605
472;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6032373905181885
473;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Contradicts;0.5327866673469543
474;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.7050484418869019
475;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.864827573299408
476;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.8136154413223267
477;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.589554488658905
478;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7165263295173645
479;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.627513587474823
480;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5115665793418884
481;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7993466854095459
482;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.5130415558815002
483;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6070698499679565
484;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8339388370513916
485;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.7561399936676025
486;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.8267688751220703
487;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.5496645569801331
488;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5028964877128601
489;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.8298147320747375
490;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7496808767318726
491;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.731850266456604
492;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5757979154586792
493;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5396240949630737
494;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7479422688484192
495;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5405250191688538
496;"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;https://github.com/torvalds/linux/commit/af8e15cc85a253155fdcea707588bf6ddfc0be2e;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8071237206459045
497;protect oom_reaper_list using simpler way;simpler way;https://github.com/torvalds/linux/commit/bb29902a7515208846114b3b36a4281a9bbf766a;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Contradicts;0.6513234972953796
498;protect oom_reaper_list using simpler way;simpler way;https://github.com/torvalds/linux/commit/bb29902a7515208846114b3b36a4281a9bbf766a;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.8074754476547241
499;protect oom_reaper_list using simpler way;simpler way;https://github.com/torvalds/linux/commit/bb29902a7515208846114b3b36a4281a9bbf766a;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Contradicts;0.5151676535606384
500;protect oom_reaper_list using simpler way;simpler way;https://github.com/torvalds/linux/commit/bb29902a7515208846114b3b36a4281a9bbf766a;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5523965358734131
501;protect oom_reaper_list using simpler way;simpler way;https://github.com/torvalds/linux/commit/bb29902a7515208846114b3b36a4281a9bbf766a;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5533469915390015
502;protect oom_reaper_list using simpler way;simpler way;https://github.com/torvalds/linux/commit/bb29902a7515208846114b3b36a4281a9bbf766a;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7216773629188538
503;protect oom_reaper_list using simpler way;simpler way;https://github.com/torvalds/linux/commit/bb29902a7515208846114b3b36a4281a9bbf766a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.926712691783905
504;protect oom_reaper_list using simpler way;simpler way;https://github.com/torvalds/linux/commit/bb29902a7515208846114b3b36a4281a9bbf766a;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.6609372496604919
505;protect oom_reaper_list using simpler way;simpler way;https://github.com/torvalds/linux/commit/bb29902a7515208846114b3b36a4281a9bbf766a;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5543509721755981
506;protect oom_reaper_list using simpler way;simpler way;https://github.com/torvalds/linux/commit/bb29902a7515208846114b3b36a4281a9bbf766a;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7114366292953491
507;protect oom_reaper_list using simpler way;simpler way;https://github.com/torvalds/linux/commit/bb29902a7515208846114b3b36a4281a9bbf766a;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.61195969581604
508;protect oom_reaper_list using simpler way;simpler way;https://github.com/torvalds/linux/commit/bb29902a7515208846114b3b36a4281a9bbf766a;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5025328397750854
509;protect oom_reaper_list using simpler way;simpler way;https://github.com/torvalds/linux/commit/bb29902a7515208846114b3b36a4281a9bbf766a;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5348961353302002
510;protect oom_reaper_list using simpler way;simpler way;https://github.com/torvalds/linux/commit/bb29902a7515208846114b3b36a4281a9bbf766a;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5055518746376038
511;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;avoid unnecessary system-wide-oom-killer;unnecessary;https://github.com/torvalds/linux/commit/a636b327f731143ccc544b966cfd8de6cb6d72c6;Contradicts;0.7582922577857971
512;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Contradicts;0.7894116640090942
513;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Contradicts;0.705562949180603
514;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Contradicts;0.620368480682373
515;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.8268657922744751
516;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Contradicts;0.9194631576538086
517;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;Contradicts;0.804192304611206
518;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;save roots task;better to save;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5965717434883118
519;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;introduce a new user interface to tune it;Because of the change in the badness() heuristics baseline;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.568226158618927
520;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;introduce helper function to process threads during scan;to process threads during scan;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;Contradicts;0.6306211352348328
521;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.9947677850723268
522;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.5438182950019836
523;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;Contradicts;0.9950201511383056
524;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.6653992533683777
525;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.8249056339263916
526;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Contradicts;0.5542934536933899
527;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;Contradicts;0.5180260539054871
528;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9274020195007324
529;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.8293581008911133
530;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5989735722541809
531;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;modify implementation of per-mm counter;reducing patch size in future patch;https://github.com/torvalds/linux/commit/d559db086ff5be9bcc259e5aa50bf3d881eaf1d1;Contradicts;0.5081539154052734
532;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6800317764282227
533;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5577399730682373
534;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.794012725353241
535;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.9835031032562256
536;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.7967547178268433
537;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.509259819984436
538;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7731319069862366
539;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;reconstruct a list of nodes;performance considerations do not matter much;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5671997666358948
540;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Add comments describing oom_locks scope;describing oom_locks scope;https://github.com/torvalds/linux/commit/a195d3f5b74f3f45a6742f9063b5e95a2522b46d;Contradicts;0.581251323223114
541;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;allow privileged processes to receive SIGIO on files theyre manipulating;privileged processes;https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.6001114845275879
542;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Introduce a struct zoneref to store a zone pointer and a zone index;Store a zone pointer and a zone index;https://github.com/torvalds/linux/commit/dd1a239f6f2d4d3eedd318583ec319aa145b324c;Contradicts;0.6306449770927429
543;Kill current;It is better than another task needlessly.;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;prevent unnecessary oom kills or kernel panics;unnecessary oom kills or kernel panics;https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.9552693367004396
544;set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;https://github.com/torvalds/linux/commit/4358997ae38a1901498d128d6508119d9f318b36;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.6665450930595398
545;set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;https://github.com/torvalds/linux/commit/4358997ae38a1901498d128d6508119d9f318b36;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.6047351360321045
546;set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;https://github.com/torvalds/linux/commit/4358997ae38a1901498d128d6508119d9f318b36;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.6327135562896729
547;set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;https://github.com/torvalds/linux/commit/4358997ae38a1901498d128d6508119d9f318b36;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5643754005432129
548;set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;https://github.com/torvalds/linux/commit/4358997ae38a1901498d128d6508119d9f318b36;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6638649106025696
549;set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;https://github.com/torvalds/linux/commit/4358997ae38a1901498d128d6508119d9f318b36;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6030317544937134
550;set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;https://github.com/torvalds/linux/commit/4358997ae38a1901498d128d6508119d9f318b36;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7910563945770264
551;set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;https://github.com/torvalds/linux/commit/4358997ae38a1901498d128d6508119d9f318b36;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6623838543891907
552;set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;https://github.com/torvalds/linux/commit/4358997ae38a1901498d128d6508119d9f318b36;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6035068035125732
553;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.524837076663971
554;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.8892794847488403
555;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.5407810211181641
556;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Contradicts;0.5846652984619141
557;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Contradicts;0.5464136004447937
558;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.913429856300354
559;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Contradicts;0.5252935290336609
560;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.5119006633758545
561;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Contradicts;0.5234991908073425
562;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Contradicts;0.5000030398368835
563;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.5529171228408813
564;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.8376909494400024
565;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.6570565700531006
566;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5717795491218567
567;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6938360929489136
568;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.6694126129150391
569;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5059866905212402
570;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.9717594981193542
571;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7607485055923462
572;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.6836681365966797
573;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.5463683605194092
574;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.6591401696205139
575;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.7732081413269043
576;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.6067041754722595
577;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Contradicts;0.5199646353721619
578;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5941012501716614
579;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.6263192892074585
580;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.8018196821212769
581;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5812504887580872
582;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.695330798625946
583;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.6750051975250244
584;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6681152582168579
585;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.8415536284446716
586;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6079936623573303
587;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9910535216331482
588;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.7971777319908142
589;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5232950448989868
590;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.9200347065925598
591;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5704452395439148
592;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;hide it behind the helpers;With pid namespaces this field is now dangerous to use explicitly;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;Contradicts;0.5064225196838379
593;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;https://github.com/torvalds/linux/commit/b460cbc581a53cc088ceba80608021dd49c63c43;Contradicts;0.5795605182647705
594;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.8417377471923828
595;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5405722856521606
596;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5605862736701965
597;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5331642627716064
598;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.9365676641464232
599;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5278288722038269
600;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.7335237860679626
601;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.5941693186759949
602;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.8985719084739685
603;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.5374711751937866
604;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6355127692222595
605;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;dump stack of victim when reaping failed;reaping failed;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.5910622477531433
606;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.7335317730903625
607;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9117072224617004
608;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5118905305862427
609;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5010705590248108
610;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6013696789741516
611;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.526153028011322
612;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6722869277000427
613;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.8803170323371887
614;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5148906111717224
615;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5476834177970886
616;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;no reason to invoke it again from the #PF path;if the OOM killer has been already invoked;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.6491701006889343
617;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.8663893938064575
618;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5211637020111084
619;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6340842247009277
620;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.7265512943267822
621;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.6748049855232239
622;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9834356904029846
623;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5320158004760742
624;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5533402562141418
625;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.7601379752159119
626;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5972176194190979
627;"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;https://github.com/torvalds/linux/commit/7b98c2e402eaa1f2beec18b1bde17f74948a19db;avoid attempting to kill init sharing same memory;avoid attempting to kill init;https://github.com/torvalds/linux/commit/a2b829d95958da2025ef844c0f53ac15ad720fac;Contradicts;0.5053649544715881
628;"fix
";use find_lock_task_mm too;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Contradicts;0.5384413599967957
629;"fix
";use find_lock_task_mm too;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5541892051696777
630;"fix
";use find_lock_task_mm too;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5385656356811523
631;"fix
";use find_lock_task_mm too;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.7016866207122803
632;"fix
";use find_lock_task_mm too;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6817287802696228
633;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Contradicts;0.8576382994651794
634;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.5771868228912354
635;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.5124281048774719
636;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.777984619140625
637;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.7577721476554871
638;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6258476376533508
639;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.6285171508789062
640;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.6437473297119141
641;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6110344529151917
642;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.7250199317932129
643;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.548363983631134
644;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6592510342597961
645;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.5867002606391907
646;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.8549309968948364
647;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5098205208778381
648;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.6036384701728821
649;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.6193315982818604
650;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.6080464124679565
651;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5061241984367371
652;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.874089777469635
653;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.8721643090248108
654;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.8131140470504761
655;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9266798496246338
656;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.6192380785942078
657;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;remove pointless kthread_run() error check;pointless;https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5386041402816772
658;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5243474245071411
659;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6834531426429749
660;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6468546390533447
661;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7676518559455872
662;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.5624634623527527
663;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.737265944480896
664;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6496968865394592
665;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.9339048862457277
666;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.617038369178772
667;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5535575747489929
668;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.7006283402442932
669;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7148285508155823
670;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5038334727287292
671;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6304898262023926
672;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5979214310646057
673;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.6466134190559387
674;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5147976279258728
675;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.5478342771530151
676;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5365442633628845
677;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;This patch causes only memory information to be displayed for nodes that are allowed by currents cpuset when dumping the VM state;to prevent verbosity that can be harmful and cause other important messages to be scrolled from the kernel log and incur a significant time delay;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.8787475824356079
678;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.6113382577896118
679;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6522499918937683
680;When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.8625870943069458
681;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.6175557374954224
682;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.5046188831329346
683;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.5220600366592407
684;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;https://github.com/torvalds/linux/commit/ad915c432eccb482427c1bbd77c74e6f7bfe60b3;Contradicts;0.6593173146247864
685;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Contradicts;0.7046196460723877
686;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.8979346752166748
687;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.6145124435424805
688;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6672163009643555
689;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6380155086517334
690;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5069027543067932
691;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;Contradicts;0.5600965023040771
692;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.7261959314346313
693;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.6398249864578247
694;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8752833604812622
695;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5455169081687927
696;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9185174703598022
697;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.5341836214065552
698;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6061450242996216
699;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5236542224884033
700;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5489908456802368
701;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;integrate them and add some comment to struct alloc_context;reduce future confusion about the meaning of this variable;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6717544794082642
702;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5476623177528381
703;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6337438821792603
704;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5945666432380676
705;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5245407223701477
706;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5673970580101013
707;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7670563459396362
708;remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;https://github.com/torvalds/linux/commit/c81fac5cb8c92b8b4795ac250a46c7514d1fce06;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.534852921962738
709;The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.6292279362678528
710;The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6572226881980896
711;The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5003576278686523
712;The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.6068387031555176
713;The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.953536868095398
714;The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5021003484725952
715;The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7121455073356628
716;The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7787615656852722
717;The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5679370760917664
718;The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.508328914642334
719;The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Update the comments for __oom_kill_task();to reflect the code changes;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;Contradicts;0.5202275514602661
720;The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5208412408828735
721;The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6030976176261902
722;The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7053828835487366
723;The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5333587527275085
724;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.8220741152763367
725;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6370412111282349
726;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.6590768098831177
727;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6056644916534424
728;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7993376851081848
729;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.6722467541694641
730;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.6443276405334473
731;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.6130369305610657
732;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9029066562652588
733;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.8623373508453369
734;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;fixes the arg for mem_cgroup_print_oom_info();fixes;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;Contradicts;0.5360605120658875
735;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7635936737060547
736;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.8000710606575012
737;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Update the comments for __oom_kill_task();to reflect the code changes;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;Contradicts;0.512519121170044
738;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.6541142463684082
739;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6148276925086975
740;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;remove unnecessary exit_state check;unnecessary;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.5371017456054688
741;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5734126567840576
742;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6783834099769592
743;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6463859677314758
744;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Add comments describing oom_locks scope;describing oom_locks scope;https://github.com/torvalds/linux/commit/a195d3f5b74f3f45a6742f9063b5e95a2522b46d;Contradicts;0.5690667629241943
745;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7506369948387146
746;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;delete the corresponding comment;it will be checked in oom_unkillable_task();https://github.com/torvalds/linux/commit/f8159c13905bba26f3e1782a521dacf7a66fc1ce;Contradicts;0.527674674987793
747;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7908412218093872
748;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5001440644264221
749;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;considered a reasonable constrain;the overall system health is more important than debugability of a particular application;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6282238364219666
750;An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;https://github.com/torvalds/linux/commit/74ab7f1d3f22ccb02f8b14f1f2375416b1ab0adb;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.533536970615387
751;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.6735295653343201
752;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Contradicts;0.5958858728408813
753;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;https://github.com/torvalds/linux/commit/ad915c432eccb482427c1bbd77c74e6f7bfe60b3;Contradicts;0.7264343500137329
754;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Contradicts;0.6304064393043518
755;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.8954254388809204
756;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.6009036898612976
757;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6019132733345032
758;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6655139327049255
759;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5051847696304321
760;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.7831922173500061
761;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5048961043357849
762;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;Contradicts;0.5150413513183594
763;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.883140504360199
764;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.8122165203094482
765;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6803221106529236
766;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9812068343162536
767;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.6465994119644165
768;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6179803609848022
769;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7980029582977295
770;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5527757406234741
771;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5369700193405151
772;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7004773020744324
773;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5936042666435242
774;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.6676815152168274
775;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5881462693214417
776;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5089005827903748
777;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7001293301582336
778;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.505940318107605
779;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5276476144790649
780;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.9070448279380798
781;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Contradicts;0.9113215208053588
782;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.7511166334152222
783;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Contradicts;0.683138370513916
784;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.678719699382782
785;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Contradicts;0.5146021842956543
786;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.9338172078132628
787;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Contradicts;0.9693599343299866
788;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.509900689125061
789;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.7155227065086365
790;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.6243337988853455
791;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;Contradicts;0.6752973198890686
792;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7648406624794006
793;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5773897171020508
794;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.588289201259613
795;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8302821516990662
796;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.8160424828529358
797;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5789467096328735
798;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;https://github.com/torvalds/linux/commit/2314b42db67be30b747122d65c6cd2c85da34538;Contradicts;0.5833033323287964
799;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5516713261604309
800;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.51214998960495
801;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.7466458082199097
802;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6451175212860107
803;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Contradicts;0.5676542520523071
804;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;Contradicts;0.7684338092803955
805;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5146317481994629
806;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.5034244656562805
807;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7994717955589294
808;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5797309875488281
809;oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.5350651144981384
810;oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;Contradicts;0.5141642689704895
811;oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5003540515899658
812;oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7877551913261414
813;oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.932440221309662
814;oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5555902123451233
815;oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5517606735229492
816;oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.7910784482955933
817;oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5034129023551941
818;oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";https://github.com/torvalds/linux/commit/dd8e8f405ca386c7ce7cbb996ccd985d283b0e03;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6971867084503174
819;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Contradicts;0.8584563732147217
820;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.7026445269584656
821;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.581209659576416
822;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5783094763755798
823;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7793494462966919
824;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Contradicts;0.6036962270736694
825;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.6119897365570068
826;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.604832112789154
827;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6869312524795532
828;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6792253255844116
829;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5822399258613586
830;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5212540030479431
831;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5370051264762878
832;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.5577483177185059
833;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7043507695198059
834;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5730637311935425
835;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5448097586631775
836;oom: PF_EXITING check should take mm into account;take mm into account;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8363174200057983
837;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7842366695404053
838;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.679715096950531
839;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.5148231983184814
840;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;Contradicts;0.6339436173439026
841;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.6751012802124023
842;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9319572448730468
843;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Contradicts;0.8251869678497314
844;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9083641767501832
845;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.5160675048828125
846;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8268558382987976
847;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5828632712364197
848;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.5812499523162842
849;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.6423898935317993
850;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.591346263885498
851;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6765772104263306
852;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5643380284309387
853;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.8528249263763428
854;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6577295660972595
855;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5477752089500427
856;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;https://github.com/torvalds/linux/commit/dc6c9a35b66b520cf67e05d8ca60ebecad3b0479;Contradicts;0.5309694409370422
857;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;https://github.com/torvalds/linux/commit/b52279406e77be711c068f9a8e970ea6471e089c;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.573962390422821
858;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.5794895887374878
859;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.6670722961425781
860;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.8343830704689026
861;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.7316294312477112
862;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Contradicts;0.5931016206741333
863;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6273545026779175
864;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.757199227809906
865;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Share the same oom_score_adj;As a result;https://github.com/torvalds/linux/commit/44a70adec910d6929689e42b6e5cee5b7d202d20;Contradicts;0.5059676170349121
866;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5730454325675964
867;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5312497019767761
868;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7541207671165466
869;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.5226401686668396
870;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5219756960868835
871;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.7613638043403625
872;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6996986865997314
873;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Contradicts;0.5041460394859314
874;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6101396679878235
875;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7564889788627625
876;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6485823392868042
877;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8552205562591553
878;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6117752194404602
879;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.7269489765167236
880;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7887541651725769
881;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.673168957233429
882;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.8391424417495728
883;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.737858235836029
884;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9082111716270448
885;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.7339091897010803
886;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.5266971588134766
887;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6036400198936462
888;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7495320439338684
889;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6343787312507629
890;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6231436133384705
891;Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7554368376731873
892;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.6757127046585083
893;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.5300857424736023
894;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5311760306358337
895;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6529232859611511
896;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5031188130378723
897;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.8336788415908813
898;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.536515474319458
899;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.6878252029418945
900;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5672305822372437
901;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5850757360458374
902;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8568044900894165
903;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.716714084148407
904;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.517970085144043
905;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5222126245498657
906;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.6944435834884644
907;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5134082436561584
908;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.90660297870636
909;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5719437599182129
910;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.5584067106246948
911;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6019406318664551
912;update users of gfp and slab facilities include those headers directly;Prepare for this change;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5985672473907471
913;As this conversion needs to touch large number of source files;needs to touch large number of source files;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.635573148727417
914;As this conversion needs to touch large number of source files;needs to touch large number of source files;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5117447972297668
915;As this conversion needs to touch large number of source files;needs to touch large number of source files;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;fix constraint deadlock;constraint deadlock;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.508404016494751
916;As this conversion needs to touch large number of source files;needs to touch large number of source files;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5114729404449463
917;As this conversion needs to touch large number of source files;needs to touch large number of source files;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5723384618759155
918;As this conversion needs to touch large number of source files;needs to touch large number of source files;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.907711148262024
919;As this conversion needs to touch large number of source files;needs to touch large number of source files;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6465063691139221
920;As this conversion needs to touch large number of source files;needs to touch large number of source files;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6083388924598694
921;As this conversion needs to touch large number of source files;needs to touch large number of source files;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5061640739440918
922;As this conversion needs to touch large number of source files;needs to touch large number of source files;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5772706866264343
923;As this conversion needs to touch large number of source files;needs to touch large number of source files;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5525439381599426
924;As this conversion needs to touch large number of source files;needs to touch large number of source files;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5136011838912964
925;As this conversion needs to touch large number of source files;needs to touch large number of source files;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5531618595123291
926;only the necessary includes are there;necessary;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Put the new include;Conform to its surrounding;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6729095578193665
927;only the necessary includes are there;necessary;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.628269374370575
928;only the necessary includes are there;necessary;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Contradicts;0.5338811278343201
929;only the necessary includes are there;necessary;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5448158979415894
930;only the necessary includes are there;necessary;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Contradicts;0.7752235531806946
931;only the necessary includes are there;necessary;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.632178783416748
932;only the necessary includes are there;necessary;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5383588075637817
933;only the necessary includes are there;necessary;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5711188912391663
934;only the necessary includes are there;necessary;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6972659826278687
935;only the necessary includes are there;necessary;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.9689728021621704
936;only the necessary includes are there;necessary;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.7553654909133911
937;only the necessary includes are there;necessary;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5142349600791931
938;only the necessary includes are there;necessary;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5607067942619324
939;only the necessary includes are there;necessary;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5354973673820496
940;Put the new include;Conform to its surrounding;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Contradicts;0.5395590662956238
941;Put the new include;Conform to its surrounding;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;Contradicts;0.5257155299186707
942;Put the new include;Conform to its surrounding;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5279214978218079
943;Put the new include;Conform to its surrounding;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5124527812004089
944;Put the new include;Conform to its surrounding;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.5195374488830566
945;Put the new include;Conform to its surrounding;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5893632769584656
946;Put the new include;Conform to its surrounding;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5522716641426086
947;Put the new include;Conform to its surrounding;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.575249195098877
948;Put the new include;Conform to its surrounding;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;remove a stale code;quick fixup;https://github.com/torvalds/linux/commit/9bfe5ded054b8e28a94c78580f233d6879a00146;Contradicts;0.6351868510246277
949;Put the new include;Conform to its surrounding;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.8569324612617493
950;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.7684244513511658
951;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.620778501033783
952;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6102381944656372
953;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.6898921132087708
954;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5607831478118896
955;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.8025614023208618
956;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5965794324874878
957;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.5229860544204712
958;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.7227210998535156
959;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5776126384735107
960;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.508639931678772
961;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7272482514381409
962;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.8120184540748596
963;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5422658920288086
964;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5366223454475403
965;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8254223465919495
966;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5937153100967407
967;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.8224002122879028
968;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6820877194404602
969;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6282970309257507
970;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5049169063568115
971;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Contradicts;0.5740563869476318
972;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.7008189558982849
973;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.9610901474952698
974;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Contradicts;0.6035925149917603
975;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Contradicts;0.5513019561767578
976;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.5758075714111328
977;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;save roots task;better to save;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5252851843833923
978;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.5692921876907349
979;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.6289132237434387
980;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Share the same oom_score_adj;As a result;https://github.com/torvalds/linux/commit/44a70adec910d6929689e42b6e5cee5b7d202d20;Contradicts;0.7764025330543518
981;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.6229154467582703
982;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7880958914756775
983;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;remove deprecated oom_adj;deprecated;https://github.com/torvalds/linux/commit/01dc52ebdf472f77cca623ca693ca24cfc0f1bbe;Contradicts;0.6608152985572815
984;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.5972935557365417
985;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.8535394668579102
986;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.6751440167427063
987;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.532465934753418
988;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.513092041015625
989;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6213259100914001
990;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.6656408905982971
991;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5617479681968689
992;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6144915223121643
993;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.603665828704834
994;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9280883073806764
995;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.548995852470398
996;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.9687054753303528
997;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.9203228950500488
998;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5823676586151123
999;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8687065839767456
1000;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5421106219291687
1001;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6242454051971436
1002;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8007043600082397
1003;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.5682824850082397
1004;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.811281144618988
1005;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6584838032722473
1006;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5066857933998108
1007;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.707730233669281
1008;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.5130339860916138
1009;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7667533755302429
1010;moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5220665335655212
1011;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Contradicts;0.8202014565467834
1012;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.7963376641273499
1013;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;Contradicts;0.6907069683074951
1014;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.5900605320930481
1015;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Contradicts;0.544873833656311
1016;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Contradicts;0.5314492583274841
1017;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.6874794363975525
1018;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.5601145625114441
1019;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;Contradicts;0.5267161726951599
1020;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.532752275466919
1021;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.5918744802474976
1022;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.5769675374031067
1023;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.5603477358818054
1024;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.5116088390350342
1025;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5544512867927551
1026;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5481783747673035
1027;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.6132177114486694
1028;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.855772078037262
1029;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.5432751178741455
1030;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.6101499795913696
1031;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7427622079849243
1032;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.840155839920044
1033;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.880922257900238
1034;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.8534320592880249
1035;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9721770882606506
1036;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.704445481300354
1037;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.7099359631538391
1038;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7401623725891113
1039;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Contradicts;0.8130257725715637
1040;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6559537649154663
1041;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8456438779830933
1042;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.5726914405822754
1043;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.6631965041160583
1044;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5444351434707642
1045;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7436568737030029
1046;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5030906796455383
1047;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6409382224082947
1048;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.7541266679763794
1049;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6441357135772705
1050;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6897827386856079
1051;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.8371961116790771
1052;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5050432682037354
1053;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6664552092552185
1054;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.8192036747932434
1055;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7366010546684265
1056;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6652500629425049
1057;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7620211839675903
1058;"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;https://github.com/torvalds/linux/commit/35451beecbd7c86ce3249d543594517a5fe9a0cd;avoid attempting to kill init sharing same memory;avoid attempting to kill init;https://github.com/torvalds/linux/commit/a2b829d95958da2025ef844c0f53ac15ad720fac;Contradicts;0.5156692862510681
1059;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.6395820379257202
1060;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.7689543962478638
1061;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.7256885170936584
1062;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.5481112599372864
1063;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5070344805717468
1064;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.8968168497085571
1065;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7138879895210266
1066;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;https://github.com/torvalds/linux/commit/5a2d41961dd6815b874b5c0afec0ac96cd90eea4;Contradicts;0.5731784701347351
1067;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8639544248580933
1068;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5100396871566772
1069;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.810588538646698
1070;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5228986144065857
1071;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5613007545471191
1072;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;out_of_memory() locking fix;locking fix;https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.544557511806488
1073;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5200570821762085
1074;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.544503927230835
1075;Only oom kill exiting tasks with attached memory;oom;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5979114770889282
1076;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;Contradicts;0.5104155540466309
1077;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Contradicts;0.503734827041626
1078;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Contradicts;0.589819073677063
1079;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;Contradicts;0.743838906288147
1080;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.7706962823867798
1081;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.669978678226471
1082;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.9142308235168456
1083;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.7406467199325562
1084;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5193564295768738
1085;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6794171929359436
1086;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.8198719024658203
1087;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6447398066520691
1088;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.725745439529419
1089;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.6969922184944153
1090;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Contradicts;0.5401687622070312
1091;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.6423598527908325
1092;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.8397239446640015
1093;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5883397459983826
1094;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Contradicts;0.7697724103927612
1095;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.6471930146217346
1096;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8472565412521362
1097;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5463853478431702
1098;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.6649280190467834
1099;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5412148833274841
1100;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5312840938568115
1101;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Contradicts;0.759726345539093
1102;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9219648838043212
1103;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5211131572723389
1104;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6372831463813782
1105;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;Contradicts;0.8992900252342224
1106;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8044676184654236
1107;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.8124876022338867
1108;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.7778562307357788
1109;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;Contradicts;0.6001604795455933
1110;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.578472912311554
1111;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6501342058181763
1112;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;fix vm_oom_kill_table[];ifdeffery;https://github.com/torvalds/linux/commit/a19cad0691597eb79c123b8a19a9faba5ab7d90e;Contradicts;0.5767679810523987
1113;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5153849720954895
1114;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5123522281646729
1115;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.8548902273178101
1116;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.527692973613739
1117;it is no longer necessary to warn about killing mm-less tasks;it is a no-op;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.5510709285736084
1118;it is no longer necessary to warn about killing mm-less tasks;it is a no-op;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.7600333094596863
1119;it is no longer necessary to warn about killing mm-less tasks;it is a no-op;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6314616203308105
1120;it is no longer necessary to warn about killing mm-less tasks;it is a no-op;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;Contradicts;0.521298885345459
1121;it is no longer necessary to warn about killing mm-less tasks;it is a no-op;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Contradicts;0.5698453783988953
1122;it is no longer necessary to warn about killing mm-less tasks;it is a no-op;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5020040273666382
1123;it is no longer necessary to warn about killing mm-less tasks;it is a no-op;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5748100876808167
1124;it is no longer necessary to warn about killing mm-less tasks;it is a no-op;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6221621632575989
1125;it is no longer necessary to warn about killing mm-less tasks;it is a no-op;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8746451735496521
1126;it is no longer necessary to warn about killing mm-less tasks;it is a no-op;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6818580627441406
1127;it is no longer necessary to warn about killing mm-less tasks;it is a no-op;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;Contradicts;0.6528971791267395
1128;it is no longer necessary to warn about killing mm-less tasks;it is a no-op;https://github.com/torvalds/linux/commit/81236810226f71bd9ff77321c8e8276dae7efc61;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5436021089553833
1129;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.5437880754470825
1130;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.6266550421714783
1131;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;https://github.com/torvalds/linux/commit/ad915c432eccb482427c1bbd77c74e6f7bfe60b3;Contradicts;0.867327868938446
1132;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Contradicts;0.5705838799476624
1133;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.5566272139549255
1134;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.5275328755378723
1135;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.555432915687561
1136;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5626477599143982
1137;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.6402156352996826
1138;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.5252207517623901
1139;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5694165825843811
1140;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.6043304204940796
1141;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.6764570474624634
1142;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9120756387710572
1143;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9637935161590576
1144;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5494017601013184
1145;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6690713763237
1146;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5189633965492249
1147;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.901354432106018
1148;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5597320795059204
1149;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6943728923797607
1150;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7270506024360657
1151;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6819716691970825
1152;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.6221157312393188
1153;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7021526098251343
1154;avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.520306408405304
1155;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Contradicts;0.6392191648483276
1156;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.6950019598007202
1157;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.5546199083328247
1158;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.5430313348770142
1159;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5913610458374023
1160;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.8045144081115723
1161;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.5354325175285339
1162;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5088216066360474
1163;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5233117341995239
1164;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7538928389549255
1165;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9587295055389404
1166;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.5900847911834717
1167;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5278574228286743
1168;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8157784938812256
1169;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.7390073537826538
1170;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5425677299499512
1171;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6747347712516785
1172;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6223591566085815
1173;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5147260427474976
1174;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7359705567359924
1175;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.6061772108078003
1176;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;Contradicts;0.7808769941329956
1177;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;it can be merged into that function at the same time;__oom_kill_task() only has a single caller;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;Contradicts;0.6125354170799255
1178;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;https://github.com/torvalds/linux/commit/ad915c432eccb482427c1bbd77c74e6f7bfe60b3;Contradicts;0.5004681348800659
1179;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6677560806274414
1180;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.8956490755081177
1181;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.5735922455787659
1182;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.5461677312850952
1183;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.9952272176742554
1184;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.8975353837013245
1185;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5717800259590149
1186;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.5274310111999512
1187;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.8207902908325195
1188;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;fix constraint deadlock;constraint deadlock;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.520301342010498
1189;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.5719929933547974
1190;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8522216081619263
1191;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.50724858045578
1192;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5679653882980347
1193;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7895530462265015
1194;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8945302963256836
1195;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5960275530815125
1196;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.561758279800415
1197;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.7779582142829895
1198;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5492348074913025
1199;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5496201515197754
1200;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5548878312110901
1201;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6342231035232544
1202;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7852240800857544
1203;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5732911229133606
1204;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.6028656363487244
1205;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.8584233522415161
1206;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;make the oom_reaper thread freezable;In order to close this race;https://github.com/torvalds/linux/commit/e26796066fdf929cbba22dabb801808f986acdb9;Contradicts;0.5584709048271179
1207;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.840794563293457
1208;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Contradicts;0.5288284420967102
1209;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Contradicts;0.5935648679733276
1210;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6929785013198853
1211;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.5553463697433472
1212;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.6722492575645447
1213;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5402986407279968
1214;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7056318521499634
1215;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;Contradicts;0.6408789157867432
1216;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.6822123527526855
1217;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5401709675788879
1218;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;Contradicts;0.8695992827415466
1219;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.8021965026855469
1220;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.6287212371826172
1221;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.6838239431381226
1222;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5396885871887207
1223;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.5218151211738586
1224;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Contradicts;0.6091143488883972
1225;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7431417107582092
1226;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7381415367126465
1227;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9478530883789062
1228;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5443646907806396
1229;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.6054266095161438
1230;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.9067856669425964
1231;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.784111738204956
1232;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5052851438522339
1233;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.7357198596000671
1234;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.8106920719146729
1235;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5962788462638855
1236;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7038354277610779
1237;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.8129801750183105
1238;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5583347678184509
1239;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6930184960365295
1240;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7668067216873169
1241;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5201958417892456
1242;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;https://github.com/torvalds/linux/commit/4d8b9135c30ccbe46e621fefd862969819003fd6;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6476238369941711
1243;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Contradicts;0.6018743515014648
1244;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.6558719277381897
1245;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.9453167915344238
1246;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Contradicts;0.6002604365348816
1247;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Contradicts;0.5205603837966919
1248;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.5560576319694519
1249;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.5146532654762268
1250;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Share the same oom_score_adj;As a result;https://github.com/torvalds/linux/commit/44a70adec910d6929689e42b6e5cee5b7d202d20;Contradicts;0.7717635035514832
1251;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.6086201071739197
1252;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7541287541389465
1253;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.5721797943115234
1254;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.6055703163146973
1255;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5190035104751587
1256;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.6064395308494568
1257;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6823211312294006
1258;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6636518239974976
1259;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9370294213294984
1260;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5159890055656433
1261;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.9617614150047302
1262;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.78412926197052
1263;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6219704747200012
1264;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8148780465126038
1265;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5016936659812927
1266;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5357294678688049
1267;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7793968915939331
1268;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7547668218612671
1269;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6442232131958008
1270;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7728794813156128
1271;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7005152702331543
1272;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5862472653388977
1273;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5063705444335938
1274;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8134045600891113
1275;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5352514982223511
1276;Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.549335241317749
1277;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;Contradicts;0.7731258273124695
1278;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.8344030976295471
1279;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Contradicts;0.560167670249939
1280;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;https://github.com/torvalds/linux/commit/ad915c432eccb482427c1bbd77c74e6f7bfe60b3;Contradicts;0.8337305188179016
1281;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Contradicts;0.6193037033081055
1282;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Contradicts;0.509527325630188
1283;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.8878660202026367
1284;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;Contradicts;0.7962914109230042
1285;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5173841118812561
1286;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.7432403564453125
1287;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Contradicts;0.5142706632614136
1288;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Contradicts;0.6870310306549072
1289;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.5175997018814087
1290;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.8835561275482178
1291;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.6326372027397156
1292;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.8237264156341553
1293;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.65727299451828
1294;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;Contradicts;0.5658540725708008
1295;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7666406631469727
1296;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;Contradicts;0.663413405418396
1297;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.6460208892822266
1298;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.6586440801620483
1299;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Contradicts;0.6346898674964905
1300;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6194745302200317
1301;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;Contradicts;0.6790366172790527
1302;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;Contradicts;0.5871632099151611
1303;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8682993650436401
1304;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.7237609624862671
1305;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7686316967010498
1306;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6225264072418213
1307;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;fixes the arg for mem_cgroup_print_oom_info();fixes;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;Contradicts;0.5411199331283569
1308;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;Contradicts;0.514880895614624
1309;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Contradicts;0.6363065838813782
1310;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9897860288619996
1311;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.6324512362480164
1312;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.7397463321685791
1313;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;Contradicts;0.744959831237793
1314;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.7083034515380859
1315;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.663525402545929
1316;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5686519742012024
1317;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.7624959349632263
1318;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8576744198799133
1319;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.6768842935562134
1320;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.7962932586669922
1321;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.7231736183166504
1322;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5251778364181519
1323;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;By giving root tasks a bonus that is proportional to their actual size;they remain comparable even when relatively small;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;Contradicts;0.5141024589538574
1324;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6446603536605835
1325;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.8067344427108765
1326;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.9335047602653505
1327;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7673247456550598
1328;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Get/put across the for_each_thread() on the selected task;The easiest fix is;https://github.com/torvalds/linux/commit/cefc7ef3c87d02fc9307835868ff721ea12cc597;Contradicts;0.508033812046051
1329;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.9800918102264404
1330;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.975940763950348
1331;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6343147158622742
1332;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;Contradicts;0.5500652194023132
1333;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7052300572395325
1334;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7678893804550171
1335;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.593641996383667
1336;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7871471047401428
1337;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;mark_tsk_oom_victim is now called under task_lock;I think this should be OK because __thaw_task shouldnt interfere with any locking down wake_up_process;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.8699485659599304
1338;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;fix vm_oom_kill_table[];ifdeffery;https://github.com/torvalds/linux/commit/a19cad0691597eb79c123b8a19a9faba5ab7d90e;Contradicts;0.5300590991973877
1339;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;delete unlock_range();exit_mmap() does not need locked_vm updates;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5024501085281372
1340;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5987460613250732
1341;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Contradicts;0.5359122157096863
1342;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;Contradicts;0.5604587197303772
1343;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.7099748849868774
1344;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7257187962532043
1345;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5334411263465881
1346;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.8563452363014221
1347;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.6700835227966309
1348;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.6850618720054626
1349;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6656738519668579
1350;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.6901640295982361
1351;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.540742039680481
1352;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.8565354943275452
1353;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5332203507423401
1354;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;Contradicts;0.5157617330551147
1355;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.92540442943573
1356;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5039257407188416
1357;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Contradicts;0.605638325214386
1358;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.6432763338088989
1359;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5445030331611633
1360;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.8004776835441589
1361;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6883321404457092
1362;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.5846621990203857
1363;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7016168832778931
1364;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.92230486869812
1365;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5030430555343628
1366;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.555952787399292
1367;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7197370529174805
1368;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.5698322653770447
1369;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6973196268081665
1370;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6537679433822632
1371;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.56988924741745
1372;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6486528515815735
1373;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6738277077674866
1374;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7016083598136902
1375;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5383915901184082
1376;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5442935824394226
1377;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.8819542527198792
1378;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;make the oom_reaper thread freezable;In order to close this race;https://github.com/torvalds/linux/commit/e26796066fdf929cbba22dabb801808f986acdb9;Contradicts;0.5033769607543945
1379;Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;https://github.com/torvalds/linux/commit/2ff05b2b4eac2e63d345fc731ea151a060247f53;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6059722900390625
1380;fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;https://github.com/torvalds/linux/commit/6d2661ede5f20f968422e790af3334908c3bc857;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Contradicts;0.6579332947731018
1381;fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;https://github.com/torvalds/linux/commit/6d2661ede5f20f968422e790af3334908c3bc857;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.5488517880439758
1382;fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;https://github.com/torvalds/linux/commit/6d2661ede5f20f968422e790af3334908c3bc857;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.5515391230583191
1383;fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;https://github.com/torvalds/linux/commit/6d2661ede5f20f968422e790af3334908c3bc857;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5421500205993652
1384;fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;https://github.com/torvalds/linux/commit/6d2661ede5f20f968422e790af3334908c3bc857;Share the same oom_score_adj;As a result;https://github.com/torvalds/linux/commit/44a70adec910d6929689e42b6e5cee5b7d202d20;Contradicts;0.5366697907447815
1385;fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;https://github.com/torvalds/linux/commit/6d2661ede5f20f968422e790af3334908c3bc857;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5248507857322693
1386;fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;https://github.com/torvalds/linux/commit/6d2661ede5f20f968422e790af3334908c3bc857;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5675463080406189
1387;fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;https://github.com/torvalds/linux/commit/6d2661ede5f20f968422e790af3334908c3bc857;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.5203022956848145
1388;fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;https://github.com/torvalds/linux/commit/6d2661ede5f20f968422e790af3334908c3bc857;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8973982930183411
1389;fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;https://github.com/torvalds/linux/commit/6d2661ede5f20f968422e790af3334908c3bc857;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.849184513092041
1390;fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;https://github.com/torvalds/linux/commit/6d2661ede5f20f968422e790af3334908c3bc857;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5562528371810913
1391;fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;https://github.com/torvalds/linux/commit/6d2661ede5f20f968422e790af3334908c3bc857;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5417495965957642
1392;fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;https://github.com/torvalds/linux/commit/6d2661ede5f20f968422e790af3334908c3bc857;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.522227942943573
1393;fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;https://github.com/torvalds/linux/commit/6d2661ede5f20f968422e790af3334908c3bc857;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.7551310658454895
1394;fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;https://github.com/torvalds/linux/commit/6d2661ede5f20f968422e790af3334908c3bc857;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5990819334983826
1395;fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;https://github.com/torvalds/linux/commit/6d2661ede5f20f968422e790af3334908c3bc857;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5700320601463318
1396;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;https://github.com/torvalds/linux/commit/ad915c432eccb482427c1bbd77c74e6f7bfe60b3;Contradicts;0.5653445720672607
1397;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.5658695697784424
1398;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Contradicts;0.5378532409667969
1399;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.540352463722229
1400;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5417222380638123
1401;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.8092303276062012
1402;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Contradicts;0.7210484743118286
1403;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7619883418083191
1404;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.602943480014801
1405;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5916860103607178
1406;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;out_of_memory() locking fix;locking fix;https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5123624205589294
1407;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;account the memory consumption of the (direct) children to the father;we do want to;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5188390612602234
1408;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5449199080467224
1409;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5742253065109253
1410;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.84061598777771
1411;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5002124905586243
1412;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.5085724592208862
1413;There is no need to call for int_sqrt;if argument is 0;https://github.com/torvalds/linux/commit/a12888f772dab4bf5e6f73668dc4f5f6026a7014;Introduce a struct zoneref to store a zone pointer and a zone index;Store a zone pointer and a zone index;https://github.com/torvalds/linux/commit/dd1a239f6f2d4d3eedd318583ec319aa145b324c;Contradicts;0.5512994527816772
1414;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.8454128503799438
1415;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Contradicts;0.5941449999809265
1416;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6743550896644592
1417;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.8817073702812195
1418;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5288875102996826
1419;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.9117246270179749
1420;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5154014825820923
1421;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.939628541469574
1422;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5873883962631226
1423;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9921058416366576
1424;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6925369501113892
1425;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.6871079802513123
1426;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5733795166015625
1427;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.593672513961792
1428;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5678330063819885
1429;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6658228635787964
1430;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.7670212388038635
1431;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.6141389608383179
1432;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6143342852592468
1433;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5023103952407837
1434;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5690876245498657
1435;avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6465579271316528
1436;avoid this deadlock;This patch;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.7160258293151855
1437;avoid this deadlock;This patch;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8909358978271484
1438;avoid this deadlock;This patch;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7870815396308899
1439;avoid this deadlock;This patch;https://github.com/torvalds/linux/commit/7f4d454dee2e0bdd21bafd413d1c53e443a26540;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6127064228057861
1440;avoid unnecessary system-wide-oom-killer;unnecessary;https://github.com/torvalds/linux/commit/a636b327f731143ccc544b966cfd8de6cb6d72c6;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.6830415725708008
1441;avoid unnecessary system-wide-oom-killer;unnecessary;https://github.com/torvalds/linux/commit/a636b327f731143ccc544b966cfd8de6cb6d72c6;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Contradicts;0.5207134485244751
1442;avoid unnecessary system-wide-oom-killer;unnecessary;https://github.com/torvalds/linux/commit/a636b327f731143ccc544b966cfd8de6cb6d72c6;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.7663145661354065
1443;avoid unnecessary system-wide-oom-killer;unnecessary;https://github.com/torvalds/linux/commit/a636b327f731143ccc544b966cfd8de6cb6d72c6;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5772485136985779
1444;avoid unnecessary system-wide-oom-killer;unnecessary;https://github.com/torvalds/linux/commit/a636b327f731143ccc544b966cfd8de6cb6d72c6;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.8516669869422913
1445;avoid unnecessary system-wide-oom-killer;unnecessary;https://github.com/torvalds/linux/commit/a636b327f731143ccc544b966cfd8de6cb6d72c6;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.6783111095428467
1446;avoid unnecessary system-wide-oom-killer;unnecessary;https://github.com/torvalds/linux/commit/a636b327f731143ccc544b966cfd8de6cb6d72c6;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.5095897912979126
1447;avoid unnecessary system-wide-oom-killer;unnecessary;https://github.com/torvalds/linux/commit/a636b327f731143ccc544b966cfd8de6cb6d72c6;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8531315326690674
1448;avoid unnecessary system-wide-oom-killer;unnecessary;https://github.com/torvalds/linux/commit/a636b327f731143ccc544b966cfd8de6cb6d72c6;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5098524689674377
1449;avoid unnecessary system-wide-oom-killer;unnecessary;https://github.com/torvalds/linux/commit/a636b327f731143ccc544b966cfd8de6cb6d72c6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6466554403305054
1450;avoid unnecessary system-wide-oom-killer;unnecessary;https://github.com/torvalds/linux/commit/a636b327f731143ccc544b966cfd8de6cb6d72c6;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7156034708023071
1451;avoid unnecessary system-wide-oom-killer;unnecessary;https://github.com/torvalds/linux/commit/a636b327f731143ccc544b966cfd8de6cb6d72c6;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5211408734321594
1452;avoid unnecessary system-wide-oom-killer;unnecessary;https://github.com/torvalds/linux/commit/a636b327f731143ccc544b966cfd8de6cb6d72c6;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.7297782897949219
1453;avoid unnecessary system-wide-oom-killer;unnecessary;https://github.com/torvalds/linux/commit/a636b327f731143ccc544b966cfd8de6cb6d72c6;"Users of mmap_sem which need it for write should be carefully reviewed to use _killable waiting as much as possible and reduce allocations requests done with the lock held to absolute minimum
";to reduce the risk even further;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7218480110168457
1454;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.5607345700263977
1455;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7327899932861328
1456;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.510456919670105
1457;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5346609950065613
1458;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5619654655456543
1459;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7298069000244141
1460;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9236894845962524
1461;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.8638092279434204
1462;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7070195078849792
1463;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8388816714286804
1464;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.537667989730835
1465;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.6298630237579346
1466;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.6736057996749878
1467;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5911768674850464
1468;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5037330985069275
1469;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6189450621604919
1470;set_current_state()/schedule_timeout();to reduce kernel size;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.550701916217804
1471;keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.7452998161315918
1472;keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5382459163665771
1473;keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.707563579082489
1474;keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.6150700449943542
1475;keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6080948114395142
1476;keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.897132396697998
1477;keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6530811786651611
1478;keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5559552907943726
1479;keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6596198081970215
1480;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Contradicts;0.5334354043006897
1481;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Contradicts;0.5244067907333374
1482;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Contradicts;0.7228931188583374
1483;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;Contradicts;0.8235772848129272
1484;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.5324500799179077
1485;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5422000288963318
1486;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.6782770752906799
1487;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Contradicts;0.8766111731529236
1488;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.973744571208954
1489;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.5231226682662964
1490;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.7353079319000244
1491;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.877219021320343
1492;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.6242459416389465
1493;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7777895331382751
1494;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5868569016456604
1495;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.543163537979126
1496;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.6632578372955322
1497;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Contradicts;0.5449587106704712
1498;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5925490856170654
1499;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;fix constraint deadlock;constraint deadlock;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.516744077205658
1500;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.7350332140922546
1501;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.6969596743583679
1502;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.8799232244491577
1503;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;https://github.com/torvalds/linux/commit/3e8715fdc03e8df4d26d8e436166e44e3e416d3b;Contradicts;0.5097721815109253
1504;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;Contradicts;0.509755551815033
1505;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.9530337452888488
1506;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6497960686683655
1507;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.6828941106796265
1508;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.8416335582733154
1509;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7482898235321045
1510;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Contradicts;0.7355377674102783
1511;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8095681071281433
1512;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6363192796707153
1513;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.7530745267868042
1514;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.551373302936554
1515;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.5942302346229553
1516;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;https://github.com/torvalds/linux/commit/b460cbc581a53cc088ceba80608021dd49c63c43;Contradicts;0.7220961451530457
1517;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.6154248118400574
1518;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.8694837689399719
1519;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6981093287467957
1520;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.7702985405921936
1521;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5752868056297302
1522;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.784922182559967
1523;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.9394241571426392
1524;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.9351270794868468
1525;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5704054832458496
1526;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.7027997374534607
1527;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6488044261932373
1528;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.6459351778030396
1529;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6551182270050049
1530;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.8987600803375244
1531;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.928763747215271
1532;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.8651437759399414
1533;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.728287398815155
1534;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5787238478660583
1535;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.642319917678833
1536;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6140251159667969
1537;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.688143789768219
1538;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7846750020980835
1539;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5145854353904724
1540;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Find kill other threads that pin the same ->mm or find another task to kill.;Memory needs to be freed.;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5331359505653381
1541;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7214488983154297
1542;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;https://github.com/torvalds/linux/commit/ef08e3b4981aebf2ba9bd7025ef7210e8eec07ce;Add a missing newline;missing;https://github.com/torvalds/linux/commit/756a025f00091918d9d09ca3229defb160b409c0;Contradicts;0.5187970995903015
1543;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.6711894273757935
1544;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Contradicts;0.5565400123596191
1545;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6998109221458435
1546;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.8069908618927002
1547;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Contradicts;0.5650909543037415
1548;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.5038790106773376
1549;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.6818838119506836
1550;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.8010926246643066
1551;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.5552207827568054
1552;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.6596353054046631
1553;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.6184204816818237
1554;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.5641368627548218
1555;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9225919246673584
1556;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.6443023681640625
1557;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6248482465744019
1558;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6577503085136414
1559;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6690499782562256
1560;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7171785831451416
1561;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.8207917213439941
1562;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6353219747543335
1563;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;Contradicts;0.5063852667808533
1564;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;https://github.com/torvalds/linux/commit/1da4db0cd5c8a31d4468ec906b413e75e604b465;Contradicts;0.6537335515022278
1565;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7300602793693542
1566;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6569883227348328
1567;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.8207091689109802
1568;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.7761911749839783
1569;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5005303621292114
1570;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;improve that even further;there is a common pattern to do a range lookup first and then do something about that;https://github.com/torvalds/linux/commit/93065ac753e4443840a057bfef4be71ec766fde9;Contradicts;0.8378428220748901
1571;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.997624695301056
1572;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This way the memory is freed in a more controllable way with CPU affinity and priority of the caller;more controllable way with CPU affinity and priority of the caller;https://github.com/torvalds/linux/commit/884a7e5964e06ed93c7771c0d7cf19c09a8946f1;Contradicts;0.8377003073692322
1573;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7867385745048523
1574;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5435817837715149
1575;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6202412843704224
1576;Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5436100959777832
1577;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.7186251878738403
1578;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6452880501747131
1579;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6782446503639221
1580;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6439054012298584
1581;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.5535675287246704
1582;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.7507942318916321
1583;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.9701551795005798
1584;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.633957028388977
1585;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5248815417289734
1586;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9396225214004515
1587;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5525442957878113
1588;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5202882885932922
1589;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.804180920124054
1590;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.721733570098877
1591;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5273575782775879
1592;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.5527432560920715
1593;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7656394839286804
1594;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7415874600410461
1595;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5391031503677368
1596;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6340156197547913
1597;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6676836609840393
1598;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7182384729385376
1599;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6412515640258789
1600;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6111476421356201
1601;Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.638367235660553
1602;Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.5598862767219543
1603;Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;Contradicts;0.6372302174568176
1604;Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.6352502107620239
1605;Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7745832204818726
1606;Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6381479501724243
1607;Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6908008456230164
1608;Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.7320847511291504
1609;Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6821544766426086
1610;Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5206820368766785
1611;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.8617096543312073
1612;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Contradicts;0.515893280506134
1613;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6224324107170105
1614;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.7268694639205933
1615;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.645568311214447
1616;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.7493917346000671
1617;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.5486062169075012
1618;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.75078946352005
1619;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.6832689046859741
1620;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6023285388946533
1621;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6364065408706665
1622;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8676230907440186
1623;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;Contradicts;0.812720775604248
1624;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.77944016456604
1625;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6614636182785034
1626;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6556022763252258
1627;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7389068007469177
1628;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.73048996925354
1629;Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.540492594242096
1630;Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6247155070304871
1631;Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6961789131164551
1632;Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.560949981212616
1633;Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8410873413085938
1634;Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5910384654998779
1635;Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6861736178398132
1636;Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5093637108802795
1637;Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5367884039878845
1638;Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5387299060821533
1639;Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.6353201866149902
1640;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.5329091548919678
1641;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Contradicts;0.512689471244812
1642;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.6260184049606323
1643;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5084633231163025
1644;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.5342743396759033
1645;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5854120254516602
1646;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.8024380803108215
1647;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5978785157203674
1648;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7516130805015564
1649;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7246488332748413
1650;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.891836404800415
1651;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7921693325042725
1652;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.590833842754364
1653;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This is done as 2 patches;so that no call site is forgotten especialy as it uses this following coccinelle patch;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5737640261650085
1654;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6960235238075256
1655;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7445522546768188
1656;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6167377233505249
1657;Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.6918438076972961
1658;Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6014757752418518
1659;Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6672952771186829
1660;Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7494274973869324
1661;Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5202298164367676
1662;Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6907097697257996
1663;Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5660898685455322
1664;Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5534196496009827
1665;Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;delete the corresponding comment;it will be checked in oom_unkillable_task();https://github.com/torvalds/linux/commit/f8159c13905bba26f3e1782a521dacf7a66fc1ce;Contradicts;0.5193522572517395
1666;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.9171719551086426
1667;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Contradicts;0.6477149724960327
1668;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Contradicts;0.6048332452774048
1669;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Contradicts;0.63344806432724
1670;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.5118204355239868
1671;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5551031827926636
1672;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Contradicts;0.6976865530014038
1673;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Contradicts;0.7109358906745911
1674;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.7345564961433411
1675;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.6642050743103027
1676;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.9478389620780944
1677;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.6374332308769226
1678;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Contradicts;0.5090306401252747
1679;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.6326460242271423
1680;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.5670166611671448
1681;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;fix constraint deadlock;constraint deadlock;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5425630211830139
1682;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.5605344176292419
1683;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5832736492156982
1684;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.5555012822151184
1685;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Contradicts;0.7495309710502625
1686;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5633593201637268
1687;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.8080927729606628
1688;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6687723994255066
1689;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5077559351921082
1690;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9971392154693604
1691;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5994346737861633
1692;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.552270233631134
1693;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.7103206515312195
1694;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.7163117527961731
1695;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7420071959495544
1696;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8380426168441772
1697;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5360171794891357
1698;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.8497006893157959
1699;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8896900415420532
1700;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.8022302389144897
1701;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5066642165184021
1702;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6265853643417358
1703;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6314395666122437
1704;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7094950675964355
1705;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6700220704078674
1706;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6526027321815491
1707;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.549422025680542
1708;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6311756372451782
1709;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;delete the corresponding comment;it will be checked in oom_unkillable_task();https://github.com/torvalds/linux/commit/f8159c13905bba26f3e1782a521dacf7a66fc1ce;Contradicts;0.8850640654563904
1710;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5167738795280457
1711;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.7701413035392761
1712;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5212292671203613
1713;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.7060713768005371
1714;applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7186104655265808
1715;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Contradicts;0.7857457399368286
1716;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Contradicts;0.6914198398590088
1717;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6880045533180237
1718;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.6232977509498596
1719;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.6566998958587646
1720;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5134674310684204
1721;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.5185293555259705
1722;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Contradicts;0.5106028914451599
1723;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8766393065452576
1724;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.8396530151367188
1725;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7810201048851013
1726;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5594018697738647
1727;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5016074776649475
1728;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5434077978134155
1729;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6112967133522034
1730;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5712825059890747
1731;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.8548235297203064
1732;The comment changed in oom_kill.c was seriously misleading;seriously misleading;https://github.com/torvalds/linux/commit/a49335cceab8afb6603152fcc3f7d3b6677366ca;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.514496386051178
1733;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;Contradicts;0.5166600942611694
1734;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Contradicts;0.520993173122406
1735;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5298246145248413
1736;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.9149708151817322
1737;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9071820378303528
1738;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.9045703411102296
1739;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.7031263709068298
1740;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.543936014175415
1741;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5537917017936707
1742;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.8871060609817505
1743;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5353772640228271
1744;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5771154761314392
1745;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.711043119430542
1746;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.8606225252151489
1747;Use printk_ratelimit();to quieten it;https://github.com/torvalds/linux/commit/42639269f9ce4aac2e6c20bcbca30b5da8b9a899;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5381954908370972
1748;Provides more debug info when the system is OOM;More debug info, system is OOM;https://github.com/torvalds/linux/commit/578c2fd6a7f378434655e5c480e23152a3994404;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.7998629808425903
1749;Provides more debug info when the system is OOM;More debug info, system is OOM;https://github.com/torvalds/linux/commit/578c2fd6a7f378434655e5c480e23152a3994404;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.6442437767982483
1750;Provides more debug info when the system is OOM;More debug info, system is OOM;https://github.com/torvalds/linux/commit/578c2fd6a7f378434655e5c480e23152a3994404;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6010898351669312
1751;Provides more debug info when the system is OOM;More debug info, system is OOM;https://github.com/torvalds/linux/commit/578c2fd6a7f378434655e5c480e23152a3994404;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8926007151603699
1752;Provides more debug info when the system is OOM;More debug info, system is OOM;https://github.com/torvalds/linux/commit/578c2fd6a7f378434655e5c480e23152a3994404;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.609906017780304
1753;Provides more debug info when the system is OOM;More debug info, system is OOM;https://github.com/torvalds/linux/commit/578c2fd6a7f378434655e5c480e23152a3994404;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5750814080238342
1754;Provides more debug info when the system is OOM;More debug info, system is OOM;https://github.com/torvalds/linux/commit/578c2fd6a7f378434655e5c480e23152a3994404;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5460839867591858
1755;Provides more debug info when the system is OOM;More debug info, system is OOM;https://github.com/torvalds/linux/commit/578c2fd6a7f378434655e5c480e23152a3994404;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9212200045585632
1756;Provides more debug info when the system is OOM;More debug info, system is OOM;https://github.com/torvalds/linux/commit/578c2fd6a7f378434655e5c480e23152a3994404;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6193762421607971
1757;Provides more debug info when the system is OOM;More debug info, system is OOM;https://github.com/torvalds/linux/commit/578c2fd6a7f378434655e5c480e23152a3994404;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.580325722694397
1758;Provides more debug info when the system is OOM;More debug info, system is OOM;https://github.com/torvalds/linux/commit/578c2fd6a7f378434655e5c480e23152a3994404;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6543401479721069
1759;Provides more debug info when the system is OOM;More debug info, system is OOM;https://github.com/torvalds/linux/commit/578c2fd6a7f378434655e5c480e23152a3994404;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5806273818016052
1760;Provides more debug info when the system is OOM;More debug info, system is OOM;https://github.com/torvalds/linux/commit/578c2fd6a7f378434655e5c480e23152a3994404;This patch causes only memory information to be displayed for nodes that are allowed by currents cpuset when dumping the VM state;to prevent verbosity that can be harmful and cause other important messages to be scrolled from the kernel log and incur a significant time delay;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.8007947206497192
1761;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Contradicts;0.514635443687439
1762;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Contradicts;0.5859793424606323
1763;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.655624270439148
1764;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.9225598573684692
1765;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Preventing the livelock;caring more about preventing the livelock;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.5134401917457581
1766;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Contradicts;0.606108546257019
1767;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;Contradicts;0.6475167870521545
1768;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.8271818161010742
1769;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.926486313343048
1770;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.5673384070396423
1771;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.8488796949386597
1772;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Contradicts;0.8987082242965698
1773;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.968532383441925
1774;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.9838082194328308
1775;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.6230158805847168
1776;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;Contradicts;0.6087995767593384
1777;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7511710524559021
1778;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5449900031089783
1779;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.9075447916984558
1780;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;remove deprecated oom_adj;deprecated;https://github.com/torvalds/linux/commit/01dc52ebdf472f77cca623ca693ca24cfc0f1bbe;Contradicts;0.5943536758422852
1781;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.7863723635673523
1782;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.5305875539779663
1783;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.5189833045005798
1784;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.6152323484420776
1785;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.6580360531806946
1786;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5291327834129333
1787;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.513511598110199
1788;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.5055822730064392
1789;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Contradicts;0.9211438894271852
1790;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.6444045305252075
1791;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5995673537254333
1792;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.5201002955436707
1793;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.6129381060600281
1794;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7736890316009521
1795;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;Contradicts;0.5589573979377747
1796;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.5344921350479126
1797;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.7696573138237
1798;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8052539229393005
1799;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.6528230905532837
1800;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.7904558777809143
1801;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5499014258384705
1802;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.8247938752174377
1803;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;Contradicts;0.5449724197387695
1804;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;Contradicts;0.808784544467926
1805;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9285837411880492
1806;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5866101384162903
1807;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7454941868782043
1808;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.8093970417976379
1809;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6566586494445801
1810;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;https://github.com/torvalds/linux/commit/1b578df02207a67a29e8ced4db3b36d89df52fef;Contradicts;0.585603654384613
1811;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Update the comments for __oom_kill_task();to reflect the code changes;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;Contradicts;0.6454925537109375
1812;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;Contradicts;0.6359824538230896
1813;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.5601221919059753
1814;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7812015414237976
1815;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8246960043907166
1816;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5750634074211121
1817;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.7454754114151001
1818;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.6542158722877502
1819;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Contradicts;0.9179094433784484
1820;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;Contradicts;0.871688961982727
1821;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Change oom_kill.c to use for_each_thread();rather than the racy while_each_thread() which can loop forever if we race with exit;https://github.com/torvalds/linux/commit/1da4db0cd5c8a31d4468ec906b413e75e604b465;Contradicts;0.5785303115844727
1822;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.6125702857971191
1823;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.6529377102851868
1824;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8130355477333069
1825;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7358505725860596
1826;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5792376399040222
1827;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6263412237167358
1828;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5679842233657837
1829;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5985956192016602
1830;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.9664448499679564
1831;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Contradicts;0.6109522581100464
1832;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.6020671725273132
1833;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.6313337683677673
1834;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.600857675075531
1835;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5383484959602356
1836;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6462618708610535
1837;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5720433592796326
1838;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8241645693778992
1839;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.5164274573326111
1840;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5757974982261658
1841;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;https://github.com/torvalds/linux/commit/79befd0c08c4766f8fa27e37ac2a70e40840a56a;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5501962304115295
1842;"create a separate ""historical"" git archive of that later";if we want to, and in the meantime its about 3.2GB when imported into git - space that would just make the early git days unnecessarily complicated, when we dont have a lot of good infrastructure for it;https://github.com/torvalds/linux/commit/1da177e4c3f41524e886b7f1b8a0c1fc7321cac2;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5667603611946106
1843;"create a separate ""historical"" git archive of that later";if we want to, and in the meantime its about 3.2GB when imported into git - space that would just make the early git days unnecessarily complicated, when we dont have a lot of good infrastructure for it;https://github.com/torvalds/linux/commit/1da177e4c3f41524e886b7f1b8a0c1fc7321cac2;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6370440125465393
1844;"create a separate ""historical"" git archive of that later";if we want to, and in the meantime its about 3.2GB when imported into git - space that would just make the early git days unnecessarily complicated, when we dont have a lot of good infrastructure for it;https://github.com/torvalds/linux/commit/1da177e4c3f41524e886b7f1b8a0c1fc7321cac2;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5450171232223511
1845;"create a separate ""historical"" git archive of that later";if we want to, and in the meantime its about 3.2GB when imported into git - space that would just make the early git days unnecessarily complicated, when we dont have a lot of good infrastructure for it;https://github.com/torvalds/linux/commit/1da177e4c3f41524e886b7f1b8a0c1fc7321cac2;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.778721809387207
1846;"create a separate ""historical"" git archive of that later";if we want to, and in the meantime its about 3.2GB when imported into git - space that would just make the early git days unnecessarily complicated, when we dont have a lot of good infrastructure for it;https://github.com/torvalds/linux/commit/1da177e4c3f41524e886b7f1b8a0c1fc7321cac2;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6450426578521729
1847;"create a separate ""historical"" git archive of that later";if we want to, and in the meantime its about 3.2GB when imported into git - space that would just make the early git days unnecessarily complicated, when we dont have a lot of good infrastructure for it;https://github.com/torvalds/linux/commit/1da177e4c3f41524e886b7f1b8a0c1fc7321cac2;cap_safe_nice() only ever saw current, so now uses capable();only ever saw current, capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5070188641548157
1848;"create a separate ""historical"" git archive of that later";if we want to, and in the meantime its about 3.2GB when imported into git - space that would just make the early git days unnecessarily complicated, when we dont have a lot of good infrastructure for it;https://github.com/torvalds/linux/commit/1da177e4c3f41524e886b7f1b8a0c1fc7321cac2;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5550128221511841
1849;consider vfork();we dont have any reason;https://github.com/torvalds/linux/commit/19b4586cd9c8ed642798902e55c6f61ed576ad93;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5316189527511597
1850;consider vfork();we dont have any reason;https://github.com/torvalds/linux/commit/19b4586cd9c8ed642798902e55c6f61ed576ad93;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5353671312332153
1851;consider vfork();we dont have any reason;https://github.com/torvalds/linux/commit/19b4586cd9c8ed642798902e55c6f61ed576ad93;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.9032042622566224
1852;consider vfork();we dont have any reason;https://github.com/torvalds/linux/commit/19b4586cd9c8ed642798902e55c6f61ed576ad93;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5359092950820923
1853;consider vfork();we dont have any reason;https://github.com/torvalds/linux/commit/19b4586cd9c8ed642798902e55c6f61ed576ad93;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6423966884613037
1854;consider vfork();we dont have any reason;https://github.com/torvalds/linux/commit/19b4586cd9c8ed642798902e55c6f61ed576ad93;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5684958696365356
1855;consider vfork();we dont have any reason;https://github.com/torvalds/linux/commit/19b4586cd9c8ed642798902e55c6f61ed576ad93;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.6569815278053284
1856;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Contradicts;0.5637617111206055
1857;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.591166615486145
1858;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7267941832542419
1859;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.7181939482688904
1860;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;Clean up the OOM killer messages;to be more consistent;https://github.com/torvalds/linux/commit/f3af38d30c18538d069a95e624a3db7c3d486a1e;Contradicts;0.5730238556861877
1861;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5292288661003113
1862;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6893300414085388
1863;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.543497622013092
1864;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.961542546749115
1865;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7753151059150696
1866;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5045265555381775
1867;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6982923746109009
1868;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5257710814476013
1869;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6397369503974915
1870;cleanup has_intersects_mems_allowed();oom;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5603480935096741
1871;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6676236391067505
1872;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6259259581565857
1873;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7296532988548279
1874;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.7141445875167847
1875;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5896537899971008
1876;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7373581528663635
1877;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7370173931121826
1878;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6569639444351196
1879;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8863935470581055
1880;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5469362139701843
1881;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.613554835319519
1882;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7983484268188477
1883;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5628893971443176
1884;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7660278677940369
1885;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.7064550518989563
1886;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5768914222717285
1887;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5365179181098938
1888;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;https://github.com/torvalds/linux/commit/df1090a8dda40b6e11d8cd09e8fc900cfe913b38;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5368172526359558
1889;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Contradicts;0.6042275428771973
1890;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;https://github.com/torvalds/linux/commit/ad915c432eccb482427c1bbd77c74e6f7bfe60b3;Contradicts;0.8262661695480347
1891;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.5026364922523499
1892;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.6182029843330383
1893;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.6818652153015137
1894;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.5734231472015381
1895;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.9616995453834534
1896;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.5968945622444153
1897;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.7323336005210876
1898;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5325137376785278
1899;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.5859073996543884
1900;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9295799732208252
1901;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5193379521369934
1902;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9455313682556152
1903;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.8894975781440735
1904;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Contradicts;0.8876124024391174
1905;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6916202306747437
1906;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6794182658195496
1907;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5466694831848145
1908;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.817082941532135
1909;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.8871037364006042
1910;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5224387645721436
1911;kill duplicate OOM_DISABLE check;duplicate;https://github.com/torvalds/linux/commit/113e27f36dff9895049df324f292474854750d21;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6010425090789795
1912;treat kernel thread honestly;/proc/<pid>/oom_score;https://github.com/torvalds/linux/commit/26ebc984913b6a8d86d724b3a79d2ed4ed574612;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Contradicts;0.5010112524032593
1913;treat kernel thread honestly;/proc/<pid>/oom_score;https://github.com/torvalds/linux/commit/26ebc984913b6a8d86d724b3a79d2ed4ed574612;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.7497883439064026
1914;treat kernel thread honestly;/proc/<pid>/oom_score;https://github.com/torvalds/linux/commit/26ebc984913b6a8d86d724b3a79d2ed4ed574612;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5764918327331543
1915;treat kernel thread honestly;/proc/<pid>/oom_score;https://github.com/torvalds/linux/commit/26ebc984913b6a8d86d724b3a79d2ed4ed574612;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7790055871009827
1916;treat kernel thread honestly;/proc/<pid>/oom_score;https://github.com/torvalds/linux/commit/26ebc984913b6a8d86d724b3a79d2ed4ed574612;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5887531042098999
1917;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.5662152767181396
1918;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;fix NULL pointer dereference;NULL pointer dereference;https://github.com/torvalds/linux/commit/be71cf2202971e50ce4953d473649c724799eb8a;Contradicts;0.5436108708381653
1919;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.6633346080780029
1920;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.6010112762451172
1921;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.6101137399673462
1922;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.5928919911384583
1923;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Contradicts;0.5779337286949158
1924;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;make sure that the mmput_async is only called;when we do not back off and reap some memory;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Contradicts;0.5588164925575256
1925;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.8837061524391174
1926;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.791588306427002
1927;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Contradicts;0.6208782196044922
1928;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.5009927749633789
1929;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.6656371355056763
1930;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Contradicts;0.6437197327613831
1931;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.752074122428894
1932;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;suppress extraneous stack and memory dump;oom;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.6643964052200317
1933;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.5704991817474365
1934;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.6916758418083191
1935;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5820232629776001
1936;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7370592355728149
1937;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;Contradicts;0.5601469874382019
1938;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5001721978187561
1939;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6865270137786865
1940;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Contradicts;0.5385349988937378
1941;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9552862048149108
1942;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.9206472039222716
1943;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;remove pointless kthread_run() error check;pointless;https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5211799144744873
1944;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7253899574279785
1945;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;hold tasklist_lock;tsk->sighand is not guarded by RCU, just as what out_of_memory() does.;https://github.com/torvalds/linux/commit/e115f2d89253490fb2dbf304b627f8d908df26f1;Contradicts;0.5127859711647034
1946;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.5232871174812317
1947;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6381018757820129
1948;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.6246262192726135
1949;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.768436849117279
1950;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;simplify the API back to the single check;to simplify the API back;https://github.com/torvalds/linux/commit/344736f29b359790facd0b7a521e367f1715c11c;Contradicts;0.5100694298744202
1951;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7238456010818481
1952;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.5362611413002014
1953;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.6835029721260071
1954;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5772714018821716
1955;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5087200999259949
1956;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.7176852226257324
1957;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8118224740028381
1958;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5566959381103516
1959;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Get/put across the for_each_thread() on the selected task;The easiest fix is;https://github.com/torvalds/linux/commit/cefc7ef3c87d02fc9307835868ff721ea12cc597;Contradicts;0.5583220720291138
1960;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;Contradicts;0.6459952592849731
1961;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5996972918510437
1962;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;Contradicts;0.5094380974769592
1963;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6453862190246582
1964;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.522612988948822
1965;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7040684819221497
1966;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;fix vm_oom_kill_table[];ifdeffery;https://github.com/torvalds/linux/commit/a19cad0691597eb79c123b8a19a9faba5ab7d90e;Contradicts;0.6370072364807129
1967;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5980634689331055
1968;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.6298096776008606
1969;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.7115071415901184
1970;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5006601214408875
1971;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.7380698919296265
1972;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.8255107998847961
1973;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5751166939735413
1974;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;https://github.com/torvalds/linux/commit/f88ccad5886d5a864b8b0d48c666ee9998dec53f;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.5976530909538269
1975;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;https://github.com/torvalds/linux/commit/ad915c432eccb482427c1bbd77c74e6f7bfe60b3;Contradicts;0.5907610058784485
1976;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6344743371009827
1977;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6087777018547058
1978;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5760268568992615
1979;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.9920228719711304
1980;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.703023374080658
1981;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.7676553130149841
1982;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5942331552505493
1983;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.7603309750556946
1984;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.9051265716552734
1985;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.6198853850364685
1986;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5263875722885132
1987;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5737565159797668
1988;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.725975751876831
1989;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5675369501113892
1990;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8371546864509583
1991;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5406417846679688
1992;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Contradicts;0.7956840991973877
1993;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7217867970466614
1994;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5570616126060486
1995;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5896924734115601
1996;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5153002142906189
1997;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5769443511962891
1998;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Contradicts;0.6739000082015991
1999;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.5937032103538513
2000;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5618839859962463
2001;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5321933627128601
2002;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7000663876533508
2003;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.738496720790863
2004;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.6399497985839844
2005;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9846404790878296
2006;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7225344777107239
2007;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7734497785568237
2008;dont try to kill oom_unkillable child;oom_unkillable;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;"Users of mmap_sem which need it for write should be carefully reviewed to use _killable waiting as much as possible and reduce allocations requests done with the lock held to absolute minimum
";to reduce the risk even further;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5912882089614868
2009;Fix it.;Fixes;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.587826669216156
2010;Fix it.;Fixes;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9506991505622864
2011;Fix it.;Fixes;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5445274710655212
2012;Fix it.;Fixes;https://github.com/torvalds/linux/commit/7c59aec830c7ed6c745bd513982cee3563ed20c1;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.6335687637329102
2013;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5028982162475586
2014;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.546666145324707
2015;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.7467431426048279
2016;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;Contradicts;0.8843815326690674
2017;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5623876452445984
2018;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.5240190625190735
2019;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Contradicts;0.5231443643569946
2020;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.7140244245529175
2021;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.5088474750518799
2022;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.8979879021644592
2023;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5381003022193909
2024;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.634476900100708
2025;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.6556447744369507
2026;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6045211553573608
2027;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6807932257652283
2028;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9529120922088624
2029;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5688023567199707
2030;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7577970027923584
2031;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.7042667269706726
2032;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5701755881309509
2033;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8696470260620117
2034;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.604295551776886
2035;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.6747715473175049
2036;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.746135950088501
2037;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.9072422981262208
2038;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5288489460945129
2039;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5724197626113892
2040;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.8003244400024414
2041;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.512657642364502
2042;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5836399793624878
2043;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.6178070902824402
2044;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.6389501094818115
2045;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.7426342368125916
2046;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;delete the corresponding comment;it will be checked in oom_unkillable_task();https://github.com/torvalds/linux/commit/f8159c13905bba26f3e1782a521dacf7a66fc1ce;Contradicts;0.9446593523025512
2047;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5404228568077087
2048;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6568658351898193
2049;Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;https://github.com/torvalds/linux/commit/0aad4b3124850e85fe54e610802f0917ce46a1ae;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6402615308761597
2050;remove unnecessary code and cleanup;unnecessary code and cleanup;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5399757027626038
2051;remove unnecessary code and cleanup;unnecessary code and cleanup;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8633631467819214
2052;remove unnecessary code and cleanup;unnecessary code and cleanup;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8764044046401978
2053;remove unnecessary code and cleanup;unnecessary code and cleanup;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6160554885864258
2054;Remove the redundancy in __oom_kill_task();redundancy;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6773592829704285
2055;Remove the redundancy in __oom_kill_task();redundancy;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;Share the same oom_score_adj;As a result;https://github.com/torvalds/linux/commit/44a70adec910d6929689e42b6e5cee5b7d202d20;Contradicts;0.5482438802719116
2056;Remove the redundancy in __oom_kill_task();redundancy;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.7363162636756897
2057;Remove the redundancy in __oom_kill_task();redundancy;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.604451596736908
2058;Remove the redundancy in __oom_kill_task();redundancy;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9072669148445128
2059;Remove the redundancy in __oom_kill_task();redundancy;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9576603770256042
2060;Remove the redundancy in __oom_kill_task();redundancy;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6769493818283081
2061;Remove the redundancy in __oom_kill_task();redundancy;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5835000872612
2062;Remove the redundancy in __oom_kill_task();redundancy;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7833809852600098
2063;moves the kernel log message to a higher level;verbosity is not always emitted here;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.5616891980171204
2064;moves the kernel log message to a higher level;verbosity is not always emitted here;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5401915907859802
2065;moves the kernel log message to a higher level;verbosity is not always emitted here;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6352958083152771
2066;moves the kernel log message to a higher level;verbosity is not always emitted here;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.5208273530006409
2067;moves the kernel log message to a higher level;verbosity is not always emitted here;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5663496255874634
2068;moves the kernel log message to a higher level;verbosity is not always emitted here;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7647050023078918
2069;moves the kernel log message to a higher level;verbosity is not always emitted here;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;Moving the test down;will give the desired behaviour;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;Contradicts;0.6846626400947571
2070;moves the kernel log message to a higher level;verbosity is not always emitted here;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6801976561546326
2071;moves the kernel log message to a higher level;verbosity is not always emitted here;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.640008807182312
2072;moves the kernel log message to a higher level;verbosity is not always emitted here;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5284857153892517
2073;it can be merged into that function at the same time;__oom_kill_task() only has a single caller;https://github.com/torvalds/linux/commit/b940fd703572f7f9e5f894c682c91c3cbd84c11e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5262826681137085
2074;Extract this to a helper function;to remove all the confusion as to its semantics;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.5499686598777771
2075;Extract this to a helper function;to remove all the confusion as to its semantics;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5474324226379395
2076;Extract this to a helper function;to remove all the confusion as to its semantics;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5945866703987122
2077;Extract this to a helper function;to remove all the confusion as to its semantics;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5250546932220459
2078;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Contradicts;0.6279808878898621
2079;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.6910078525543213
2080;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5099945664405823
2081;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6365121006965637
2082;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.8872670531272888
2083;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9155205488204956
2084;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5341222882270813
2085;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6980997920036316
2086;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5236085057258606
2087;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;Contradicts;0.5357775092124939
2088;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6256357431411743
2089;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7697205543518066
2090;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5821285843849182
2091;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6858149766921997
2092;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5360453128814697
2093;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5168262124061584
2094;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5559353232383728
2095;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.7545420527458191
2096;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5555004477500916
2097;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6355857849121094
2098;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.855398416519165
2099;fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;https://github.com/torvalds/linux/commit/309ed882508cc471320ff79265e7340774d6746c;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6882286667823792
2100;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;https://github.com/torvalds/linux/commit/ad915c432eccb482427c1bbd77c74e6f7bfe60b3;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.8862695097923279
2101;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;https://github.com/torvalds/linux/commit/ad915c432eccb482427c1bbd77c74e6f7bfe60b3;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7160392999649048
2102;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;https://github.com/torvalds/linux/commit/ad915c432eccb482427c1bbd77c74e6f7bfe60b3;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6538498401641846
2103;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;https://github.com/torvalds/linux/commit/ad915c432eccb482427c1bbd77c74e6f7bfe60b3;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6137361526489258
2104;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;https://github.com/torvalds/linux/commit/ad915c432eccb482427c1bbd77c74e6f7bfe60b3;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.5524981021881104
2105;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;avoid unnecessary scanning;help to avoid unnecessary scanning if system doesnt have a swap device;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Contradicts;0.7475749850273132
2106;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;save roots task;better to save;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.9393123388290404
2107;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.8456115126609802
2108;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.7529404163360596
2109;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.7305341958999634
2110;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.5164853930473328
2111;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.6064465641975403
2112;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.6526762843132019
2113;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.8565876483917236
2114;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6354929208755493
2115;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.7953009605407715
2116;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.7356045842170715
2117;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.6557233929634094
2118;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.7018894553184509
2119;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;Contradicts;0.5044001340866089
2120;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.7458204627037048
2121;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.6773701310157776
2122;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.5084564685821533
2123;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6648313403129578
2124;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.5768272876739502
2125;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Contradicts;0.652754008769989
2126;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8683618307113647
2127;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.6785909533500671
2128;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.9010602831840516
2129;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.8858079314231873
2130;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.9363425970077516
2131;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;https://github.com/torvalds/linux/commit/5a2d41961dd6815b874b5c0afec0ac96cd90eea4;Contradicts;0.5786346197128296
2132;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9369191527366638
2133;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.8111814260482788
2134;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6830415725708008
2135;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.6258258819580078
2136;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7882480025291443
2137;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.502434253692627
2138;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;hide it behind the helpers;With pid namespaces this field is now dangerous to use explicitly;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;Contradicts;0.5035997033119202
2139;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;https://github.com/torvalds/linux/commit/b460cbc581a53cc088ceba80608021dd49c63c43;Contradicts;0.809348464012146
2140;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.8339319229125977
2141;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.5900288820266724
2142;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.7542906403541565
2143;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.7903969883918762
2144;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.9496417045593262
2145;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.8015169501304626
2146;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7609813809394836
2147;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5501702427864075
2148;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Convert oom_zonelist_trylock() to return bool instead of int;Only success and failure are tested;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.6054420471191406
2149;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5016628503799438
2150;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.7765110731124878
2151;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;move the cpuset semaphore region outside the tasklist_lock region;The fix seems easy enough;https://github.com/torvalds/linux/commit/505970b96e3b7d22177c38e03435a68376628e7a;Contradicts;0.5066699385643005
2152;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.8701791763305664
2153;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.5076128244400024
2154;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.8589997291564941
2155;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8767879009246826
2156;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.7175946831703186
2157;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.6797260046005249
2158;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.8053207397460938
2159;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.7334361672401428
2160;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7617915868759155
2161;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6345896124839783
2162;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.6483921408653259
2163;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.9438066482543944
2164;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7047178149223328
2165;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.5810768008232117
2166;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.8000701069831848
2167;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.7790692448616028
2168;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;cap_safe_nice() only ever saw current, so now uses capable();only ever saw current, capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5381624698638916
2169;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.7381142973899841
2170;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.8874881267547607
2171;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.7216882109642029
2172;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Fix typo in comment: kthead -> kthread;typo;https://github.com/torvalds/linux/commit/4c9c3809ae2ecfcece9acb3f51427e617d21fafb;Contradicts;0.5749830603599548
2173;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.5112116932868958
2174;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8010659217834473
2175;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.9410224556922911
2176;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;This patch causes only memory information to be displayed for nodes that are allowed by currents cpuset when dumping the VM state;to prevent verbosity that can be harmful and cause other important messages to be scrolled from the kernel log and incur a significant time delay;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.6962451934814453
2177;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.784594714641571
2178;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.6835501194000244
2179;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8840374946594238
2180;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7102621793746948
2181;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Contradicts;0.581775426864624
2182;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.5448748469352722
2183;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;Contradicts;0.5596222877502441
2184;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;make it as simple and predictable as possible;so the results are better understood and we end up killing the task which will lead to the most memory freeing while still respecting the fine-tuning from userspace;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5743143558502197
2185;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.8593352437019348
2186;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Contradicts;0.5288594961166382
2187;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.5699251294136047
2188;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.5111040472984314
2189;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5147891640663147
2190;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7025583982467651
2191;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;significantly reduces the amount of time that it is held;isnt a complete solution to tasklist_lock starvation;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;Contradicts;0.6476542353630066
2192;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.8886104822158813
2193;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.5077875852584839
2194;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5333357453346252
2195;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.6437335014343262
2196;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5221990942955017
2197;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Contradicts;0.7174854278564453
2198;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7322325706481934
2199;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5003128051757812
2200;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.6213875412940979
2201;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6746490597724915
2202;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7047106027603149
2203;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7591428756713867
2204;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.7724538445472717
2205;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.822819709777832
2206;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;https://github.com/torvalds/linux/commit/b460cbc581a53cc088ceba80608021dd49c63c43;Contradicts;0.6070678234100342
2207;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.5618546009063721
2208;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6778132319450378
2209;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5528773069381714
2210;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6076220273971558
2211;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.6861355304718018
2212;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.956520676612854
2213;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5873585939407349
2214;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.8042759895324707
2215;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;By giving root tasks a bonus that is proportional to their actual size;they remain comparable even when relatively small;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;Contradicts;0.6960355043411255
2216;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.894173264503479
2217;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.8645028471946716
2218;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5383307337760925
2219;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6823432445526123
2220;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7617741227149963
2221;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.6401737332344055
2222;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5147212147712708
2223;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.7057244181632996
2224;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6686098575592041
2225;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7228156328201294
2226;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;https://github.com/torvalds/linux/commit/6f48d0ebd907ae419387f27b602ee98870cfa7bb;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5041097402572632
2227;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5679627060890198
2228;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Contradicts;0.7201040983200073
2229;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6245083808898926
2230;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.7513622045516968
2231;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5677894949913025
2232;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.784682035446167
2233;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.5151311755180359
2234;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Contradicts;0.5846343040466309
2235;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.566943347454071
2236;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.8074762225151062
2237;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7764927744865417
2238;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.611735463142395
2239;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.6701722145080566
2240;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6798047423362732
2241;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.8266969323158264
2242;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9141089916229248
2243;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5216653347015381
2244;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6744412779808044
2245;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.8732881546020508
2246;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8159564137458801
2247;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6977152824401855
2248;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.7176660299301147
2249;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8013997673988342
2250;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.5605957508087158
2251;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6088926196098328
2252;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.8211697936058044
2253;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.507630467414856
2254;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.560391902923584
2255;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9057732820510864
2256;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5398673415184021
2257;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5627967119216919
2258;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;https://github.com/torvalds/linux/commit/6cf86ac6f36b638459a9a6c2576d5e655d41d451;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8338590860366821
2259;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.5214861631393433
2260;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6197891235351562
2261;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.8386327028274536
2262;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Contradicts;0.5080763101577759
2263;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.6242026686668396
2264;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.5095052123069763
2265;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.7057449817657471
2266;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5648607611656189
2267;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;https://github.com/torvalds/linux/commit/3d124cbba316737af8f3a6959edb95bbd130a4d8;Contradicts;0.5385413765907288
2268;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;Contradicts;0.6818455457687378
2269;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.5496729612350464
2270;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5155619978904724
2271;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7936748266220093
2272;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7358764410018921
2273;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9931730628013612
2274;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6986743211746216
2275;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.6924217343330383
2276;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5994928479194641
2277;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.732465922832489
2278;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8773203492164612
2279;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.5399370193481445
2280;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5825916528701782
2281;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5957756042480469
2282;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.814817488193512
2283;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;"
MADV_PAGEOUT is similar to MADV_DONTNEED 
MADV_COLD is similar to MADV_FREE 
";"
it hints the kernel that memory region is not currently needed and should be reclaimed immediately 
it hints the kernel that memory region is not currently needed and should be reclaimed when memory pressure rises";https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Contradicts;0.7537063360214233
2284;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6369198560714722
2285;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5661783814430237
2286;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.569928765296936
2287;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6590859889984131
2288;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7337732315063477
2289;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.5612374544143677
2290;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.8020579814910889
2291;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5505979657173157
2292;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.8537766337394714
2293;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.6079590916633606
2294;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7624637484550476
2295;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.629371166229248
2296;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.6259344816207886
2297;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6097223162651062
2298;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6042980551719666
2299;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.637947678565979
2300;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.79544597864151
2301;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9116172194480896
2302;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5027762651443481
2303;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5029054284095764
2304;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Contradicts;0.577064573764801
2305;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.5715449452400208
2306;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7485718727111816
2307;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7238051891326904
2308;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6243976950645447
2309;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.7801923751831055
2310;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6103705763816833
2311;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.5052322149276733
2312;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7370384931564331
2313;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5769009590148926
2314;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6148610711097717
2315;deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6482117176055908
2316;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.6855449080467224
2317;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6811206936836243
2318;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5385584235191345
2319;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5376499891281128
2320;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.7825790643692017
2321;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;Contradicts;0.6546444296836853
2322;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5160319209098816
2323;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5744806528091431
2324;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.5554296970367432
2325;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.9136754870414734
2326;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.938182294368744
2327;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5526226758956909
2328;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6255315542221069
2329;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5086284875869751
2330;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;https://github.com/torvalds/linux/commit/b460cbc581a53cc088ceba80608021dd49c63c43;Contradicts;0.5262073278427124
2331;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8522588014602661
2332;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5243092179298401
2333;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.8751764893531799
2334;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5290343165397644
2335;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.5184355974197388
2336;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.5419965386390686
2337;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6079195737838745
2338;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5174575448036194
2339;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.5472519397735596
2340;It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7421438097953796
2341;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.5345544815063477
2342;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5131479501724243
2343;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.8006394505500793
2344;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.6261221766471863
2345;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;Contradicts;0.9034539461135864
2346;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.510397732257843
2347;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.6273647546768188
2348;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.7504866719245911
2349;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.6796871423721313
2350;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.729616105556488
2351;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;https://github.com/torvalds/linux/commit/3d124cbba316737af8f3a6959edb95bbd130a4d8;Contradicts;0.6604231595993042
2352;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.5267333388328552
2353;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.6270724534988403
2354;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5879664421081543
2355;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7116631865501404
2356;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5206242799758911
2357;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.6281635761260986
2358;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7479337453842163
2359;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5938259959220886
2360;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9950359463691713
2361;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.6135632395744324
2362;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;remove pointless kthread_run() error check;pointless;https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6038109660148621
2363;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6436013579368591
2364;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.6174658536911011
2365;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7721555233001709
2366;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.5652014017105103
2367;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.8500027060508728
2368;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;give the functions a kthread_ prefix;to better document the use case;https://github.com/torvalds/linux/commit/f5678e7f2ac31c270334b936352f0ef2fe7dd2b3;Contradicts;0.520205557346344
2369;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8326421976089478
2370;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7801389098167419
2371;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5471593141555786
2372;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5667470693588257
2373;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Add comments describing oom_locks scope;describing oom_locks scope;https://github.com/torvalds/linux/commit/a195d3f5b74f3f45a6742f9063b5e95a2522b46d;Contradicts;0.6128591299057007
2374;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.807041585445404
2375;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5745781660079956
2376;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5936284065246582
2377;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.5899875164031982
2378;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6252188086509705
2379;MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8324776291847229
2380;put those freeable pages in inactive file LRU;it would make sense to;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6741809844970703
2381;put those freeable pages in inactive file LRU;it would make sense to;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6546435356140137
2382;put those freeable pages in inactive file LRU;it would make sense to;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5201935172080994
2383;put those freeable pages in inactive file LRU;it would make sense to;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5178775787353516
2384;put those freeable pages in inactive file LRU;it would make sense to;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5748768448829651
2385;put those freeable pages in inactive file LRU;it would make sense to;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6709400415420532
2386;give a bonus to make them be reclaimed on swapless system;could;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.546107828617096
2387;give a bonus to make them be reclaimed on swapless system;could;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5726428627967834
2388;give a bonus to make them be reclaimed on swapless system;could;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7085015177726746
2389;give a bonus to make them be reclaimed on swapless system;could;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.6999876499176025
2390;give a bonus to make them be reclaimed on swapless system;could;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.7086105942726135
2391;give a bonus to make them be reclaimed on swapless system;could;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5269631743431091
2392;give a bonus to make them be reclaimed on swapless system;could;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6060467958450317
2393;give a bonus to make them be reclaimed on swapless system;could;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8966146111488342
2394;give a bonus to make them be reclaimed on swapless system;could;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7897549271583557
2395;give a bonus to make them be reclaimed on swapless system;could;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6245090365409851
2396;give a bonus to make them be reclaimed on swapless system;could;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5330978035926819
2397;give a bonus to make them be reclaimed on swapless system;could;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5711052417755127
2398;give a bonus to make them be reclaimed on swapless system;could;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7208751440048218
2399;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.637672483921051
2400;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.5235809087753296
2401;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6043625473976135
2402;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6953834295272827
2403;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.7952807545661926
2404;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6924245953559875
2405;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7051859498023987
2406;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6462896466255188
2407;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9097198843955994
2408;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5692569017410278
2409;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5895387530326843
2410;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7581396102905273
2411;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7191610336303711
2412;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.523135781288147
2413;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.6498319506645203
2414;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.8886087536811829
2415;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.8411583304405212
2416;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7670902013778687
2417;reclaiming them requires swap-out/in in the end;its bigger cost;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5889552235603333
2418;better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6093338131904602
2419;better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6862001419067383
2420;better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5511587262153625
2421;better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7652425765991211
2422;better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7885334491729736
2423;better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5095542669296265
2424;better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5684519410133362
2425;better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5357774496078491
2426;better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5672950744628906
2427;avoid unnecessary scanning;help to avoid unnecessary scanning if system doesnt have a swap device;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.5926389098167419
2428;avoid unnecessary scanning;help to avoid unnecessary scanning if system doesnt have a swap device;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.506005585193634
2429;avoid unnecessary scanning;help to avoid unnecessary scanning if system doesnt have a swap device;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5208944082260132
2430;avoid unnecessary scanning;help to avoid unnecessary scanning if system doesnt have a swap device;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5433588027954102
2431;Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6049508452415466
2432;Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.6954459547996521
2433;Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6342683434486389
2434;Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5661078095436096
2435;Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6389695405960083
2436;Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.506020724773407
2437;Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5493158102035522
2438;Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7976027131080627
2439;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.5426421761512756
2440;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.554764449596405
2441;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Contradicts;0.6620185375213623
2442;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Contradicts;0.6785935163497925
2443;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.7366551160812378
2444;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.6585107445716858
2445;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5975889563560486
2446;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.6381943821907043
2447;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;Contradicts;0.7393409013748169
2448;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.8391100764274597
2449;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.897721529006958
2450;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.5459535717964172
2451;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Contradicts;0.5242154598236084
2452;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.5539500117301941
2453;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Contradicts;0.5287202000617981
2454;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5242123603820801
2455;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.6861394047737122
2456;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;suppress extraneous stack and memory dump;oom;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.5436068177223206
2457;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.9895562529563904
2458;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.82679283618927
2459;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.5994618535041809
2460;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.8014637231826782
2461;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5722951292991638
2462;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.7151268720626831
2463;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;Contradicts;0.7152809500694275
2464;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.6876044869422913
2465;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.576439619064331
2466;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6460649967193604
2467;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9322550296783448
2468;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5251218676567078
2469;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6282200813293457
2470;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6906530857086182
2471;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.5872323513031006
2472;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6277382969856262
2473;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.6539458632469177
2474;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6989926695823669
2475;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6470690965652466
2476;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5877497792243958
2477;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.6105243563652039
2478;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.9425869584083556
2479;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5808019042015076
2480;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.8170644044876099
2481;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9942891597747804
2482;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.6384442448616028
2483;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;Contradicts;0.7315382361412048
2484;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.8758665323257446
2485;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;Contradicts;0.7584342956542969
2486;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7378038167953491
2487;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7281768918037415
2488;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5134555697441101
2489;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;delete unlock_range();exit_mmap() does not need locked_vm updates;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5821447372436523
2490;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5171553492546082
2491;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.7351802587509155
2492;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5343296527862549
2493;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;delete the corresponding comment;it will be checked in oom_unkillable_task();https://github.com/torvalds/linux/commit/f8159c13905bba26f3e1782a521dacf7a66fc1ce;Contradicts;0.5075864195823669
2494;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.6253663301467896
2495;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8950793743133545
2496;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;This patch causes only memory information to be displayed for nodes that are allowed by currents cpuset when dumping the VM state;to prevent verbosity that can be harmful and cause other important messages to be scrolled from the kernel log and incur a significant time delay;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.7929521203041077
2497;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7261003851890564
2498;Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;avoid attempting to kill init sharing same memory;avoid attempting to kill init;https://github.com/torvalds/linux/commit/a2b829d95958da2025ef844c0f53ac15ad720fac;Contradicts;0.6316684484481812
2499;printing this value;the only documentation of the value for the process being killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6370232701301575
2500;printing this value;the only documentation of the value for the process being killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.8631051778793335
2501;printing this value;the only documentation of the value for the process being killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.8255112767219543
2502;printing this value;the only documentation of the value for the process being killed;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6150311827659607
2503;The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.8688395023345947
2504;The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.5805392265319824
2505;The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.7088372111320496
2506;The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.512163519859314
2507;The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6581377983093262
2508;The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6497637629508972
2509;The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6666882038116455
2510;The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;https://github.com/torvalds/linux/commit/70cb6d2677905121bfc7fdf5babfd8444218edd9;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6489112973213196
2511;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6076394319534302
2512;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.58430016040802
2513;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7344196438789368
2514;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5371319651603699
2515;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;hide it behind the helpers;With pid namespaces this field is now dangerous to use explicitly;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;Contradicts;0.5420650839805603
2516;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5608734488487244
2517;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6699012517929077
2518;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.7168787717819214
2519;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.8687375783920288
2520;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.933809220790863
2521;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7246102690696716
2522;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6644209623336792
2523;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5750755667686462
2524;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;This patch causes only memory information to be displayed for nodes that are allowed by currents cpuset when dumping the VM state;to prevent verbosity that can be harmful and cause other important messages to be scrolled from the kernel log and incur a significant time delay;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5837782621383667
2525;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.6566523313522339
2526;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5003238916397095
2527;Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;https://github.com/torvalds/linux/commit/8ac3f8fe91a2119522a73fbc41d354057054e6ed;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.8577791452407837
2528;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Contradicts;0.7581280469894409
2529;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;Contradicts;0.5242729783058167
2530;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;https://github.com/torvalds/linux/commit/7c5f64f84483bd13886348edda8b3e7b799a7fdb;Contradicts;0.7137004137039185
2531;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5131527781486511
2532;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.7756727337837219
2533;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5778037905693054
2534;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.8037271499633789
2535;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8743599653244019
2536;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6165202856063843
2537;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;Contradicts;0.5232309699058533
2538;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9601075053215028
2539;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6284148693084717
2540;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.6605222225189209
2541;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5890116691589355
2542;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.580737829208374
2543;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5526084303855896
2544;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.8499101996421814
2545;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6079687476158142
2546;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5643856525421143
2547;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.9162005186080932
2548;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7751275897026062
2549;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.595763087272644
2550;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.9159671664237976
2551;remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;https://github.com/torvalds/linux/commit/2c207985f354dfb549e5a543102a3e084eea81f6;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5189561247825623
2552;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.5627996325492859
2553;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6502745747566223
2554;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.5404998064041138
2555;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7202571630477905
2556;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7239086031913757
2557;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8369929790496826
2558;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5039272308349609
2559;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7264675498008728
2560;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6404399275779724
2561;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.7457298636436462
2562;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.8448880910873413
2563;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.5102699995040894
2564;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.5964359641075134
2565;remove redundant task_in_mem_cgroup() check;redundant;https://github.com/torvalds/linux/commit/6ba749ee78ef42ffdf4b95c042fc574a37d229d9;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.589853048324585
2566;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5441202521324158
2567;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.5197265148162842
2568;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.5032070279121399
2569;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;Contradicts;0.5905930995941162
2570;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;Contradicts;0.6478842496871948
2571;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.9248720407485962
2572;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.5966827273368835
2573;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5850902199745178
2574;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.6832260489463806
2575;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;suppress extraneous stack and memory dump;oom;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.5193301439285278
2576;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Contradicts;0.5709612369537354
2577;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;fix constraint deadlock;constraint deadlock;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5253522396087646
2578;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.664734423160553
2579;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;Contradicts;0.503890335559845
2580;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.613445520401001
2581;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;Contradicts;0.5376274585723877
2582;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;Contradicts;0.5453978180885315
2583;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.6088578701019287
2584;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7287979125976562
2585;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7348110675811768
2586;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;select_bad_process();it makes consistency more and makes speed up;https://github.com/torvalds/linux/commit/495789a51a91cb8c015d8d77fecbac1caf20b186;Contradicts;0.5976929664611816
2587;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9189197421073914
2588;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.6188374757766724
2589;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7294099926948547
2590;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.5610027313232422
2591;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;Contradicts;0.721372127532959
2592;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Update the comments for __oom_kill_task();to reflect the code changes;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;Contradicts;0.5592302680015564
2593;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5385482311248779
2594;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5069791078567505
2595;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;https://github.com/torvalds/linux/commit/2314b42db67be30b747122d65c6cd2c85da34538;Contradicts;0.5178093910217285
2596;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.9063016176223756
2597;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.6423608660697937
2598;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.8770576119422913
2599;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.626974880695343
2600;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.6491830945014954
2601;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;https://github.com/torvalds/linux/commit/4d4048be8a93769350efa31d2482a038b7de73d0;Contradicts;0.6625116467475891
2602;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5371596813201904
2603;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Change oom_kill.c to use for_each_thread();rather than the racy while_each_thread() which can loop forever if we race with exit;https://github.com/torvalds/linux/commit/1da4db0cd5c8a31d4468ec906b413e75e604b465;Contradicts;0.5834729671478271
2604;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.737195611000061
2605;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.6369101405143738
2606;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.9021994471549988
2607;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.800979495048523
2608;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.505619466304779
2609;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.521877110004425
2610;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;Contradicts;0.6672977209091187
2611;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.807981550693512
2612;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5238996744155884
2613;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;Contradicts;0.6099717617034912
2614;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6137501001358032
2615;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.612162172794342
2616;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5528308749198914
2617;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;fix vm_oom_kill_table[];ifdeffery;https://github.com/torvalds/linux/commit/a19cad0691597eb79c123b8a19a9faba5ab7d90e;Contradicts;0.6301935911178589
2618;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5665339231491089
2619;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;delete unlock_range();exit_mmap() does not need locked_vm updates;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5807883739471436
2620;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Contradicts;0.5078766345977783
2621;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.6137956380844116
2622;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.5656089186668396
2623;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.5769510269165039
2624;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5350797772407532
2625;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;Contradicts;0.620863676071167
2626;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5353869199752808
2627;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.501667320728302
2628;mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";https://github.com/torvalds/linux/commit/f168a9a54ec39b3f832c353733898b713b6b5c1f;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5033243298530579
2629;fix uninitialized oc->constraint;uninitialized;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5165058970451355
2630;fix uninitialized oc->constraint;uninitialized;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7044820189476013
2631;fix uninitialized oc->constraint;uninitialized;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5027573108673096
2632;fix uninitialized oc->constraint;uninitialized;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5161977410316467
2633;fix uninitialized oc->constraint;uninitialized;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9463487863540648
2634;fix uninitialized oc->constraint;uninitialized;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8377577066421509
2635;fix uninitialized oc->constraint;uninitialized;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5345877408981323
2636;fix uninitialized oc->constraint;uninitialized;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5684800744056702
2637;fix uninitialized oc->constraint;uninitialized;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5423054099082947
2638;fix uninitialized oc->constraint;uninitialized;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5837830305099487
2639;fix uninitialized oc->constraint;uninitialized;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5494721531867981
2640;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.7646780014038086
2641;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.6344021558761597
2642;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.6104227900505066
2643;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.6412683725357056
2644;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.7875223159790039
2645;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.6881768703460693
2646;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5572723150253296
2647;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;Contradicts;0.6267999410629272
2648;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9049578309059144
2649;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.6132241487503052
2650;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8511565923690796
2651;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5609998106956482
2652;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.7282887101173401
2653;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5309616327285767
2654;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.5972926020622253
2655;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;https://github.com/torvalds/linux/commit/4d4048be8a93769350efa31d2482a038b7de73d0;Contradicts;0.5040544867515564
2656;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6976562142372131
2657;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5340224504470825
2658;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6043926477432251
2659;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;Contradicts;0.6151959300041199
2660;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5323286652565002
2661;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;delete unlock_range();exit_mmap() does not need locked_vm updates;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.574830174446106
2662;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.5387011766433716
2663;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.8080005645751953
2664;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;Contradicts;0.6930056214332581
2665;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.5296043753623962
2666;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;https://github.com/torvalds/linux/commit/dc1b83ab08f1954335692cdcd499f78c94f4c42a;prevent unnecessary oom kills or kernel panics;unnecessary oom kills or kernel panics;https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5551837086677551
2667;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7273048162460327
2668;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.8015474081039429
2669;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.91290944814682
2670;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.520997166633606
2671;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7018408179283142
2672;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5561441779136658
2673;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6310363411903381
2674;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5376741290092468
2675;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.514997124671936
2676;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6285151839256287
2677;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;Contradicts;0.7844305634498596
2678;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.5361239910125732
2679;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.7137703895568848
2680;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.6508621573448181
2681;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.9684728980064392
2682;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.6692438125610352
2683;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.7629973888397217
2684;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9363452196121216
2685;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.822709858417511
2686;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6211636066436768
2687;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;https://github.com/torvalds/linux/commit/b460cbc581a53cc088ceba80608021dd49c63c43;Contradicts;0.8256010413169861
2688;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.6580294966697693
2689;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Contradicts;0.6891578435897827
2690;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6784882545471191
2691;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.798011302947998
2692;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.628400444984436
2693;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6926468014717102
2694;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;https://github.com/torvalds/linux/commit/dc6c9a35b66b520cf67e05d8ca60ebecad3b0479;Contradicts;0.5041128396987915
2695;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5746490359306335
2696;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6443970203399658
2697;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.5582876205444336
2698;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5173624753952026
2699;Issue a SIGKILL to any thread sharing the same mm;Were safe;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;avoid attempting to kill init sharing same memory;avoid attempting to kill init;https://github.com/torvalds/linux/commit/a2b829d95958da2025ef844c0f53ac15ad720fac;Contradicts;0.8931500315666199
2700;Preventing the livelock;caring more about preventing the livelock;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Contradicts;0.5452331304550171
2701;Preventing the livelock;caring more about preventing the livelock;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.714432954788208
2702;Preventing the livelock;caring more about preventing the livelock;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8699062466621399
2703;Preventing the livelock;caring more about preventing the livelock;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6049690246582031
2704;Preventing the livelock;caring more about preventing the livelock;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.906271517276764
2705;Preventing the livelock;caring more about preventing the livelock;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5281158685684204
2706;Preventing the livelock;caring more about preventing the livelock;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5875016450881958
2707;Preventing the livelock;caring more about preventing the livelock;https://github.com/torvalds/linux/commit/1e99bad0d9c12a4aaa60cd812c84ef152564bcf5;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.7244206666946411
2708;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5041708946228027
2709;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.9202899932861328
2710;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5795639753341675
2711;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.9114421010017396
2712;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5013424754142761
2713;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Contradicts;0.5388835668563843
2714;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.6635870933532715
2715;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6437126994132996
2716;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6933497786521912
2717;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;https://github.com/torvalds/linux/commit/5a2d41961dd6815b874b5c0afec0ac96cd90eea4;Contradicts;0.5939152240753174
2718;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9684464931488036
2719;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5182629823684692
2720;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5766295790672302
2721;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.5861567854881287
2722;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5138046145439148
2723;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5274001955986023
2724;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5891293287277222
2725;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.784113883972168
2726;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5617201328277588
2727;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;https://github.com/torvalds/linux/commit/e18641e19a9204f241f04a5ac700168dcd18de4f;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5796881318092346
2728;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.793938934803009
2729;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Contradicts;0.5298181772232056
2730;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Contradicts;0.664181113243103
2731;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Contradicts;0.5039390921592712
2732;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.7569063305854797
2733;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.8800963759422302
2734;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.8725947737693787
2735;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.722074568271637
2736;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.6107714772224426
2737;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.660258948802948
2738;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Contradicts;0.5105401277542114
2739;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.5249993205070496
2740;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5217592716217041
2741;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.5419337153434753
2742;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5196046233177185
2743;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5897834300994873
2744;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.5700352787971497
2745;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8491135835647583
2746;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5213683843612671
2747;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.7066754102706909
2748;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.544086217880249
2749;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9809746742248536
2750;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.8307934403419495
2751;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;https://github.com/torvalds/linux/commit/b460cbc581a53cc088ceba80608021dd49c63c43;Contradicts;0.7373876571655273
2752;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Contradicts;0.5712020993232727
2753;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.6060817837715149
2754;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.8239971995353699
2755;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6983681321144104
2756;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7243613004684448
2757;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6725142598152161
2758;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.7604721784591675
2759;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.68888258934021
2760;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.9103249311447144
2761;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Remove the unused arguments and update all callers.;unused.;https://github.com/torvalds/linux/commit/a72afd873089c697053e9daa85ff343b3140d2e7;Contradicts;0.5400334596633911
2762;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Remove the unused arguments and update all callers.;unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;Contradicts;0.5400334596633911
2763;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7669652700424194
2764;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.8547351956367493
2765;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5933489799499512
2766;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5991485118865967
2767;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5079315900802612
2768;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5909841656684875
2769;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7446996569633484
2770;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7533476948738098
2771;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.6713556051254272
2772;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7661389112472534
2773;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5917467474937439
2774;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.742929220199585
2775;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.6581388711929321
2776;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5710852146148682
2777;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5431424975395203
2778;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.6367307305335999
2779;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6236847043037415
2780;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7591627836227417
2781;Reduces confusion;Users currently dont know which tasks in the tasklist arent eligible for kill;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6012921929359436
2782;Reduces confusion;Users currently dont know which tasks in the tasklist arent eligible for kill;https://github.com/torvalds/linux/commit/e85bfd3aa7a34fa963bb268a676b41694e6dcf96;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7458616495132446
2783;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.5291666984558105
2784;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.643977701663971
2785;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.5210478901863098
2786;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.9004099369049072
2787;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6080340147018433
2788;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9204038977622986
2789;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5100611448287964
2790;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.8121334910392761
2791;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5067917704582214
2792;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6110379695892334
2793;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5122339129447937
2794;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6392483711242676
2795;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6267938017845154
2796;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6086951494216919
2797;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;https://github.com/torvalds/linux/commit/f19e8aa11afa24036c6273428da51949b5acf30c;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7175142168998718
2798;fix NULL pointer dereference;NULL pointer dereference;https://github.com/torvalds/linux/commit/be71cf2202971e50ce4953d473649c724799eb8a;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Contradicts;0.5650827884674072
2799;fix NULL pointer dereference;NULL pointer dereference;https://github.com/torvalds/linux/commit/be71cf2202971e50ce4953d473649c724799eb8a;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5958688855171204
2800;fix NULL pointer dereference;NULL pointer dereference;https://github.com/torvalds/linux/commit/be71cf2202971e50ce4953d473649c724799eb8a;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5679733753204346
2801;fix NULL pointer dereference;NULL pointer dereference;https://github.com/torvalds/linux/commit/be71cf2202971e50ce4953d473649c724799eb8a;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7435535192489624
2802;fix NULL pointer dereference;NULL pointer dereference;https://github.com/torvalds/linux/commit/be71cf2202971e50ce4953d473649c724799eb8a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7348403334617615
2803;fix NULL pointer dereference;NULL pointer dereference;https://github.com/torvalds/linux/commit/be71cf2202971e50ce4953d473649c724799eb8a;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5486371517181396
2804;make it as simple and predictable as possible;so the results are better understood and we end up killing the task which will lead to the most memory freeing while still respecting the fine-tuning from userspace;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6942088603973389
2805;make it as simple and predictable as possible;so the results are better understood and we end up killing the task which will lead to the most memory freeing while still respecting the fine-tuning from userspace;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.8074288964271545
2806;make it as simple and predictable as possible;so the results are better understood and we end up killing the task which will lead to the most memory freeing while still respecting the fine-tuning from userspace;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5196682810783386
2807;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.5665953755378723
2808;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.5125978589057922
2809;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.845022976398468
2810;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Contradicts;0.6546885967254639
2811;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8254726529121399
2812;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5606307983398438
2813;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6122141480445862
2814;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6391156315803528
2815;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5888516306877136
2816;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.8744827508926392
2817;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6345049142837524
2818;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6877597570419312
2819;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5824095606803894
2820;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5396683216094971
2821;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.8739814162254333
2822;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5413659811019897
2823;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.8694111108779907
2824;save roots task;better to save;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.5929645299911499
2825;save roots task;better to save;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5683010816574097
2826;save roots task;better to save;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.920467495918274
2827;save roots task;better to save;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.776301920413971
2828;save roots task;better to save;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5400261282920837
2829;save roots task;better to save;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.626822829246521
2830;save roots task;better to save;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6275902390480042
2831;introduce a new user interface to tune it;Because of the change in the badness() heuristics baseline;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6214984059333801
2832;introduce a new user interface to tune it;Because of the change in the badness() heuristics baseline;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7274242639541626
2833;introduce a new user interface to tune it;Because of the change in the badness() heuristics baseline;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6249277591705322
2834;introduce a new user interface to tune it;Because of the change in the badness() heuristics baseline;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5755481719970703
2835;introduce a new user interface to tune it;Because of the change in the badness() heuristics baseline;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.520987868309021
2836;introduce a new user interface to tune it;Because of the change in the badness() heuristics baseline;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5260805487632751
2837;introduce a new user interface to tune it;Because of the change in the badness() heuristics baseline;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6519522666931152
2838;Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.528849184513092
2839;Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Share the same oom_score_adj;As a result;https://github.com/torvalds/linux/commit/44a70adec910d6929689e42b6e5cee5b7d202d20;Contradicts;0.6022757887840271
2840;Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5383895039558411
2841;Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.773402750492096
2842;Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.8994767069816589
2843;Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5289714336395264
2844;Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7451733946800232
2845;Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7017013430595398
2846;Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5921452045440674
2847;Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5739494562149048
2848;Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5175164341926575
2849;Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.8120142221450806
2850;Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7215525507926941
2851;Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7112041115760803
2852;Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6802119016647339
2853;Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6673049330711365
2854;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.5541818737983704
2855;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Share the same oom_score_adj;As a result;https://github.com/torvalds/linux/commit/44a70adec910d6929689e42b6e5cee5b7d202d20;Contradicts;0.704066276550293
2856;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Contradicts;0.5784716010093689
2857;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.7759650945663452
2858;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.539149284362793
2859;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.679038941860199
2860;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.5902624130249023
2861;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.6188331246376038
2862;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;Contradicts;0.7799621820449829
2863;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5756164193153381
2864;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.5223522782325745
2865;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6074953675270081
2866;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7247251272201538
2867;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9855388402938844
2868;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.6450268030166626
2869;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.537543535232544
2870;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.515976071357727
2871;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.62757807970047
2872;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6690300703048706
2873;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7676665782928467
2874;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5735779404640198
2875;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6760731935501099
2876;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.587704062461853
2877;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5689425468444824
2878;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6400083303451538
2879;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5193763971328735
2880;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5620424151420593
2881;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;https://github.com/torvalds/linux/commit/a63d83f427fbce97a6cea0db2e64b0eb8435cd10;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5351361036300659
2882;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.5248386263847351
2883;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.5282915234565735
2884;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Contradicts;0.8153830766677856
2885;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5532717704772949
2886;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.537560224533081
2887;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9678029417991638
2888;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5265142321586609
2889;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7132031321525574
2890;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8045605421066284
2891;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.6127514243125916
2892;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7714842557907104
2893;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5329400300979614
2894;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6397092938423157
2895;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7851830720901489
2896;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6775057911872864
2897;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.579713761806488
2898;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6147298812866211
2899;Remove this dubious PF_EXITING check;dubious;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;considered a reasonable constrain;the overall system health is more important than debugability of a particular application;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7468937039375305
2900;add the protection of multi threaded issue;protection of multi threaded issue;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6895530223846436
2901;add the protection of multi threaded issue;protection of multi threaded issue;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5876460671424866
2902;add the protection of multi threaded issue;protection of multi threaded issue;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.8572232127189636
2903;add the protection of multi threaded issue;protection of multi threaded issue;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7599762082099915
2904;add the protection of multi threaded issue;protection of multi threaded issue;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5715824961662292
2905;add the protection of multi threaded issue;protection of multi threaded issue;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5570576190948486
2906;add the protection of multi threaded issue;protection of multi threaded issue;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6227614879608154
2907;add the protection of multi threaded issue;protection of multi threaded issue;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5442156195640564
2908;add the protection of multi threaded issue;protection of multi threaded issue;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7150418162345886
2909;add the protection of multi threaded issue;protection of multi threaded issue;https://github.com/torvalds/linux/commit/cef1d3523d33ebc35fc29e454b1f4bab953fabbf;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5334982872009277
2910;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Contradicts;0.9701312780380248
2911;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Contradicts;0.8420583605766296
2912;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5335032939910889
2913;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.9638588428497314
2914;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5722613334655762
2915;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5764114260673523
2916;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.540404736995697
2917;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.632073700428009
2918;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5684332251548767
2919;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.5911255478858948
2920;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.577125608921051
2921;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.586818516254425
2922;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5654823184013367
2923;Using SCHED_FIFO:1 with the lowest RT priority;This task wont interfere with any running RT task;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7040187120437622
2924;Using SCHED_FIFO:1 with the lowest RT priority;This task wont interfere with any running RT task;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8436502814292908
2925;Using SCHED_FIFO:1 with the lowest RT priority;This task wont interfere with any running RT task;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8353116512298584
2926;Using SCHED_FIFO:1 with the lowest RT priority;This task wont interfere with any running RT task;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.7461979389190674
2927;Using SCHED_FIFO:1 with the lowest RT priority;This task wont interfere with any running RT task;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5034538507461548
2928;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.5079643130302429
2929;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.8231638073921204
2930;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5573463439941406
2931;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6663934588432312
2932;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5134943723678589
2933;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Contradicts;0.626952052116394
2934;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.6039251089096069
2935;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.6209574341773987
2936;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.6617358922958374
2937;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7475952506065369
2938;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Contradicts;0.813704252243042
2939;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9093525409698486
2940;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5811890959739685
2941;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7517141103744507
2942;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6903634667396545
2943;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5885800719261169
2944;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.6944314241409302
2945;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6568410396575928
2946;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6734459400177002
2947;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;improve that even further;there is a common pattern to do a range lookup first and then do something about that;https://github.com/torvalds/linux/commit/93065ac753e4443840a057bfef4be71ec766fde9;Contradicts;0.9647380709648132
2948;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5514981150627136
2949;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.7781861424446106
2950;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7213945388793945
2951;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;https://github.com/torvalds/linux/commit/93b43fa55088fe977503a156d1097cc2055449a2;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5968958139419556
2952;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;https://github.com/torvalds/linux/commit/7c5f64f84483bd13886348edda8b3e7b799a7fdb;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6356723308563232
2953;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;https://github.com/torvalds/linux/commit/7c5f64f84483bd13886348edda8b3e7b799a7fdb;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.676913857460022
2954;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;https://github.com/torvalds/linux/commit/7c5f64f84483bd13886348edda8b3e7b799a7fdb;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.5350014567375183
2955;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;https://github.com/torvalds/linux/commit/7c5f64f84483bd13886348edda8b3e7b799a7fdb;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5986831188201904
2956;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;https://github.com/torvalds/linux/commit/7c5f64f84483bd13886348edda8b3e7b799a7fdb;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9395585656166076
2957;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;https://github.com/torvalds/linux/commit/7c5f64f84483bd13886348edda8b3e7b799a7fdb;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6383635997772217
2958;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;https://github.com/torvalds/linux/commit/7c5f64f84483bd13886348edda8b3e7b799a7fdb;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5181306004524231
2959;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;https://github.com/torvalds/linux/commit/7c5f64f84483bd13886348edda8b3e7b799a7fdb;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7091047763824463
2960;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;https://github.com/torvalds/linux/commit/7c5f64f84483bd13886348edda8b3e7b799a7fdb;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5447825789451599
2961;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;https://github.com/torvalds/linux/commit/7c5f64f84483bd13886348edda8b3e7b799a7fdb;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5724483132362366
2962;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;https://github.com/torvalds/linux/commit/7c5f64f84483bd13886348edda8b3e7b799a7fdb;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6219726800918579
2963;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;https://github.com/torvalds/linux/commit/7c5f64f84483bd13886348edda8b3e7b799a7fdb;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7956293821334839
2964;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;https://github.com/torvalds/linux/commit/7c5f64f84483bd13886348edda8b3e7b799a7fdb;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5950672030448914
2965;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;https://github.com/torvalds/linux/commit/7c5f64f84483bd13886348edda8b3e7b799a7fdb;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6006541848182678
2966;fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();https://github.com/torvalds/linux/commit/f33e6f0671b3ba81acef4d7c078af86afcc855c4;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6770622134208679
2967;fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();https://github.com/torvalds/linux/commit/f33e6f0671b3ba81acef4d7c078af86afcc855c4;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.8695888519287109
2968;fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();https://github.com/torvalds/linux/commit/f33e6f0671b3ba81acef4d7c078af86afcc855c4;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.6321505904197693
2969;fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();https://github.com/torvalds/linux/commit/f33e6f0671b3ba81acef4d7c078af86afcc855c4;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.935595154762268
2970;fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();https://github.com/torvalds/linux/commit/f33e6f0671b3ba81acef4d7c078af86afcc855c4;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7269646525382996
2971;fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();https://github.com/torvalds/linux/commit/f33e6f0671b3ba81acef4d7c078af86afcc855c4;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9070180058479308
2972;fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();https://github.com/torvalds/linux/commit/f33e6f0671b3ba81acef4d7c078af86afcc855c4;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5606536865234375
2973;fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();https://github.com/torvalds/linux/commit/f33e6f0671b3ba81acef4d7c078af86afcc855c4;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5977789163589478
2974;fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();https://github.com/torvalds/linux/commit/f33e6f0671b3ba81acef4d7c078af86afcc855c4;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6322241425514221
2975;fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();https://github.com/torvalds/linux/commit/f33e6f0671b3ba81acef4d7c078af86afcc855c4;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.7613899111747742
2976;fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();https://github.com/torvalds/linux/commit/f33e6f0671b3ba81acef4d7c078af86afcc855c4;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.573842465877533
2977;fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();https://github.com/torvalds/linux/commit/f33e6f0671b3ba81acef4d7c078af86afcc855c4;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5360103249549866
2978;fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();https://github.com/torvalds/linux/commit/f33e6f0671b3ba81acef4d7c078af86afcc855c4;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6651526689529419
2979;fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();https://github.com/torvalds/linux/commit/f33e6f0671b3ba81acef4d7c078af86afcc855c4;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.6399635076522827
2980;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.9196491241455078
2981;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.743392288684845
2982;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5005500316619873
2983;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.5125125050544739
2984;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.610219419002533
2985;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.5801780223846436
2986;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.797813892364502
2987;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.556790828704834
2988;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.5757963061332703
2989;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.535942554473877
2990;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5439894795417786
2991;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5665164589881897
2992;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6195729970932007
2993;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.568692147731781
2994;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7343560457229614
2995;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6154162287712097
2996;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5118972659111023
2997;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;Contradicts;0.7373616695404053
2998;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5385299921035767
2999;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5063645243644714
3000;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9666697978973388
3001;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7479274272918701
3002;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.6301577091217041
3003;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7249714732170105
3004;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5801420211791992
3005;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5661689043045044
3006;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.9888556599617004
3007;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6645389795303345
3008;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Fix the setting of PF_SUPERPRIV by __capable();it could corrupt the flags of the target process if that is not the current process and it is trying to change its own flags in a different way at the same time;https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.527653694152832
3009;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.96465665102005
3010;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.816457211971283
3011;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.618346631526947
3012;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;https://github.com/torvalds/linux/commit/a373966d1f64c04ba9d0159087f0fa1b5aac4c33;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5086889266967773
3013;do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.672745406627655
3014;do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5854707360267639
3015;do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.6931177973747253
3016;do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.606389045715332
3017;do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.8484551310539246
3018;do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.735261082649231
3019;do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5183103084564209
3020;do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5801655650138855
3021;do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.517170786857605
3022;do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6149299144744873
3023;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Contradicts;0.8303772211074829
3024;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.5997553467750549
3025;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5162053108215332
3026;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;Contradicts;0.633039116859436
3027;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.549816906452179
3028;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.5515480041503906
3029;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.540238618850708
3030;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.501764178276062
3031;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6810458302497864
3032;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;Contradicts;0.6966980695724487
3033;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7271487712860107
3034;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.5115420818328857
3035;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6459352374076843
3036;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;Contradicts;0.6387493014335632
3037;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.980414867401123
3038;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;https://github.com/torvalds/linux/commit/c4812909f5d5a9b7f1c85a2d95be388a066cda52;Contradicts;0.5315277576446533
3039;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;hold tasklist_lock;tsk->sighand is not guarded by RCU, just as what out_of_memory() does.;https://github.com/torvalds/linux/commit/e115f2d89253490fb2dbf304b627f8d908df26f1;Contradicts;0.6571378707885742
3040;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.8301973342895508
3041;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6448769569396973
3042;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;account the memory consumption of the (direct) children to the father;we do want to;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5475614666938782
3043;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5836616158485413
3044;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5196988582611084
3045;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6110185384750366
3046;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.9637911915779114
3047;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.644835889339447
3048;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.564658522605896
3049;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.5420147180557251
3050;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.7344719767570496
3051;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6500751972198486
3052;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9239727258682252
3053;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.9602887630462646
3054;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.752415120601654
3055;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5508045554161072
3056;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.8293426036834717
3057;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6228170990943909
3058;mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5112414956092834
3059;mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.8154172301292419
3060;mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.5257880687713623
3061;mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.837594747543335
3062;mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7830028533935547
3063;mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7416001558303833
3064;mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6109034419059753
3065;mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.8716886639595032
3066;mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6873854398727417
3067;mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;https://github.com/torvalds/linux/commit/11a410d516e89320fe0817606eeab58f36c22968;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5447046756744385
3068;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5327144861221313
3069;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.7507494688034058
3070;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7096593379974365
3071;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.6122131943702698
3072;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5252294540405273
3073;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.591985821723938
3074;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5105500221252441
3075;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.5376771092414856
3076;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;Contradicts;0.5689923167228699
3077;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Contradicts;0.9313011169433594
3078;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6715403199195862
3079;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6898928284645081
3080;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6501173377037048
3081;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Contradicts;0.5534417033195496
3082;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.928740382194519
3083;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.527575671672821
3084;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6059690117835999
3085;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.59527188539505
3086;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.6092197895050049
3087;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8663981556892395
3088;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.7536761164665222
3089;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;convert it to atomic_long_t;to avoid races;https://github.com/torvalds/linux/commit/e1f56c89b040134add93f686931cc266541d239a;Contradicts;0.5068153142929077
3090;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5368541479110718
3091;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7517419457435608
3092;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7775372266769409
3093;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5301575064659119
3094;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6188932061195374
3095;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.9512616991996764
3096;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;Contradicts;0.6110326647758484
3097;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;Contradicts;0.5454996824264526
3098;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5152219533920288
3099;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.500573992729187
3100;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5089563131332397
3101;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;introduce a dedicated system call to cover this use case;to cover this use case;https://github.com/torvalds/linux/commit/884a7e5964e06ed93c7771c0d7cf19c09a8946f1;Contradicts;0.5123860836029053
3102;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5242276191711426
3103;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;https://github.com/torvalds/linux/commit/696453e66630ad45e644c4571307fa3ebec9a835;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.8402993083000183
3104;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7942423820495605
3105;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.5748862028121948
3106;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.660449206829071
3107;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5541409850120544
3108;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8275583386421204
3109;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.9584692120552064
3110;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6390777230262756
3111;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.537747859954834
3112;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6148234009742737
3113;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5733076930046082
3114;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5164253115653992
3115;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6489585041999817
3116;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5578796863555908
3117;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Contradicts;0.6909119486808777
3118;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5475749969482422
3119;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.8306900262832642
3120;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.7800388336181641
3121;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7212228178977966
3122;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5707993507385254
3123;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.541854739189148
3124;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5228712558746338
3125;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9884097576141356
3126;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7085533738136292
3127;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.800855278968811
3128;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;https://github.com/torvalds/linux/commit/b460cbc581a53cc088ceba80608021dd49c63c43;Contradicts;0.5184592604637146
3129;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6451300978660583
3130;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8544019460678101
3131;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.7670086026191711
3132;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Contradicts;0.5117706060409546
3133;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5819286704063416
3134;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5200175046920776
3135;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.6972782611846924
3136;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.519551694393158
3137;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6317715644836426
3138;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;https://github.com/torvalds/linux/commit/1af8bb43269563e458ebcf0ece812e9a970864b3;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7378474473953247
3139;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Contradicts;0.5471659898757935
3140;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.6129916906356812
3141;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5311810970306396
3142;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.7318252325057983
3143;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.9511706829071044
3144;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.8539674878120422
3145;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.7661378979682922
3146;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7442327737808228
3147;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5993015170097351
3148;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6463802456855774
3149;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.569616436958313
3150;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.9252411127090454
3151;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5007367730140686
3152;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;OOM killed task shouldnt escape PM suspend;OOM;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6598448753356934
3153;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.6203087568283081
3154;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.6043961644172668
3155;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.531522810459137
3156;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6290145516395569
3157;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5654554963111877
3158;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.5955998301506042
3159;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.6094567775726318
3160;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;Contradicts;0.7001488208770752
3161;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8697758316993713
3162;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.93562513589859
3163;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5869907736778259
3164;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5441757440567017
3165;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5170065760612488
3166;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.7551436424255371
3167;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6671987771987915
3168;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;https://github.com/torvalds/linux/commit/97fd49c2355ffdede6526afc0c72bc314d05f42a;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5553807616233826
3169;Share the same oom_score_adj;As a result;https://github.com/torvalds/linux/commit/44a70adec910d6929689e42b6e5cee5b7d202d20;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5327844619750977
3170;Share the same oom_score_adj;As a result;https://github.com/torvalds/linux/commit/44a70adec910d6929689e42b6e5cee5b7d202d20;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7545636892318726
3171;Share the same oom_score_adj;As a result;https://github.com/torvalds/linux/commit/44a70adec910d6929689e42b6e5cee5b7d202d20;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5579921007156372
3172;Share the same oom_score_adj;As a result;https://github.com/torvalds/linux/commit/44a70adec910d6929689e42b6e5cee5b7d202d20;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.8492757081985474
3173;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5661969780921936
3174;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5942755937576294
3175;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.5329549908638
3176;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.5046627521514893
3177;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8577853441238403
3178;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5441907644271851
3179;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8907939195632935
3180;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6423602104187012
3181;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5265532732009888
3182;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.667319118976593
3183;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.504689633846283
3184;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.7947207093238831
3185;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5874481797218323
3186;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5683175325393677
3187;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5660483241081238
3188;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5984007120132446
3189;make sure that the mmput_async is only called;when we do not back off and reap some memory;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5838497877120972
3190;make sure that the mmput_async is only called;when we do not back off and reap some memory;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9187334775924684
3191;make sure that the mmput_async is only called;when we do not back off and reap some memory;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6200847625732422
3192;make sure that the mmput_async is only called;when we do not back off and reap some memory;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;Contradicts;0.5140655040740967
3193;make sure that the mmput_async is only called;when we do not back off and reap some memory;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6673343777656555
3194;make sure that the mmput_async is only called;when we do not back off and reap some memory;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5319727063179016
3195;make sure that the mmput_async is only called;when we do not back off and reap some memory;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5030643939971924
3196;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.7227261066436768
3197;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6602660417556763
3198;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.550891637802124
3199;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5309047102928162
3200;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.6578278541564941
3201;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5641233921051025
3202;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8769727945327759
3203;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5776039361953735
3204;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9820636510849
3205;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5114685297012329
3206;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.6730485558509827
3207;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6670740842819214
3208;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8078412413597107
3209;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5781289339065552
3210;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5678671002388
3211;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.600365936756134
3212;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5788412094116211
3213;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.8196483850479126
3214;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5506792664527893
3215;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6214274168014526
3216;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6032921671867371
3217;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6422740817070007
3218;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5229644775390625
3219;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.8961778283119202
3220;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6898066997528076
3221;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8776810765266418
3222;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;"This is identical to the global oom killer and is done even before checking for panic_on_oom: a pending SIGKILL here while panic_on_oom is selected is guaranteed to have come from userspace; the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory.";the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.6747753024101257
3223;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7425937056541443
3224;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;https://github.com/torvalds/linux/commit/e5e3f4c4f0e95ecbad2f8d2f4f6a29bb8a90226b;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5524402260780334
3225;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Contradicts;0.5051320195198059
3226;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.610297441482544
3227;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.554570734500885
3228;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.853939414024353
3229;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9289954900741576
3230;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5933722257614136
3231;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5300431847572327
3232;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6615352034568787
3233;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5340024828910828
3234;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5208501815795898
3235;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6742411851882935
3236;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.792375922203064
3237;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6839572787284851
3238;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5271478891372681
3239;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.5129317045211792
3240;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.5463006496429443
3241;remove unused argument from oom_scan_process_thread();unused argument;https://github.com/torvalds/linux/commit/fbe84a09da746f781553051bb3dbc63f7b0a5162;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.545428454875946
3242;avoid pointless atomic_inc_not_zero usage;pointless;https://github.com/torvalds/linux/commit/9df10fb7b80bc2f540956ba01b5e7ee1012001a5;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;Contradicts;0.5104073286056519
3243;avoid pointless atomic_inc_not_zero usage;pointless;https://github.com/torvalds/linux/commit/9df10fb7b80bc2f540956ba01b5e7ee1012001a5;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.6053888201713562
3244;avoid pointless atomic_inc_not_zero usage;pointless;https://github.com/torvalds/linux/commit/9df10fb7b80bc2f540956ba01b5e7ee1012001a5;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.876075804233551
3245;avoid pointless atomic_inc_not_zero usage;pointless;https://github.com/torvalds/linux/commit/9df10fb7b80bc2f540956ba01b5e7ee1012001a5;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5755262970924377
3246;avoid pointless atomic_inc_not_zero usage;pointless;https://github.com/torvalds/linux/commit/9df10fb7b80bc2f540956ba01b5e7ee1012001a5;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6760510802268982
3247;avoid pointless atomic_inc_not_zero usage;pointless;https://github.com/torvalds/linux/commit/9df10fb7b80bc2f540956ba01b5e7ee1012001a5;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.908858835697174
3248;avoid pointless atomic_inc_not_zero usage;pointless;https://github.com/torvalds/linux/commit/9df10fb7b80bc2f540956ba01b5e7ee1012001a5;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.686836838722229
3249;avoid pointless atomic_inc_not_zero usage;pointless;https://github.com/torvalds/linux/commit/9df10fb7b80bc2f540956ba01b5e7ee1012001a5;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6531087160110474
3250;avoid pointless atomic_inc_not_zero usage;pointless;https://github.com/torvalds/linux/commit/9df10fb7b80bc2f540956ba01b5e7ee1012001a5;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5405005812644958
3251;avoid pointless atomic_inc_not_zero usage;pointless;https://github.com/torvalds/linux/commit/9df10fb7b80bc2f540956ba01b5e7ee1012001a5;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5395996570587158
3252;avoid pointless atomic_inc_not_zero usage;pointless;https://github.com/torvalds/linux/commit/9df10fb7b80bc2f540956ba01b5e7ee1012001a5;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5372916460037231
3253;avoid pointless atomic_inc_not_zero usage;pointless;https://github.com/torvalds/linux/commit/9df10fb7b80bc2f540956ba01b5e7ee1012001a5;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5078390836715698
3254;avoid pointless atomic_inc_not_zero usage;pointless;https://github.com/torvalds/linux/commit/9df10fb7b80bc2f540956ba01b5e7ee1012001a5;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5148592591285706
3255;avoid pointless atomic_inc_not_zero usage;pointless;https://github.com/torvalds/linux/commit/9df10fb7b80bc2f540956ba01b5e7ee1012001a5;"Users of mmap_sem which need it for write should be carefully reviewed to use _killable waiting as much as possible and reduce allocations requests done with the lock held to absolute minimum
";to reduce the risk even further;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7100590467453003
3256;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Contradicts;0.6964238882064819
3257;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;Contradicts;0.5813654661178589
3258;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.94746994972229
3259;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.8328566551208496
3260;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.5046330094337463
3261;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.9431933760643004
3262;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.7683367729187012
3263;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.7572123408317566
3264;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.5711251497268677
3265;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.7697513699531555
3266;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.6429533958435059
3267;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.719779372215271
3268;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.6151294112205505
3269;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;Contradicts;0.5116421580314636
3270;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.6332069635391235
3271;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9132379293441772
3272;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.666348934173584
3273;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.7711434960365295
3274;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6359351873397827
3275;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7484703063964844
3276;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.951137125492096
3277;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5860964059829712
3278;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.7195995450019836
3279;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;https://github.com/torvalds/linux/commit/b460cbc581a53cc088ceba80608021dd49c63c43;Contradicts;0.8662110567092896
3280;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Contradicts;0.575320839881897
3281;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.6120214462280273
3282;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.5502035617828369
3283;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7317241430282593
3284;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.547326922416687
3285;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5772113800048828
3286;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7093960642814636
3287;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.6649218797683716
3288;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.7740225791931152
3289;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.8521130084991455
3290;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.6137053966522217
3291;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.748601496219635
3292;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7320769429206848
3293;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7495945692062378
3294;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.6194359064102173
3295;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5662568807601929
3296;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6899624466896057
3297;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7991642951965332
3298;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5688450336456299
3299;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5379372835159302
3300;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.7732310891151428
3301;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.7670913338661194
3302;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.7270742058753967
3303;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7245194315910339
3304;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5593787431716919
3305;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8017164468765259
3306;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5580986142158508
3307;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.514288604259491
3308;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6753458380699158
3309;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;make the oom_reaper thread freezable;In order to close this race;https://github.com/torvalds/linux/commit/e26796066fdf929cbba22dabb801808f986acdb9;Contradicts;0.6332015991210938
3310;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6632214188575745
3311;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;https://github.com/torvalds/linux/commit/1e11ad8dc42975d5c2bab7d478f6cd875602eda4;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.8617316484451294
3312;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.785443127155304
3313;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Contradicts;0.5588447451591492
3314;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6075855493545532
3315;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5822286009788513
3316;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5102534294128418
3317;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5891797542572021
3318;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8167508840560913
3319;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5691323280334473
3320;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5581678152084351
3321;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6509897112846375
3322;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.8016552329063416
3323;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5818197727203369
3324;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6729055643081665
3325;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.7025650143623352
3326;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.5120015144348145
3327;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6813748478889465
3328;The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;https://github.com/torvalds/linux/commit/078de5f706ece36afd73bb4b8283314132d2dfdf;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5097836852073669
3329;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.9903081059455872
3330;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.6272203326225281
3331;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.6167725920677185
3332;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5473225712776184
3333;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9716376066207886
3334;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5658572316169739
3335;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8441298007965088
3336;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6296319365501404
3337;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.9105663299560548
3338;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Contradicts;0.8378188610076904
3339;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5526259541511536
3340;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7908309698104858
3341;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7623446583747864
3342;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5812970399856567
3343;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.7148774862289429
3344;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.5197437405586243
3345;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5238007307052612
3346;force oom kill on sysrq+f;oom;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;prevent unnecessary oom kills or kernel panics;unnecessary oom kills or kernel panics;https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6310596466064453
3347;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5395693778991699
3348;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.7894975543022156
3349;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.9958349466323853
3350;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Contradicts;0.5185307860374451
3351;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;Contradicts;0.7794138789176941
3352;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.6050109267234802
3353;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.6413170099258423
3354;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9140267968177797
3355;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5034478902816772
3356;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6121180057525635
3357;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7443369030952454
3358;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5293264985084534
3359;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6159095764160156
3360;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7673611044883728
3361;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5446219444274902
3362;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;https://github.com/torvalds/linux/commit/1da4db0cd5c8a31d4468ec906b413e75e604b465;Contradicts;0.5157174468040466
3363;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8622056245803833
3364;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.8136602640151978
3365;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5109316110610962
3366;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;https://github.com/torvalds/linux/commit/dc6c9a35b66b520cf67e05d8ca60ebecad3b0479;Contradicts;0.6801459789276123
3367;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;This patch fixes the problem and should be backported into stable/LTS.;Fixes the problem, should be backported into stable/LTS.;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.5331392288208008
3368;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;allow privileged processes to receive SIGIO on files theyre manipulating;privileged processes;https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5221213698387146
3369;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;https://github.com/torvalds/linux/commit/08ab9b10d43aca091fdff58b69fc1ec89c5b8a83;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.697425901889801
3370;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.5787927508354187
3371;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Contradicts;0.8594553470611572
3372;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5214270353317261
3373;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9478787183761596
3374;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5936840772628784
3375;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7016037702560425
3376;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;start isolating the tons of warnings;cannot be sent right now as this leads to tons of warnings;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;Contradicts;0.8898607492446899
3377;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5185410976409912
3378;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.823732852935791
3379;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5279209017753601
3380;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5278210639953613
3381;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5191182494163513
3382;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7054243683815002
3383;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.5305333733558655
3384;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6332203149795532
3385;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6644187569618225
3386;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.5370574593544006
3387;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;https://github.com/torvalds/linux/commit/8447d950e7445cae71ad66d0e33784f8388aaf9d;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5297664403915405
3388;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6939150094985962
3389;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.5219193696975708
3390;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.593895673751831
3391;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6744842529296875
3392;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.6870158910751343
3393;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6198047995567322
3394;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.52953040599823
3395;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5223960876464844
3396;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.869367778301239
3397;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5589432716369629
3398;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.7593444585800171
3399;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7584571242332458
3400;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5750792622566223
3401;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.9629665613174438
3402;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.528243899345398
3403;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.54969322681427
3404;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5482161045074463
3405;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5908879041671753
3406;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;https://github.com/torvalds/linux/commit/647f2bdf4a00dbcaa8964286501d68e7d2e6da93;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5121718645095825
3407;avoid looping when chosen thread detaches its mm;mm, oom;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8468344211578369
3408;avoid looping when chosen thread detaches its mm;mm, oom;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8993935585021973
3409;avoid looping when chosen thread detaches its mm;mm, oom;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6317106485366821
3410;avoid looping when chosen thread detaches its mm;mm, oom;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5878216624259949
3411;avoid looping when chosen thread detaches its mm;mm, oom;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.679168701171875
3412;avoid looping when chosen thread detaches its mm;mm, oom;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5390293002128601
3413;avoid looping when chosen thread detaches its mm;mm, oom;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.5400962233543396
3414;avoid looping when chosen thread detaches its mm;mm, oom;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7820836305618286
3415;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6378688216209412
3416;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.6185795664787292
3417;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7777484655380249
3418;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5591397285461426
3419;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6140072345733643
3420;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5148224234580994
3421;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8125495314598083
3422;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.6929923295974731
3423;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6561574935913086
3424;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.509337306022644
3425;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5185734629631042
3426;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5273609161376953
3427;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6228276491165161
3428;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5454525351524353
3429;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;https://github.com/torvalds/linux/commit/2a1c9b1fc0a0ea2e30cdeb69062647c5c5ae661f;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7301976680755615
3430;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7796117663383484
3431;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7891577482223511
3432;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.6276125907897949
3433;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.6240331530570984
3434;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7017263770103455
3435;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5349928140640259
3436;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.937024176120758
3437;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5160490870475769
3438;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6229957342147827
3439;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5821910500526428
3440;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7444807887077332
3441;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.555729866027832
3442;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.7595142126083374
3443;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7928256988525391
3444;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5936400890350342
3445;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5887573957443237
3446;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.5419567227363586
3447;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5432254076004028
3448;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6326820850372314
3449;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5771497488021851
3450;add tracepoints for debugging oom_score_adj;debugging oom_score_adj;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7474393248558044
3451;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.8696849346160889
3452;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.8932453989982605
3453;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.5701579451560974
3454;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5859850645065308
3455;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7560935020446777
3456;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5017947554588318
3457;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5432300567626953
3458;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.587342381477356
3459;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5280524492263794
3460;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.5537694096565247
3461;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5794355273246765
3462;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.5391545295715332
3463;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.5937201380729675
3464;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7023866772651672
3465;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.565214216709137
3466;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5313495397567749
3467;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7607860565185547
3468;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5914603471755981
3469;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.6638549566268921
3470;adds some tracepoints useful for debugging;useful for debugging;https://github.com/torvalds/linux/commit/43d2b113241d6797b890318767e0af78e313414b;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7040631175041199
3471;fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;https://github.com/torvalds/linux/commit/ff05b6f7ae762b6eb464183eec994b28ea09f6dd;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.7733739018440247
3472;fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;https://github.com/torvalds/linux/commit/ff05b6f7ae762b6eb464183eec994b28ea09f6dd;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.6109107136726379
3473;fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;https://github.com/torvalds/linux/commit/ff05b6f7ae762b6eb464183eec994b28ea09f6dd;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.5536962747573853
3474;fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;https://github.com/torvalds/linux/commit/ff05b6f7ae762b6eb464183eec994b28ea09f6dd;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8639540076255798
3475;fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;https://github.com/torvalds/linux/commit/ff05b6f7ae762b6eb464183eec994b28ea09f6dd;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9294591546058656
3476;fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;https://github.com/torvalds/linux/commit/ff05b6f7ae762b6eb464183eec994b28ea09f6dd;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5393247604370117
3477;fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;https://github.com/torvalds/linux/commit/ff05b6f7ae762b6eb464183eec994b28ea09f6dd;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.647682249546051
3478;fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;https://github.com/torvalds/linux/commit/ff05b6f7ae762b6eb464183eec994b28ea09f6dd;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5479421019554138
3479;The points variable should be of type long instead of int;to prevent the int overflow;https://github.com/torvalds/linux/commit/ff05b6f7ae762b6eb464183eec994b28ea09f6dd;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.5876561403274536
3480;The points variable should be of type long instead of int;to prevent the int overflow;https://github.com/torvalds/linux/commit/ff05b6f7ae762b6eb464183eec994b28ea09f6dd;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5690229535102844
3481;The points variable should be of type long instead of int;to prevent the int overflow;https://github.com/torvalds/linux/commit/ff05b6f7ae762b6eb464183eec994b28ea09f6dd;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6183850765228271
3482;The points variable should be of type long instead of int;to prevent the int overflow;https://github.com/torvalds/linux/commit/ff05b6f7ae762b6eb464183eec994b28ea09f6dd;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5932655930519104
3483;The points variable should be of type long instead of int;to prevent the int overflow;https://github.com/torvalds/linux/commit/ff05b6f7ae762b6eb464183eec994b28ea09f6dd;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5478817224502563
3484;The points variable should be of type long instead of int;to prevent the int overflow;https://github.com/torvalds/linux/commit/ff05b6f7ae762b6eb464183eec994b28ea09f6dd;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.8205668926239014
3485;The points variable should be of type long instead of int;to prevent the int overflow;https://github.com/torvalds/linux/commit/ff05b6f7ae762b6eb464183eec994b28ea09f6dd;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5883691310882568
3486;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.6144779920578003
3487;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.827915370464325
3488;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.525833249092102
3489;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5804532170295715
3490;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9759669899940492
3491;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7052704691886902
3492;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;Update the comments for __oom_kill_task();to reflect the code changes;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;Contradicts;0.5922369956970215
3493;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6289339065551758
3494;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5045501589775085
3495;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.698418140411377
3496;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6092883944511414
3497;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6228422522544861
3498;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.7065264582633972
3499;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7189014554023743
3500;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;https://github.com/torvalds/linux/commit/a5be2d0d1a8746e7be5210e3d6b904455000443c;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7879863381385803
3501;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Contradicts;0.8951513171195984
3502;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;remove deprecated oom_adj;deprecated;https://github.com/torvalds/linux/commit/01dc52ebdf472f77cca623ca693ca24cfc0f1bbe;Contradicts;0.7406647801399231
3503;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.5162891149520874
3504;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.5309668183326721
3505;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5710368752479553
3506;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.7942338585853577
3507;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5880130529403687
3508;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5918311476707458
3509;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.5554365515708923
3510;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.8829692602157593
3511;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;Contradicts;0.8215858936309814
3512;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5756056308746338
3513;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6212059259414673
3514;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6776975393295288
3515;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5989838242530823
3516;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6774080991744995
3517;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8888220191001892
3518;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;remove pointless kthread_run() error check;pointless;https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6013763546943665
3519;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.8854277729988098
3520;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.6317017078399658
3521;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6581191420555115
3522;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5955057144165039
3523;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7360905408859253
3524;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5253098011016846
3525;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.5010088682174683
3526;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.7059566974639893
3527;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5939937829971313
3528;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.7927441596984863
3529;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.7889683842658997
3530;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5118024945259094
3531;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.8233957290649414
3532;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5035921335220337
3533;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5486918091773987
3534;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6974696516990662
3535;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Contradicts;0.6941395998001099
3536;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.7466435432434082
3537;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;Contradicts;0.5836405158042908
3538;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5528669953346252
3539;A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;https://github.com/torvalds/linux/commit/43362a4977e37db46f86f7e6ab935f0006956632;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6165356040000916
3540;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.6512171626091003
3541;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Contradicts;0.5650776028633118
3542;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Pinning mms mm_count for longer time;not really harmful because this will not pin much memory;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;Contradicts;0.5894928574562073
3543;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.5771805644035339
3544;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.5147033929824829
3545;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5135403871536255
3546;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.6416929364204407
3547;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;Contradicts;0.6860982179641724
3548;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;Contradicts;0.5227413773536682
3549;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9420555233955384
3550;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6910541653633118
3551;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;Contradicts;0.5008863806724548
3552;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;Contradicts;0.5355128645896912
3553;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9374249577522278
3554;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.6215412616729736
3555;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;mm locking fix;oom-kill;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.5566478371620178
3556;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;check all threads which could share the same ->mm;to make it more or less correct;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.7944661974906921
3557;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6317790150642395
3558;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5180343985557556
3559;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.7341346144676208
3560;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;I added some more output;Users tend to be irritated by the choice of killed processes;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.8288033604621887
3561;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.7292900681495667
3562;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;integrate them and add some comment to struct alloc_context;reduce future confusion about the meaning of this variable;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.549071729183197
3563;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Introduce two new options for madvise;To achieve the goal;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Contradicts;0.5263384580612183
3564;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.5043659210205078
3565;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.7376571297645569
3566;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.9654608964920044
3567;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Add comments describing oom_locks scope;describing oom_locks scope;https://github.com/torvalds/linux/commit/a195d3f5b74f3f45a6742f9063b5e95a2522b46d;Contradicts;0.6578661203384399
3568;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5131326913833618
3569;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.8462247252464294
3570;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.8245282173156738
3571;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Contradicts;0.6374555826187134
3572;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Add a new flag PF_POSTCOREDUMP;so that tasks that have passed through coredump_task_exit can be recognized and ignored in zap_process;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5116433501243591
3573;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6722832322120667
3574;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7648303508758545
3575;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;adds MM_SHMEMPAGES counter to mm_rss_stat;to account for shmem pages separately from MM_FILEPAGES;https://github.com/torvalds/linux/commit/eca56ff906bdd0239485e8b47154a6e73dd9a2f3;Contradicts;0.5710217356681824
3576;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.673507571220398
3577;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5221343636512756
3578;Remove the count;Its better to remove the count;https://github.com/torvalds/linux/commit/c9f01245b6a7d77d17deaa71af10f6aca14fa24e;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6429547071456909
3579;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.7359648942947388
3580;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.6722369194030762
3581;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.7199608683586121
3582;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;Contradicts;0.5351384282112122
3583;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Contradicts;0.8444843888282776
3584;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.807958722114563
3585;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7126749157905579
3586;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6589897274971008
3587;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9761455059051514
3588;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5957333445549011
3589;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7429420351982117
3590;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.5665035843849182
3591;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6739919781684875
3592;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7591970562934875
3593;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.6191065907478333
3594;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.6177533864974976
3595;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.6450079083442688
3596;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5073907375335693
3597;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5606124401092529
3598;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7283199429512024
3599;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.7351700663566589
3600;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6423326730728149
3601;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.657584011554718
3602;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.8995609283447266
3603;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5652588605880737
3604;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5847598910331726
3605;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5942689776420593
3606;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6337133049964905
3607;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6407548189163208
3608;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5008595585823059
3609;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.841651976108551
3610;Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;https://github.com/torvalds/linux/commit/c027a474a68065391c8773f6e83ed5412657e369;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5591874718666077
3611;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;https://github.com/torvalds/linux/commit/e1e12d2f3104be886073ac6c5c4678f30b1b9e51;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.6475639343261719
3612;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;https://github.com/torvalds/linux/commit/e1e12d2f3104be886073ac6c5c4678f30b1b9e51;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7804563045501709
3613;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;https://github.com/torvalds/linux/commit/e1e12d2f3104be886073ac6c5c4678f30b1b9e51;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.745728075504303
3614;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;https://github.com/torvalds/linux/commit/e1e12d2f3104be886073ac6c5c4678f30b1b9e51;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7793964147567749
3615;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;https://github.com/torvalds/linux/commit/e1e12d2f3104be886073ac6c5c4678f30b1b9e51;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6163466572761536
3616;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;https://github.com/torvalds/linux/commit/e1e12d2f3104be886073ac6c5c4678f30b1b9e51;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.93052339553833
3617;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;https://github.com/torvalds/linux/commit/e1e12d2f3104be886073ac6c5c4678f30b1b9e51;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5425858497619629
3618;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;https://github.com/torvalds/linux/commit/e1e12d2f3104be886073ac6c5c4678f30b1b9e51;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.5688924193382263
3619;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;https://github.com/torvalds/linux/commit/e1e12d2f3104be886073ac6c5c4678f30b1b9e51;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6564549207687378
3620;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;https://github.com/torvalds/linux/commit/e1e12d2f3104be886073ac6c5c4678f30b1b9e51;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5867959856987
3621;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;https://github.com/torvalds/linux/commit/e1e12d2f3104be886073ac6c5c4678f30b1b9e51;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5341497659683228
3622;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;https://github.com/torvalds/linux/commit/e1e12d2f3104be886073ac6c5c4678f30b1b9e51;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6958598494529724
3623;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;https://github.com/torvalds/linux/commit/e1e12d2f3104be886073ac6c5c4678f30b1b9e51;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6545002460479736
3624;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;https://github.com/torvalds/linux/commit/e1e12d2f3104be886073ac6c5c4678f30b1b9e51;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8110011219978333
3625;The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;https://github.com/torvalds/linux/commit/a9c58b907dbc6821533dfc295b63caf111ff1f16;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5605404376983643
3626;The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;https://github.com/torvalds/linux/commit/a9c58b907dbc6821533dfc295b63caf111ff1f16;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6802580952644348
3627;The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;https://github.com/torvalds/linux/commit/a9c58b907dbc6821533dfc295b63caf111ff1f16;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7629819512367249
3628;The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;https://github.com/torvalds/linux/commit/a9c58b907dbc6821533dfc295b63caf111ff1f16;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5690624117851257
3629;The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;https://github.com/torvalds/linux/commit/a9c58b907dbc6821533dfc295b63caf111ff1f16;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5571187734603882
3630;The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;https://github.com/torvalds/linux/commit/a9c58b907dbc6821533dfc295b63caf111ff1f16;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.7798328399658203
3631;The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;https://github.com/torvalds/linux/commit/a9c58b907dbc6821533dfc295b63caf111ff1f16;cap_safe_nice() only ever saw current, so now uses capable();only ever saw current, capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.6143812537193298
3632;The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;https://github.com/torvalds/linux/commit/a9c58b907dbc6821533dfc295b63caf111ff1f16;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.532307505607605
3633;The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;https://github.com/torvalds/linux/commit/a9c58b907dbc6821533dfc295b63caf111ff1f16;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5065189599990845
3634;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;allocate, detach its mm, and free the memory it represents;quickly;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Contradicts;0.9028419852256776
3635;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.8547713160514832
3636;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;Contradicts;0.7740809917449951
3637;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;Contradicts;0.6828441023826599
3638;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.7621335983276367
3639;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.5130075216293335
3640;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Contradicts;0.5159782767295837
3641;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.6273773908615112
3642;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.6013228893280029
3643;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5892424583435059
3644;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.5332570672035217
3645;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.7051929235458374
3646;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.6490573287010193
3647;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9063417315483092
3648;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.5238660573959351
3649;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6872941255569458
3650;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5191815495491028
3651;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.8563849925994873
3652;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9884184002876282
3653;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.8336107730865479
3654;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.8572350144386292
3655;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.824122428894043
3656;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;uid==0 makes processes only on the host more important;even without any capabilities;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.5821717977523804
3657;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;start isolating the tons of warnings;cannot be sent right now as this leads to tons of warnings;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;Contradicts;0.5191280245780945
3658;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.6534616947174072
3659;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Contradicts;0.5988835692405701
3660;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.5693575739860535
3661;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.5463831424713135
3662;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.6421647667884827
3663;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.629002571105957
3664;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.687940239906311
3665;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7194991707801819
3666;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.56734299659729
3667;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;out_of_memory() locking fix;locking fix;https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5048478841781616
3668;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5378534197807312
3669;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6625470519065857
3670;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.9203295707702636
3671;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5590218901634216
3672;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;https://github.com/torvalds/linux/commit/4d4048be8a93769350efa31d2482a038b7de73d0;Contradicts;0.5007657408714294
3673;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.6426060795783997
3674;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8028705716133118
3675;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6934463977813721
3676;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.8905782699584961
3677;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.9206064343452454
3678;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.8397101759910583
3679;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6712058782577515
3680;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5414403676986694
3681;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5220597386360168
3682;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.5379617810249329
3683;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6280688047409058
3684;allocate, detach its mm, and free the memory it represents;quickly;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.6433935165405273
3685;allocate, detach its mm, and free the memory it represents;quickly;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6224119067192078
3686;allocate, detach its mm, and free the memory it represents;quickly;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5469393134117126
3687;allocate, detach its mm, and free the memory it represents;quickly;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.746782124042511
3688;allocate, detach its mm, and free the memory it represents;quickly;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.945212185382843
3689;allocate, detach its mm, and free the memory it represents;quickly;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6663524508476257
3690;allocate, detach its mm, and free the memory it represents;quickly;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5723806619644165
3691;allocate, detach its mm, and free the memory it represents;quickly;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6179019808769226
3692;allocate, detach its mm, and free the memory it represents;quickly;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7600352168083191
3693;allocate, detach its mm, and free the memory it represents;quickly;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.639944851398468
3694;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.6589285731315613
3695;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.6678674817085266
3696;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.657692551612854
3697;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Contradicts;0.6701487302780151
3698;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.6966357231140137
3699;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9276539087295532
3700;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8154862523078918
3701;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7849195599555969
3702;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7575545907020569
3703;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Contradicts;0.5043202042579651
3704;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.984666347503662
3705;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5856366157531738
3706;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5518184304237366
3707;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7781278491020203
3708;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6114633083343506
3709;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.890486478805542
3710;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.5526255369186401
3711;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.8557661175727844
3712;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.8796415328979492
3713;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8740755319595337
3714;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6871041655540466
3715;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.7093583345413208
3716;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5504494309425354
3717;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.502869725227356
3718;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7251726984977722
3719;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;The oom killer does not want to defer in this case;there is no guarantee that thread will ever exit without intervention;https://github.com/torvalds/linux/commit/edd45544c6f09550df0a5491aa8a07af24767e73;Contradicts;0.5468683838844299
3720;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5309227705001831
3721;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7587316632270813
3722;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5357070565223694
3723;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;https://github.com/torvalds/linux/commit/9ff4868e3051d9128a24dd330bed32011a11421d;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6041600704193115
3724;remove deprecated oom_adj;deprecated;https://github.com/torvalds/linux/commit/01dc52ebdf472f77cca623ca693ca24cfc0f1bbe;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5404608249664307
3725;remove deprecated oom_adj;deprecated;https://github.com/torvalds/linux/commit/01dc52ebdf472f77cca623ca693ca24cfc0f1bbe;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.6323593258857727
3726;remove deprecated oom_adj;deprecated;https://github.com/torvalds/linux/commit/01dc52ebdf472f77cca623ca693ca24cfc0f1bbe;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5058544278144836
3727;remove deprecated oom_adj;deprecated;https://github.com/torvalds/linux/commit/01dc52ebdf472f77cca623ca693ca24cfc0f1bbe;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8022767901420593
3728;remove deprecated oom_adj;deprecated;https://github.com/torvalds/linux/commit/01dc52ebdf472f77cca623ca693ca24cfc0f1bbe;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9342368245124816
3729;remove deprecated oom_adj;deprecated;https://github.com/torvalds/linux/commit/01dc52ebdf472f77cca623ca693ca24cfc0f1bbe;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.5195151567459106
3730;remove deprecated oom_adj;deprecated;https://github.com/torvalds/linux/commit/01dc52ebdf472f77cca623ca693ca24cfc0f1bbe;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5378304123878479
3731;remove deprecated oom_adj;deprecated;https://github.com/torvalds/linux/commit/01dc52ebdf472f77cca623ca693ca24cfc0f1bbe;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.8112828731536865
3732;remove deprecated oom_adj;deprecated;https://github.com/torvalds/linux/commit/01dc52ebdf472f77cca623ca693ca24cfc0f1bbe;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5134426355361938
3733;remove deprecated oom_adj;deprecated;https://github.com/torvalds/linux/commit/01dc52ebdf472f77cca623ca693ca24cfc0f1bbe;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6182441115379333
3734;reduce dependency on tasklist_lock;reduce dependency;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5965211391448975
3735;reduce dependency on tasklist_lock;reduce dependency;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7483513951301575
3736;reduce dependency on tasklist_lock;reduce dependency;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5121177434921265
3737;reduce dependency on tasklist_lock;reduce dependency;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5535719394683838
3738;reduce dependency on tasklist_lock;reduce dependency;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5521053075790405
3739;reduce dependency on tasklist_lock;reduce dependency;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5125042200088501
3740;try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Contradicts;0.8327532410621643
3741;try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7127930521965027
3742;try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.925212025642395
3743;try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.8374157547950745
3744;try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9486982226371764
3745;try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.6461914777755737
3746;try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7079917192459106
3747;try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7504686117172241
3748;try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.6342298984527588
3749;try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.715141236782074
3750;try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6177896857261658
3751;try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5476171970367432
3752;try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.889046311378479
3753;try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;https://github.com/torvalds/linux/commit/6b0c81b3be114a93f79bd4c5639ade5107d77c21;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6660336256027222
3754;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.5112464427947998
3755;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5577727556228638
3756;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.883795976638794
3757;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7812334299087524
3758;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5564530491828918
3759;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5756410956382751
3760;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9570054411888124
3761;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6266735196113586
3762;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7522563934326172
3763;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5185856223106384
3764;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5692733526229858
3765;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6379775404930115
3766;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6248630285263062
3767;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5991418361663818
3768;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.5542876720428467
3769;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7622607350349426
3770;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5058979392051697
3771;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;Use a single linked list;Save a word in task_struct;https://github.com/torvalds/linux/commit/29c696e1c6eceb5db6b21f0c89495fcfcd40c0eb;Contradicts;0.9543251991271972
3772;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5728386044502258
3773;Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5227494239807129
3774;significantly reduces the amount of time that it is held;isnt a complete solution to tasklist_lock starvation;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5561307072639465
3775;significantly reduces the amount of time that it is held;isnt a complete solution to tasklist_lock starvation;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7216969132423401
3776;significantly reduces the amount of time that it is held;isnt a complete solution to tasklist_lock starvation;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6773187518119812
3777;significantly reduces the amount of time that it is held;isnt a complete solution to tasklist_lock starvation;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6587674617767334
3778;significantly reduces the amount of time that it is held;isnt a complete solution to tasklist_lock starvation;https://github.com/torvalds/linux/commit/9cbb78bb314360a860a8b23723971cb6fcb54176;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5956505537033081
3779;introduce helper function to process threads during scan;to process threads during scan;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.5829880237579346
3780;introduce helper function to process threads during scan;to process threads during scan;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5990315675735474
3781;introduce helper function to process threads during scan;to process threads during scan;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5928353071212769
3782;introduce helper function to process threads during scan;to process threads during scan;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6539856791496277
3783;introduce helper function to process threads during scan;to process threads during scan;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7297499775886536
3784;introduce helper function to process threads during scan;to process threads during scan;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6789302229881287
3785;introduce helper function to process threads during scan;to process threads during scan;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.883162796497345
3786;introduce helper function to process threads during scan;to process threads during scan;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5630680322647095
3787;introduce helper function to process threads during scan;to process threads during scan;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6987146139144897
3788;introduce helper function to process threads during scan;to process threads during scan;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5221483707427979
3789;introduce helper function to process threads during scan;to process threads during scan;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5193346738815308
3790;introduce helper function to process threads during scan;to process threads during scan;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.5026684999465942
3791;introduce helper function to process threads during scan;to process threads during scan;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5340607166290283
3792;introduce helper function to process threads during scan;to process threads during scan;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.81728196144104
3793;introduce helper function to process threads during scan;to process threads during scan;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7076830863952637
3794;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.6623638868331909
3795;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5176486372947693
3796;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Contradicts;0.6108044385910034
3797;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.674645185470581
3798;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5599671602249146
3799;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.6404148936271667
3800;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Contradicts;0.5749304890632629
3801;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.523560106754303
3802;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7297549843788147
3803;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7818049788475037
3804;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.5671513676643372
3805;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5972226858139038
3806;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6771897673606873
3807;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.5196588039398193
3808;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.721515417098999
3809;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.6579865217208862
3810;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;Contradicts;0.5803120732307434
3811;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;Add comments describing oom_locks scope;describing oom_locks scope;https://github.com/torvalds/linux/commit/a195d3f5b74f3f45a6742f9063b5e95a2522b46d;Contradicts;0.5564751029014587
3812;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5194202661514282
3813;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6340555548667908
3814;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;fix vm_oom_kill_table[];ifdeffery;https://github.com/torvalds/linux/commit/a19cad0691597eb79c123b8a19a9faba5ab7d90e;Contradicts;0.615742564201355
3815;A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;https://github.com/torvalds/linux/commit/462607ecc519b197f7b5cc6b024a1c26fa6fc0ac;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5485680103302002
3816;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9029240012168884
3817;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5119901895523071
3818;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6392091512680054
3819;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9091047048568726
3820;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.8050211668014526
3821;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5670648217201233
3822;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5430726408958435
3823;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5068533420562744
3824;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6314796805381775
3825;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5835790634155273
3826;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5104355812072754
3827;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5905224680900574
3828;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5453916788101196
3829;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8442102074623108
3830;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Contradicts;0.8725528717041016
3831;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Contradicts;0.6497757434844971
3832;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.51008540391922
3833;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.5211490392684937
3834;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Contradicts;0.6025795340538025
3835;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.7385971546173096
3836;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5452070236206055
3837;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Contradicts;0.8827782273292542
3838;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.720000147819519
3839;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.8811860084533691
3840;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7292632460594177
3841;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.5760782957077026
3842;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.6347959041595459
3843;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.84554523229599
3844;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5782028436660767
3845;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.7526987195014954
3846;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7099647521972656
3847;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5983229875564575
3848;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5768146514892578
3849;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;Contradicts;0.6979023814201355
3850;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Contradicts;0.8117136359214783
3851;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9825337529182434
3852;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5175560116767883
3853;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7254975438117981
3854;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.8060263395309448
3855;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Update the comments for __oom_kill_task();to reflect the code changes;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;Contradicts;0.6107958555221558
3856;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.648761510848999
3857;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.6604548692703247
3858;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7204058766365051
3859;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.9112305641174316
3860;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.7955990433692932
3861;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.6722843647003174
3862;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;https://github.com/torvalds/linux/commit/4d4048be8a93769350efa31d2482a038b7de73d0;Contradicts;0.7382568717002869
3863;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.8745473027229309
3864;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6518640518188477
3865;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5436840653419495
3866;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6907961964607239
3867;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.5992713570594788
3868;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5055721402168274
3869;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5141240954399109
3870;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.911827802658081
3871;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6166782379150391
3872;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7101078033447266
3873;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6325741410255432
3874;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.8501766324043274
3875;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;fix vm_oom_kill_table[];ifdeffery;https://github.com/torvalds/linux/commit/a19cad0691597eb79c123b8a19a9faba5ab7d90e;Contradicts;0.5432696342468262
3876;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5139952898025513
3877;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.6931688785552979
3878;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6059575080871582
3879;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.990230143070221
3880;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5003606081008911
3881;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7750480771064758
3882;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;https://github.com/torvalds/linux/commit/121d1ba0a019e1465a53533aea133b1b0f6b442d;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5116372108459473
3883;Fix kernel-doc warnings such as;No description found for parameter id, Excess function parameter mem description in swap_cgroup_record;https://github.com/torvalds/linux/commit/dad7557eb705688040aac134efa5418b66d5ed92;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5819856524467468
3884;Fix kernel-doc warnings such as;No description found for parameter id, Excess function parameter mem description in swap_cgroup_record;https://github.com/torvalds/linux/commit/dad7557eb705688040aac134efa5418b66d5ed92;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.684350311756134
3885;Fix kernel-doc warnings such as;No description found for parameter id, Excess function parameter mem description in swap_cgroup_record;https://github.com/torvalds/linux/commit/dad7557eb705688040aac134efa5418b66d5ed92;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5161824226379395
3886;Fix this by always printing the nodemask;always printing the nodemask;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.6969436407089233
3887;Fix this by always printing the nodemask;always printing the nodemask;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8962021470069885
3888;Fix this by always printing the nodemask;always printing the nodemask;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8084036111831665
3889;Fix this by always printing the nodemask;always printing the nodemask;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5961222648620605
3890;Fix this by always printing the nodemask;always printing the nodemask;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5122395753860474
3891;Fix this by always printing the nodemask;always printing the nodemask;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9318891763687134
3892;Fix this by always printing the nodemask;always printing the nodemask;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5129960179328918
3893;Fix this by always printing the nodemask;always printing the nodemask;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.647034764289856
3894;Fix this by always printing the nodemask;always printing the nodemask;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8792531490325928
3895;Fix this by always printing the nodemask;always printing the nodemask;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5597519278526306
3896;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.550758421421051
3897;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5207027196884155
3898;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6845607161521912
3899;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7213392853736877
3900;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.572543740272522
3901;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.6114174127578735
3902;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5855844616889954
3903;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.7989359498023987
3904;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.5965059399604797
3905;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;https://github.com/torvalds/linux/commit/82e7d3abec86cba9df945a765bba384f8ac113a7;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5319675207138062
3906;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Contradicts;0.7131438255310059
3907;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5403655171394348
3908;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7490621209144592
3909;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.6919412612915039
3910;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5163939595222473
3911;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7482239007949829
3912;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6462866067886353
3913;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.6026049256324768
3914;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;https://github.com/torvalds/linux/commit/9254990fb9f0f15f25605748da20cfbeced7c816;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6542326807975769
3915;allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;https://github.com/torvalds/linux/commit/1b51e65eab64fac72cab009691e8ca9915624876;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7771390080451965
3916;allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;https://github.com/torvalds/linux/commit/1b51e65eab64fac72cab009691e8ca9915624876;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5315160155296326
3917;allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;https://github.com/torvalds/linux/commit/1b51e65eab64fac72cab009691e8ca9915624876;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5913876891136169
3918;allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;https://github.com/torvalds/linux/commit/1b51e65eab64fac72cab009691e8ca9915624876;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.868908703327179
3919;allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;https://github.com/torvalds/linux/commit/1b51e65eab64fac72cab009691e8ca9915624876;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.8707452416419983
3920;allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;https://github.com/torvalds/linux/commit/1b51e65eab64fac72cab009691e8ca9915624876;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6938889026641846
3921;allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;https://github.com/torvalds/linux/commit/1b51e65eab64fac72cab009691e8ca9915624876;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7401148080825806
3922;allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;https://github.com/torvalds/linux/commit/1b51e65eab64fac72cab009691e8ca9915624876;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6802745461463928
3923;allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;https://github.com/torvalds/linux/commit/1b51e65eab64fac72cab009691e8ca9915624876;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.9798327684402466
3924;allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;https://github.com/torvalds/linux/commit/1b51e65eab64fac72cab009691e8ca9915624876;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6275982856750488
3925;allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;https://github.com/torvalds/linux/commit/1b51e65eab64fac72cab009691e8ca9915624876;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5003210306167603
3926;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Contradicts;0.5427297949790955
3927;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.7568318843841553
3928;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9199142456054688
3929;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5032116174697876
3930;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5191042423248291
3931;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6099708080291748
3932;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9050251841545104
3933;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7120146751403809
3934;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7641122341156006
3935;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.6057829260826111
3936;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;cleanup pagefault oom handler;mm, oom;https://github.com/torvalds/linux/commit/efacd02e4f57d94e934ba5c84f10f8ce91158770;Contradicts;0.5253046751022339
3937;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7215266227722168
3938;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6869783997535706
3939;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.6371322274208069
3940;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6873222589492798
3941;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6594952344894409
3942;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Contradicts;0.5020172595977783
3943;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Contradicts;0.6288405656814575
3944;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;Contradicts;0.5096378326416016
3945;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5839381814002991
3946;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5691318511962891
3947;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7725408673286438
3948;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8945816159248352
3949;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.772262454032898
3950;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6055078506469727
3951;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8382400274276733
3952;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5211742520332336
3953;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Contradicts;0.6642857193946838
3954;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.8689100742340088
3955;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7993800640106201
3956;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8160585761070251
3957;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.56059330701828
3958;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5539446473121643
3959;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8430249094963074
3960;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.8384998440742493
3961;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6413793563842773
3962;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5014554262161255
3963;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7582312226295471
3964;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7276320457458496
3965;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5450359582901001
3966;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5850288271903992
3967;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6328520774841309
3968;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8234907388687134
3969;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;"This is identical to the global oom killer and is done even before checking for panic_on_oom: a pending SIGKILL here while panic_on_oom is selected is guaranteed to have come from userspace; the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory.";the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.7505187392234802
3970;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5227041840553284
3971;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8081703782081604
3972;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5068825483322144
3973;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5512441992759705
3974;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7068694233894348
3975;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.549795389175415
3976;SIGBUS is triggered;the flag is set;https://github.com/torvalds/linux/commit/3f70dc38cec2ad6e5355f80c4c7a15a3f7e97a19;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7693604230880737
3977;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5180768370628357
3978;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7185654640197754
3979;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9337302446365356
3980;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7679484486579895
3981;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.8834249973297119
3982;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6323966979980469
3983;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5046625733375549
3984;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.5203786492347717
3985;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.5506134629249573
3986;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5215505361557007
3987;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5337939858436584
3988;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.610850989818573
3989;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5934737324714661
3990;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;https://github.com/torvalds/linux/commit/38531201c12144cd7d96abfdfe7449c2b01375e8;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5506815910339355
3991;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Contradicts;0.9882718920707704
3992;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.502769410610199
3993;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5793668627738953
3994;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9197731614112854
3995;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6296526789665222
3996;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5535616874694824
3997;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.752579927444458
3998;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6198192238807678
3999;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.594601035118103
4000;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.6699615716934204
4001;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5585491061210632
4002;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6568687558174133
4003;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6035532355308533
4004;Lets get rid of the signal_struct counter;We do not need it anymore;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.9594812393188475
4005;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.6327882409095764
4006;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9370751976966858
4007;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6788188219070435
4008;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5872774124145508
4009;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9803080558776855
4010;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7571718692779541
4011;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.5186936855316162
4012;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5947104692459106
4013;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5063329339027405
4014;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;renaming;doesnt bring any functional change;https://github.com/torvalds/linux/commit/bbec2e15170aae3e084d7d9afc730aeebe01b654;Contradicts;0.5362880229949951
4015;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.645839512348175
4016;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5198085308074951
4017;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;https://github.com/torvalds/linux/commit/862e3073b3eed13f17bd6be6ca6052db15c0b728;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5657662749290466
4018;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Contradicts;0.6695975065231323
4019;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.6265228390693665
4020;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5646466016769409
4021;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Contradicts;0.6041920185089111
4022;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5758843421936035
4023;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9292899966239928
4024;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;Contradicts;0.6146278381347656
4025;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5118983387947083
4026;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5439144968986511
4027;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5435103178024292
4028;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7282438278198242
4029;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.935390055179596
4030;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.7405874133110046
4031;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.674822986125946
4032;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.7025013566017151
4033;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5257610082626343
4034;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Update the comments for __oom_kill_task();to reflect the code changes;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;Contradicts;0.7084851861000061
4035;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.6555936336517334
4036;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.5588003396987915
4037;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.5127232670783997
4038;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7069990634918213
4039;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.867387056350708
4040;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6639221906661987
4041;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5355348587036133
4042;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;https://github.com/torvalds/linux/commit/dd0fc66fb33cd610bc1a5db8a5e232d34879b4d7;Contradicts;0.5469403862953186
4043;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;https://github.com/torvalds/linux/commit/4d4048be8a93769350efa31d2482a038b7de73d0;Contradicts;0.5059986114501953
4044;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.628734290599823
4045;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;convert it to atomic_long_t;to avoid races;https://github.com/torvalds/linux/commit/e1f56c89b040134add93f686931cc266541d239a;Contradicts;0.6313672065734863
4046;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8938072323799133
4047;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7390981912612915
4048;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6743661165237427
4049;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.9157922267913818
4050;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.9854045510292052
4051;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5232042074203491
4052;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;fix vm_oom_kill_table[];ifdeffery;https://github.com/torvalds/linux/commit/a19cad0691597eb79c123b8a19a9faba5ab7d90e;Contradicts;0.5839646458625793
4053;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.6416255831718445
4054;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5050685405731201
4055;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.655464231967926
4056;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.6453804969787598
4057;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5261169672012329
4058;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5459252595901489
4059;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.5085391998291016
4060;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6204642057418823
4061;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.8811838030815125
4062;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9272308945655824
4063;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7128757834434509
4064;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5872127413749695
4065;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.543910026550293
4066;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5603393316268921
4067;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5333170890808105
4068;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5252545475959778
4069;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Reduce the ballast;Doesnt provide any relevant information;https://github.com/torvalds/linux/commit/974f4367dd315acc15ad4a6453f8304aea60dfbd;Contradicts;0.5559138655662537
4070;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5554446578025818
4071;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5458763241767883
4072;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;https://github.com/torvalds/linux/commit/26db62f179d112d345031e14926a4cda9cd40d6e;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7743604183197021
4073;do not attempt to reap a task twice;do not attempt to reap a task twice;https://github.com/torvalds/linux/commit/8496afaba93ece80a83cbd096f0675a1020ddfc4;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.584123969078064
4074;do not attempt to reap a task twice;do not attempt to reap a task twice;https://github.com/torvalds/linux/commit/8496afaba93ece80a83cbd096f0675a1020ddfc4;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7607498168945312
4075;do not attempt to reap a task twice;do not attempt to reap a task twice;https://github.com/torvalds/linux/commit/8496afaba93ece80a83cbd096f0675a1020ddfc4;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.8398168683052063
4076;do not attempt to reap a task twice;do not attempt to reap a task twice;https://github.com/torvalds/linux/commit/8496afaba93ece80a83cbd096f0675a1020ddfc4;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7098506689071655
4077;do not attempt to reap a task twice;do not attempt to reap a task twice;https://github.com/torvalds/linux/commit/8496afaba93ece80a83cbd096f0675a1020ddfc4;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5071256160736084
4078;do not attempt to reap a task twice;do not attempt to reap a task twice;https://github.com/torvalds/linux/commit/8496afaba93ece80a83cbd096f0675a1020ddfc4;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6005922555923462
4079;reduce find_lock_task_mm() usage;mm, oom_reaper;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7662755250930786
4080;reduce find_lock_task_mm() usage;mm, oom_reaper;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.645807147026062
4081;reduce find_lock_task_mm() usage;mm, oom_reaper;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5113298892974854
4082;reduce find_lock_task_mm() usage;mm, oom_reaper;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8008835911750793
4083;reduce find_lock_task_mm() usage;mm, oom_reaper;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5244621634483337
4084;reduce find_lock_task_mm() usage;mm, oom_reaper;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5026322603225708
4085;reduce find_lock_task_mm() usage;mm, oom_reaper;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6273326873779297
4086;reduce find_lock_task_mm() usage;mm, oom_reaper;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5512950420379639
4087;reduce find_lock_task_mm() usage;mm, oom_reaper;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5039183497428894
4088;reduce find_lock_task_mm() usage;mm, oom_reaper;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6153948307037354
4089;reduce find_lock_task_mm() usage;mm, oom_reaper;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5001811981201172
4090;reduce find_lock_task_mm() usage;mm, oom_reaper;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5997586250305176
4091;reduce find_lock_task_mm() usage;mm, oom_reaper;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.6148013472557068
4092;reduce find_lock_task_mm() usage;mm, oom_reaper;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7711054086685181
4093;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5052996873855591
4094;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6606261134147644
4095;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5157099962234497
4096;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.951196312904358
4097;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5044780373573303
4098;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;https://github.com/torvalds/linux/commit/1b578df02207a67a29e8ced4db3b36d89df52fef;Contradicts;0.5376254916191101
4099;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.508769154548645
4100;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6604300737380981
4101;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5567421913146973
4102;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5328401327133179
4103;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.9262938499450684
4104;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7508293390274048
4105;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.5039756298065186
4106;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5432441830635071
4107;Pinning mms mm_count for longer time;not really harmful because this will not pin much memory;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.585616946220398
4108;Pinning mms mm_count for longer time;not really harmful because this will not pin much memory;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7324498295783997
4109;Pinning mms mm_count for longer time;not really harmful because this will not pin much memory;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5539106130599976
4110;Pinning mms mm_count for longer time;not really harmful because this will not pin much memory;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5389209389686584
4111;Pinning mms mm_count for longer time;not really harmful because this will not pin much memory;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6689977645874023
4112;Pinning mms mm_count for longer time;not really harmful because this will not pin much memory;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7244194149971008
4113;Pinning mms mm_count for longer time;not really harmful because this will not pin much memory;https://github.com/torvalds/linux/commit/7ebffa45551fe7db86a2b32bf586f124ef484e6e;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5756723880767822
4114;contstrained_alloc() should get memory_less_node into count;memory_less_node into count;https://github.com/torvalds/linux/commit/96ac5913f4e45c6a1b98350f2c0a8bb3abe2646a;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.8574230670928955
4115;contstrained_alloc() should get memory_less_node into count;memory_less_node into count;https://github.com/torvalds/linux/commit/96ac5913f4e45c6a1b98350f2c0a8bb3abe2646a;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5226054191589355
4116;contstrained_alloc() should get memory_less_node into count;memory_less_node into count;https://github.com/torvalds/linux/commit/96ac5913f4e45c6a1b98350f2c0a8bb3abe2646a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.865246057510376
4117;contstrained_alloc() should get memory_less_node into count;memory_less_node into count;https://github.com/torvalds/linux/commit/96ac5913f4e45c6a1b98350f2c0a8bb3abe2646a;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.8609543442726135
4118;contstrained_alloc() should get memory_less_node into count;memory_less_node into count;https://github.com/torvalds/linux/commit/96ac5913f4e45c6a1b98350f2c0a8bb3abe2646a;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6007897853851318
4119;contstrained_alloc() should get memory_less_node into count;memory_less_node into count;https://github.com/torvalds/linux/commit/96ac5913f4e45c6a1b98350f2c0a8bb3abe2646a;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6851568222045898
4120;contstrained_alloc() should get memory_less_node into count;memory_less_node into count;https://github.com/torvalds/linux/commit/96ac5913f4e45c6a1b98350f2c0a8bb3abe2646a;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5585188865661621
4121;contstrained_alloc() should get memory_less_node into count;memory_less_node into count;https://github.com/torvalds/linux/commit/96ac5913f4e45c6a1b98350f2c0a8bb3abe2646a;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7472317218780518
4122;contstrained_alloc() should get memory_less_node into count;memory_less_node into count;https://github.com/torvalds/linux/commit/96ac5913f4e45c6a1b98350f2c0a8bb3abe2646a;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5758309960365295
4123;contstrained_alloc() should get memory_less_node into count;memory_less_node into count;https://github.com/torvalds/linux/commit/96ac5913f4e45c6a1b98350f2c0a8bb3abe2646a;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5482997894287109
4124;contstrained_alloc() should get memory_less_node into count;memory_less_node into count;https://github.com/torvalds/linux/commit/96ac5913f4e45c6a1b98350f2c0a8bb3abe2646a;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5081230401992798
4125;fix it;fix;https://github.com/torvalds/linux/commit/96ac5913f4e45c6a1b98350f2c0a8bb3abe2646a;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7988623380661011
4126;fix it;fix;https://github.com/torvalds/linux/commit/96ac5913f4e45c6a1b98350f2c0a8bb3abe2646a;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6422252655029297
4127;fix it;fix;https://github.com/torvalds/linux/commit/96ac5913f4e45c6a1b98350f2c0a8bb3abe2646a;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5355122685432434
4128;fix it;fix;https://github.com/torvalds/linux/commit/96ac5913f4e45c6a1b98350f2c0a8bb3abe2646a;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5620843172073364
4129;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Contradicts;0.991957187652588
4130;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5284912586212158
4131;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5139471888542175
4132;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5951128005981445
4133;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8002191781997681
4134;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.8815904259681702
4135;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6496953964233398
4136;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6319749355316162
4137;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5790877938270569
4138;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.6913632154464722
4139;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6441054940223694
4140;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.6352129578590393
4141;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.8595566749572754
4142;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.540523111820221
4143;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.879103422164917
4144;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6622500419616699
4145;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.918355405330658
4146;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5407441258430481
4147;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5633687376976013
4148;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5863485336303711
4149;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5599266886711121
4150;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6516577005386353
4151;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7818620204925537
4152;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6012685894966125
4153;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7070865035057068
4154;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8222130537033081
4155;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.5436522960662842
4156;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.5429074764251709
4157;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7664762139320374
4158;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7545856833457947
4159;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9566550850868224
4160;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5467479825019836
4161;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.7681849598884583
4162;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.801139235496521
4163;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5820996165275574
4164;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5666971206665039
4165;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6135310530662537
4166;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6193994283676147
4167;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5934773087501526
4168;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5642111897468567
4169;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6699581742286682
4170;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5936477780342102
4171;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;This fix has considerable negative impact on process_mrelease performance;will likely need later optimization;https://github.com/torvalds/linux/commit/337546e83fc7e50917f44846beee936abb9c9f1f;Contradicts;0.6922182440757751
4172;It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6481974720954895
4173;reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Contradicts;0.503558337688446
4174;reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8285534381866455
4175;reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6364544630050659
4176;reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5769562721252441
4177;reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9665529727935792
4178;reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6796018481254578
4179;reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7635550498962402
4180;reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.7297554016113281
4181;reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5554019808769226
4182;reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5107031464576721
4183;reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5011143088340759
4184;reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6719883680343628
4185;reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;https://github.com/torvalds/linux/commit/02a0e53d8227aff5e62e0433f82c12c1c2805fd6;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5748873353004456
4186;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5596240758895874
4187;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5458516478538513
4188;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7896595597267151
4189;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.900128960609436
4190;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.6407207250595093
4191;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6551230549812317
4192;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7544496059417725
4193;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5659502148628235
4194;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5773752927780151
4195;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5877372622489929
4196;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.8655503988265991
4197;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.7517569065093994
4198;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.8471556305885315
4199;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;https://github.com/torvalds/linux/commit/f2a2a7108aa0039ba7a5fe7a0d2ecef2219a7584;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5894993543624878
4200;cleanup messages;oom;https://github.com/torvalds/linux/commit/f3af38d30c18538d069a95e624a3db7c3d486a1e;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5478296875953674
4201;cleanup messages;oom;https://github.com/torvalds/linux/commit/f3af38d30c18538d069a95e624a3db7c3d486a1e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9621453881263732
4202;cleanup messages;oom;https://github.com/torvalds/linux/commit/f3af38d30c18538d069a95e624a3db7c3d486a1e;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5850788354873657
4203;Clean up the OOM killer messages;to be more consistent;https://github.com/torvalds/linux/commit/f3af38d30c18538d069a95e624a3db7c3d486a1e;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.8109414577484131
4204;Clean up the OOM killer messages;to be more consistent;https://github.com/torvalds/linux/commit/f3af38d30c18538d069a95e624a3db7c3d486a1e;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8049418926239014
4205;Clean up the OOM killer messages;to be more consistent;https://github.com/torvalds/linux/commit/f3af38d30c18538d069a95e624a3db7c3d486a1e;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.548965334892273
4206;Clean up the OOM killer messages;to be more consistent;https://github.com/torvalds/linux/commit/f3af38d30c18538d069a95e624a3db7c3d486a1e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.919236421585083
4207;Clean up the OOM killer messages;to be more consistent;https://github.com/torvalds/linux/commit/f3af38d30c18538d069a95e624a3db7c3d486a1e;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6516540050506592
4208;Clean up the OOM killer messages;to be more consistent;https://github.com/torvalds/linux/commit/f3af38d30c18538d069a95e624a3db7c3d486a1e;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6490508913993835
4209;Clean up the OOM killer messages;to be more consistent;https://github.com/torvalds/linux/commit/f3af38d30c18538d069a95e624a3db7c3d486a1e;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.6347160935401917
4210;Clean up the OOM killer messages;to be more consistent;https://github.com/torvalds/linux/commit/f3af38d30c18538d069a95e624a3db7c3d486a1e;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.553360104560852
4211;Clean up the OOM killer messages;to be more consistent;https://github.com/torvalds/linux/commit/f3af38d30c18538d069a95e624a3db7c3d486a1e;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5745877027511597
4212;Clean up the OOM killer messages;to be more consistent;https://github.com/torvalds/linux/commit/f3af38d30c18538d069a95e624a3db7c3d486a1e;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.537818968296051
4213;Having this test here;"prevents any OOM_DISABLE child of the ""selected"" process from being killed.";https://github.com/torvalds/linux/commit/c33e0fca3508f0aa387b1c10d0ef158102deb140;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.712424099445343
4214;Having this test here;"prevents any OOM_DISABLE child of the ""selected"" process from being killed.";https://github.com/torvalds/linux/commit/c33e0fca3508f0aa387b1c10d0ef158102deb140;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6818066239356995
4215;Having this test here;"prevents any OOM_DISABLE child of the ""selected"" process from being killed.";https://github.com/torvalds/linux/commit/c33e0fca3508f0aa387b1c10d0ef158102deb140;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6292150616645813
4216;Having this test here;"prevents any OOM_DISABLE child of the ""selected"" process from being killed.";https://github.com/torvalds/linux/commit/c33e0fca3508f0aa387b1c10d0ef158102deb140;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5174421668052673
4217;Having this test here;"prevents any OOM_DISABLE child of the ""selected"" process from being killed.";https://github.com/torvalds/linux/commit/c33e0fca3508f0aa387b1c10d0ef158102deb140;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.548581600189209
4218;Having this test here;"prevents any OOM_DISABLE child of the ""selected"" process from being killed.";https://github.com/torvalds/linux/commit/c33e0fca3508f0aa387b1c10d0ef158102deb140;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.533811092376709
4219;Having this test here;"prevents any OOM_DISABLE child of the ""selected"" process from being killed.";https://github.com/torvalds/linux/commit/c33e0fca3508f0aa387b1c10d0ef158102deb140;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6653997898101807
4220;No logic changes, but imho easier to read.;easier to read;https://github.com/torvalds/linux/commit/972c4ea59c9dbf82647ee9665d9e945241911a51;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Contradicts;0.5407907366752625
4221;No logic changes, but imho easier to read.;easier to read;https://github.com/torvalds/linux/commit/972c4ea59c9dbf82647ee9665d9e945241911a51;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.8050049543380737
4222;No logic changes, but imho easier to read.;easier to read;https://github.com/torvalds/linux/commit/972c4ea59c9dbf82647ee9665d9e945241911a51;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5846187472343445
4223;No logic changes, but imho easier to read.;easier to read;https://github.com/torvalds/linux/commit/972c4ea59c9dbf82647ee9665d9e945241911a51;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5795760154724121
4224;No logic changes, but imho easier to read.;easier to read;https://github.com/torvalds/linux/commit/972c4ea59c9dbf82647ee9665d9e945241911a51;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5802738666534424
4225;No logic changes, but imho easier to read.;easier to read;https://github.com/torvalds/linux/commit/972c4ea59c9dbf82647ee9665d9e945241911a51;modify implementation of per-mm counter;reducing patch size in future patch;https://github.com/torvalds/linux/commit/d559db086ff5be9bcc259e5aa50bf3d881eaf1d1;Contradicts;0.6284811496734619
4226;No logic changes, but imho easier to read.;easier to read;https://github.com/torvalds/linux/commit/972c4ea59c9dbf82647ee9665d9e945241911a51;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5257431268692017
4227;No logic changes, but imho easier to read.;easier to read;https://github.com/torvalds/linux/commit/972c4ea59c9dbf82647ee9665d9e945241911a51;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.5512372255325317
4228;No logic changes, but imho easier to read.;easier to read;https://github.com/torvalds/linux/commit/972c4ea59c9dbf82647ee9665d9e945241911a51;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5550640225410461
4229;No logic changes, but imho easier to read.;easier to read;https://github.com/torvalds/linux/commit/972c4ea59c9dbf82647ee9665d9e945241911a51;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5218209028244019
4230;No logic changes, but imho easier to read.;easier to read;https://github.com/torvalds/linux/commit/972c4ea59c9dbf82647ee9665d9e945241911a51;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.7905956506729126
4231;No logic changes, but imho easier to read.;easier to read;https://github.com/torvalds/linux/commit/972c4ea59c9dbf82647ee9665d9e945241911a51;This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;https://github.com/torvalds/linux/commit/1da4db0cd5c8a31d4468ec906b413e75e604b465;Contradicts;0.8428087830543518
4232;No logic changes, but imho easier to read.;easier to read;https://github.com/torvalds/linux/commit/972c4ea59c9dbf82647ee9665d9e945241911a51;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6143154501914978
4233;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Contradicts;0.5299261212348938
4234;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Contradicts;0.5990453958511353
4235;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.537182629108429
4236;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.6197957992553711
4237;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.6093174815177917
4238;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Contradicts;0.569444477558136
4239;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.955142080783844
4240;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5302442908287048
4241;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5041422247886658
4242;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8061781525611877
4243;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.7530766129493713
4244;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5499008893966675
4245;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8196380138397217
4246;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.6915113925933838
4247;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5020421147346497
4248;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5063008666038513
4249;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6852680444717407
4250;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7459281086921692
4251;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5826604962348938
4252;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5086144208908081
4253;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;https://github.com/torvalds/linux/commit/28324d1df646521256e83389244adcce98e89ff2;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.8911424279212952
4254;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.8817698359489441
4255;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6854056715965271
4256;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7298202514648438
4257;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.5615840554237366
4258;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5503127574920654
4259;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.5051999688148499
4260;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5897783041000366
4261;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7867224812507629
4262;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5069937109947205
4263;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5129187703132629
4264;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.5013778209686279
4265;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.505479097366333
4266;Introduce a new state, TASK_DEAD;to avoid a confusion;https://github.com/torvalds/linux/commit/c394cc9fbb367f87faa2228ec2eabacd2d4701c6;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6123571395874023
4267;removes dependency on Erics other patches for now;checks pid and thus;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5207271575927734
4268;removes dependency on Erics other patches for now;checks pid and thus;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5918041467666626
4269;removes dependency on Erics other patches for now;checks pid and thus;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6769363880157471
4270;removes dependency on Erics other patches for now;checks pid and thus;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5099189877510071
4271;removes dependency on Erics other patches for now;checks pid and thus;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5694491863250732
4272;removes dependency on Erics other patches for now;checks pid and thus;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5151785612106323
4273;removes dependency on Erics other patches for now;checks pid and thus;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.8187747597694397
4274;removes dependency on Erics other patches for now;checks pid and thus;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6152856945991516
4275;removes dependency on Erics other patches for now;checks pid and thus;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5742127299308777
4276;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.6960594654083252
4277;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.8134655952453613
4278;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5793164968490601
4279;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5042360424995422
4280;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.715067982673645
4281;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.729865550994873
4282;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6169585585594177
4283;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.6525390148162842
4284;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6003980040550232
4285;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5553635954856873
4286;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5956947207450867
4287;Introduce is_init;to capture this case;https://github.com/torvalds/linux/commit/f400e198b2ed26ce55b22a1412ded0896e7516ac;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5126960277557373
4288;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.5171726942062378
4289;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5953196287155151
4290;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.57365882396698
4291;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6038276553153992
4292;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.8149325847625732
4293;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.8034846782684326
4294;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6972779631614685
4295;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.8307834267616272
4296;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9585501551628112
4297;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.7673035860061646
4298;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.6563404202461243
4299;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5968449711799622
4300;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.5856949687004089
4301;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7924522757530212
4302;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.7834409475326538
4303;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5125625729560852
4304;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.868461012840271
4305;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.5084360241889954
4306;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6174597144126892
4307;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.7188242673873901
4308;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5534290671348572
4309;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5094708800315857
4310;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6310452222824097
4311;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.5480337142944336
4312;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.625522255897522
4313;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.7374072074890137
4314;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5861943960189819
4315;suppress extraneous stack and memory dump;oom;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8287001252174377
4316;suppress extraneous stack and memory dump;oom;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5132563710212708
4317;suppress extraneous stack and memory dump;oom;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8892505168914795
4318;suppress extraneous stack and memory dump;oom;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Contradicts;0.7221400141716003
4319;suppress extraneous stack and memory dump;oom;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5093091726303101
4320;suppress extraneous stack and memory dump;oom;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5647788047790527
4321;suppress extraneous stack and memory dump;oom;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.5534514784812927
4322;suppress extraneous stack and memory dump;oom;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6903682351112366
4323;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;Contradicts;0.690300703048706
4324;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Contradicts;0.7522196769714355
4325;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6977270841598511
4326;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5401802062988281
4327;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5672035217285156
4328;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;Contradicts;0.7388560175895691
4329;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.5243582129478455
4330;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5453153848648071
4331;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5489791035652161
4332;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;https://github.com/torvalds/linux/commit/7213f5066fc8a17c78389fe245de522b5cf0648a;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6751129627227783
4333;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.5440676212310791
4334;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.6696494817733765
4335;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7458621859550476
4336;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9679521322250366
4337;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5011283755302429
4338;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;Contradicts;0.6343704462051392
4339;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.5488482117652893
4340;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.7092506885528564
4341;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Contradicts;0.7129846811294556
4342;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6333171129226685
4343;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.758013904094696
4344;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5981682538986206
4345;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5431057810783386
4346;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6684659123420715
4347;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;Contradicts;0.5835347175598145
4348;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;https://github.com/torvalds/linux/commit/fe071d7e8aae5745c009c808bb8933f22a9e305a;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7489448189735413
4349;OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.5117890238761902
4350;OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9073941111564636
4351;OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7393638491630554
4352;OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5735278129577637
4353;OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.5319957733154297
4354;OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.714189887046814
4355;OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5381245017051697
4356;OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5075581073760986
4357;OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.6430069804191589
4358;OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5092028379440308
4359;OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5132478475570679
4360;DMA allocations can be targeted at the zone level;locking was done in nodes or globally;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.709435760974884
4361;DMA allocations can be targeted at the zone level;locking was done in nodes or globally;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7230018973350525
4362;DMA allocations can be targeted at the zone level;locking was done in nodes or globally;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5640192627906799
4363;DMA allocations can be targeted at the zone level;locking was done in nodes or globally;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7960281372070312
4364;DMA allocations can be targeted at the zone level;locking was done in nodes or globally;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5877211093902588
4365;DMA allocations can be targeted at the zone level;locking was done in nodes or globally;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6212034225463867
4366;DMA allocations can be targeted at the zone level;locking was done in nodes or globally;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5080480575561523
4367;DMA allocations can be targeted at the zone level;locking was done in nodes or globally;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7402044534683228
4368;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Contradicts;0.6255751252174377
4369;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Contradicts;0.9272918105125428
4370;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.6939378380775452
4371;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.8995264768600464
4372;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.915763795375824
4373;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8110390901565552
4374;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.9428384304046632
4375;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.75552898645401
4376;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8253986239433289
4377;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.9407508969306946
4378;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.5868710875511169
4379;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5079379081726074
4380;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7025083899497986
4381;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5355972647666931
4382;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7355982065200806
4383;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.6495684385299683
4384;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.695792555809021
4385;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.8768029808998108
4386;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5110787749290466
4387;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.932293713092804
4388;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.8505862951278687
4389;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6428095698356628
4390;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5762602686882019
4391;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6056510806083679
4392;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5906575322151184
4393;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5315343141555786
4394;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.641173779964447
4395;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.5277880430221558
4396;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.9099040031433104
4397;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6811374425888062
4398;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.957390069961548
4399;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7584184408187866
4400;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5396554470062256
4401;"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;https://github.com/torvalds/linux/commit/098d7f128a4e53cb64930628915ac767785e0e60;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.5762951374053955
4402;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.6776481866836548
4403;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Contradicts;0.6990836262702942
4404;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.5527132749557495
4405;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5589532852172852
4406;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5118221044540405
4407;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5041114091873169
4408;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8943716883659363
4409;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Contradicts;0.7138369679450989
4410;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.8745405673980713
4411;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5849298238754272
4412;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.8169260621070862
4413;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.805126428604126
4414;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6008036732673645
4415;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6100593209266663
4416;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;Reduce the ballast;Doesnt provide any relevant information;https://github.com/torvalds/linux/commit/974f4367dd315acc15ad4a6453f8304aea60dfbd;Contradicts;0.5085322260856628
4417;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6351813077926636
4418;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;https://github.com/torvalds/linux/commit/70e24bdf6d2fead14631e72a07fba012400c521e;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7266503572463989
4419;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7815544605255127
4420;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.6198974847793579
4421;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6942803859710693
4422;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6550292372703552
4423;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;Contradicts;0.5067497491836548
4424;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9769178628921508
4425;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.6058198809623718
4426;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6154743432998657
4427;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6892068386077881
4428;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.53651362657547
4429;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6615133285522461
4430;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5629997849464417
4431;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.6003602743148804
4432;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8222929835319519
4433;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6087092161178589
4434;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7001075148582458
4435;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8898430466651917
4436;Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;https://github.com/torvalds/linux/commit/4e950f6f0189f65f8bf069cf2272649ef418f5e4;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5697179436683655
4437;fix constraint deadlock;constraint deadlock;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9190106391906738
4438;fix constraint deadlock;constraint deadlock;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6602224707603455
4439;fix constraint deadlock;constraint deadlock;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5696110129356384
4440;fix constraint deadlock;constraint deadlock;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5527823567390442
4441;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.8869337439537048
4442;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.8078925013542175
4443;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8679370284080505
4444;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5832708477973938
4445;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7259930968284607
4446;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.965901792049408
4447;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.6320182085037231
4448;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.5849888324737549
4449;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7278238534927368
4450;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.800744891166687
4451;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7214032411575317
4452;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8567996025085449
4453;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.542170524597168
4454;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.571533739566803
4455;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7179189324378967
4456;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5409863591194153
4457;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6072019338607788
4458;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6164137125015259
4459;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7552908062934875
4460;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.584888219833374
4461;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Reduce the ballast;Doesnt provide any relevant information;https://github.com/torvalds/linux/commit/974f4367dd315acc15ad4a6453f8304aea60dfbd;Contradicts;0.5591618418693542
4462;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5714137554168701
4463;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5900374054908752
4464;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.608733594417572
4465;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5474749803543091
4466;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.624703049659729
4467;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.8927540183067322
4468;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.7382414937019348
4469;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9001967906951904
4470;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.502805233001709
4471;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5646160840988159
4472;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7275102734565735
4473;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7276636362075806
4474;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6737104654312134
4475;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7856796979904175
4476;We now take callback_mutex after iterating through the zonelist;we dont need it yet;https://github.com/torvalds/linux/commit/2b45ab3398a0ba119b1f672c7c56fd5a431b7f0a;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8446526527404785
4477;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9828407764434814
4478;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5005937218666077
4479;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.9327003359794616
4480;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6861703395843506
4481;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6672902703285217
4482;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.892031192779541
4483;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.8408469557762146
4484;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;Contradicts;0.7081548571586609
4485;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.8816385865211487
4486;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6312135457992554
4487;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6507152318954468
4488;panic ASAP;want failover;https://github.com/torvalds/linux/commit/2b744c01a54fe0c9974ff1b29522f25f07084053;solve in a more reasonable way;more reasonable way;https://github.com/torvalds/linux/commit/9bfe5ded054b8e28a94c78580f233d6879a00146;Contradicts;0.8104510307312012
4489;fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;https://github.com/torvalds/linux/commit/3d124cbba316737af8f3a6959edb95bbd130a4d8;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6250808835029602
4490;fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;https://github.com/torvalds/linux/commit/3d124cbba316737af8f3a6959edb95bbd130a4d8;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8498812317848206
4491;fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;https://github.com/torvalds/linux/commit/3d124cbba316737af8f3a6959edb95bbd130a4d8;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.6826434135437012
4492;fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;https://github.com/torvalds/linux/commit/3d124cbba316737af8f3a6959edb95bbd130a4d8;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8934899568557739
4493;fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;https://github.com/torvalds/linux/commit/3d124cbba316737af8f3a6959edb95bbd130a4d8;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5911049246788025
4494;fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;https://github.com/torvalds/linux/commit/3d124cbba316737af8f3a6959edb95bbd130a4d8;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7530847191810608
4495;fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;https://github.com/torvalds/linux/commit/3d124cbba316737af8f3a6959edb95bbd130a4d8;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5501209497451782
4496;fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;https://github.com/torvalds/linux/commit/3d124cbba316737af8f3a6959edb95bbd130a4d8;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5820237994194031
4497;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Contradicts;0.7484282851219177
4498;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7108407020568848
4499;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5296911597251892
4500;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.5105162262916565
4501;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;https://github.com/torvalds/linux/commit/b460cbc581a53cc088ceba80608021dd49c63c43;Contradicts;0.5211840271949768
4502;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.9527525305747986
4503;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5960904359817505
4504;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5562899112701416
4505;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.7898288369178772
4506;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;solve in a more reasonable way;more reasonable way;https://github.com/torvalds/linux/commit/9bfe5ded054b8e28a94c78580f233d6879a00146;Contradicts;0.5308693647384644
4507;kill those individual threads;When finding other threads that share an mm with that task;https://github.com/torvalds/linux/commit/650a7c974f1b91de9732c0f720e792837f8abfd6;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.7302109003067017
4508;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Contradicts;0.5857377648353577
4509;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6597001552581787
4510;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.6984719634056091
4511;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7346668243408203
4512;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5689678192138672
4513;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Contradicts;0.8536006808280945
4514;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7060832977294922
4515;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7170738577842712
4516;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5402138829231262
4517;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.553669810295105
4518;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Contradicts;0.6870342493057251
4519;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;Contradicts;0.5916024446487427
4520;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.5953255295753479
4521;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;https://github.com/torvalds/linux/commit/4d4048be8a93769350efa31d2482a038b7de73d0;Contradicts;0.5737313032150269
4522;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5046617388725281
4523;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.9714672565460204
4524;prevent oom from killing a process with children/sibling unkillable;fix oom issue;https://github.com/torvalds/linux/commit/35ae834fa02ba89cfbd4a80892c0e458fd6d5c0b;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9047002792358398
4525;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Contradicts;0.5060659050941467
4526;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9565737843513488
4527;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.7565039992332458
4528;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5185908675193787
4529;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6444469094276428
4530;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6536495685577393
4531;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.6171483397483826
4532;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.56348717212677
4533;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.5174711346626282
4534;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5690169930458069
4535;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.548409640789032
4536;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.7382956743240356
4537;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6018960475921631
4538;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5796459913253784
4539;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.551118791103363
4540;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8129935264587402
4541;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.5148571133613586
4542;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.659701943397522
4543;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5238081216812134
4544;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.9214563965797424
4545;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6359392404556274
4546;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;https://github.com/torvalds/linux/commit/7ba3485947ee7bc89a17f86250fe9b692a615dff;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.6000310182571411
4547;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5029065608978271
4548;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;Contradicts;0.7690912485122681
4549;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.5306647419929504
4550;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8585758209228516
4551;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.6332258582115173
4552;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6727114915847778
4553;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.760953426361084
4554;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.861687958240509
4555;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.8658026456832886
4556;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7361992001533508
4557;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7572029232978821
4558;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.8734068274497986
4559;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5048575401306152
4560;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.585005521774292
4561;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5763925313949585
4562;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;I added some more output;Users tend to be irritated by the choice of killed processes;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5795767903327942
4563;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.7705784440040588
4564;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;no longer get stuck on any lock;a sleeping task may hold;https://github.com/torvalds/linux/commit/3812c8c8f3953921ef18544110dafc3505c1ac62;Contradicts;0.5999427437782288
4565;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.9701785445213318
4566;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Remove the unused arguments and update all callers.;unused.;https://github.com/torvalds/linux/commit/a72afd873089c697053e9daa85ff343b3140d2e7;Contradicts;0.6131115555763245
4567;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Remove the unused arguments and update all callers.;unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;Contradicts;0.6131115555763245
4568;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5911248922348022
4569;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.915830373764038
4570;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9127612113952636
4571;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5427186489105225
4572;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5330992937088013
4573;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5416391491889954
4574;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5423405170440674
4575;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.5215598344802856
4576;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5551207065582275
4577;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.6646168828010559
4578;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.8460327982902527
4579;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;delete unlock_range();exit_mmap() does not need locked_vm updates;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.7223269939422607
4580;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.5573313236236572
4581;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;This patch fixes the problem and should be backported into stable/LTS.;Fixes the problem, should be backported into stable/LTS.;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.5449039936065674
4582;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.7706533074378967
4583;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.7838626503944397
4584;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;delete the corresponding comment;it will be checked in oom_unkillable_task();https://github.com/torvalds/linux/commit/f8159c13905bba26f3e1782a521dacf7a66fc1ce;Contradicts;0.5016524195671082
4585;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.8052206635475159
4586;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9861618280410768
4587;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.8308418393135071
4588;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.6745251417160034
4589;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.5277023911476135
4590;"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;avoid attempting to kill init sharing same memory;avoid attempting to kill init;https://github.com/torvalds/linux/commit/a2b829d95958da2025ef844c0f53ac15ad720fac;Contradicts;0.5668454766273499
4591;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5953785181045532
4592;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;Contradicts;0.535453736782074
4593;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9115613698959352
4594;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5568385124206543
4595;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5650267601013184
4596;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6050233840942383
4597;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5879271030426025
4598;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.956749677658081
4599;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6659902334213257
4600;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6500864624977112
4601;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Contradicts;0.7629875540733337
4602;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7006065845489502
4603;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8594996333122253
4604;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.5044126510620117
4605;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5192963480949402
4606;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6554628610610962
4607;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5309893488883972
4608;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8876420855522156
4609;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6754688024520874
4610;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.947385311126709
4611;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.8118586540222168
4612;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7843563556671143
4613;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6494469046592712
4614;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.7552486062049866
4615;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5116705894470215
4616;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7236315011978149
4617;Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5201984643936157
4618;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;This change ;will allow such a usecase without worrying about complete memory reserves depletion.;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7872958183288574
4619;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;Contradicts;0.7053983807563782
4620;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;Contradicts;0.582783579826355
4621;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5945507884025574
4622;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.527912437915802
4623;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7708932757377625
4624;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6230599880218506
4625;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;Contradicts;0.5687220692634583
4626;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Contradicts;0.581290602684021
4627;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.80782550573349
4628;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.7216550707817078
4629;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.5675756931304932
4630;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5778692364692688
4631;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8380677103996277
4632;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.7160366773605347
4633;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;https://github.com/torvalds/linux/commit/dd0fc66fb33cd610bc1a5db8a5e232d34879b4d7;Contradicts;0.7295548319816589
4634;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Provide more precise dump info while memcg oom happening;more precise dump info;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5658419728279114
4635;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5403664112091064
4636;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7221091389656067
4637;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.5362681746482849
4638;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Introduce two new options for madvise;To achieve the goal;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Contradicts;0.5195688009262085
4639;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.5164366960525513
4640;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7639350295066833
4641;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.8357728719711304
4642;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.8179498314857483
4643;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Add comments describing oom_locks scope;describing oom_locks scope;https://github.com/torvalds/linux/commit/a195d3f5b74f3f45a6742f9063b5e95a2522b46d;Contradicts;0.5716485381126404
4644;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Rename page_counter_limit() to page_counter_set_max();The idea behind this renaming is to have the direct matching between memory cgroup knobs (low, high, max) and page_counters API;https://github.com/torvalds/linux/commit/bbec2e15170aae3e084d7d9afc730aeebe01b654;Contradicts;0.5864126086235046
4645;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7218153476715088
4646;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.679725170135498
4647;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.6964382529258728
4648;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6595484614372253
4649;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.7459700703620911
4650;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;LSMs should use the new has_capability_noaudit() interface;The denials will not be recorded;https://github.com/torvalds/linux/commit/a2f2945a99057c7d44043465906c6bb63c3368a0;Contradicts;0.7409502863883972
4651;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.6437720060348511
4652;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.8771451115608215
4653;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Add a new flag PF_POSTCOREDUMP;so that tasks that have passed through coredump_task_exit can be recognized and ignored in zap_process;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5968448519706726
4654;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6131003499031067
4655;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5388524532318115
4656;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5197668075561523
4657;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8067148923873901
4658;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5534281134605408
4659;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5254183411598206
4660;This change ;will allow such a usecase without worrying about complete memory reserves depletion.;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7281740307807922
4661;adding some tracepoints ;might help with debugging of similar issues;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.5402010679244995
4662;adding some tracepoints ;might help with debugging of similar issues;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5199782848358154
4663;adding some tracepoints ;might help with debugging of similar issues;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6702670454978943
4664;adding some tracepoints ;might help with debugging of similar issues;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.9259649515151978
4665;adding some tracepoints ;might help with debugging of similar issues;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5372316837310791
4666;problem mentioned above can be found;How it works in practice;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8329289555549622
4667;problem mentioned above can be found;How it works in practice;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5433933138847351
4668;problem mentioned above can be found;How it works in practice;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5280259847640991
4669;problem mentioned above can be found;How it works in practice;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5560271739959717
4670;problem mentioned above can be found;How it works in practice;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.9081377983093262
4671;problem mentioned above can be found;How it works in practice;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5457764863967896
4672;problem mentioned above can be found;How it works in practice;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.8697656393051147
4673;problem mentioned above can be found;How it works in practice;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.993499517440796
4674;problem mentioned above can be found;How it works in practice;https://github.com/torvalds/linux/commit/422580c3cea7faaca67f6199375b79565d3d8ebd;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8516973853111267
4675;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.8148239850997925
4676;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6069492101669312
4677;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9504000544548036
4678;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5733970403671265
4679;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5005590915679932
4680;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6425514817237854
4681;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6781777143478394
4682;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.6857959628105164
4683;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6258501410484314
4684;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6589806079864502
4685;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5620871186256409
4686;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8264437317848206
4687;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;https://github.com/torvalds/linux/commit/d75da004c708c9fca7b53f7da293a295522414d9;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5542672276496887
4688;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Contradicts;0.6621941924095154
4689;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Contradicts;0.6136534810066223
4690;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7652854919433594
4691;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5886737704277039
4692;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8118497729301453
4693;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.8159127831459045
4694;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7618778944015503
4695;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7416938543319702
4696;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5007575154304504
4697;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6559256315231323
4698;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5343251824378967
4699;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5954364538192749
4700;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5490803718566895
4701;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6019304990768433
4702;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.7491694092750549
4703;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.8309840559959412
4704;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6014389991760254
4705;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5105273127555847
4706;Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7650669813156128
4707;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Contradicts;0.8446692228317261
4708;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7694944143295288
4709;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5818692445755005
4710;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Contradicts;0.5406328439712524
4711;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5778311491012573
4712;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7199832797050476
4713;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.5915875434875488
4714;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6730199456214905
4715;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5119633674621582
4716;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6856482625007629
4717;Include the new header in the files that are going to need it;files that are going to need it;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6172950863838196
4718;Include the new header in the files that are going to need it;files that are going to need it;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7235277891159058
4719;Include the new header in the files that are going to need it;files that are going to need it;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8094729781150818
4720;Include the new header in the files that are going to need it;files that are going to need it;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5502704381942749
4721;Include the new header in the files that are going to need it;files that are going to need it;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6650797724723816
4722;Include the new header in the files that are going to need it;files that are going to need it;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.6277185678482056
4723;Include the new header in the files that are going to need it;files that are going to need it;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5129048824310303
4724;Include the new header in the files that are going to need it;files that are going to need it;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5550417304039001
4725;Include the new header in the files that are going to need it;files that are going to need it;https://github.com/torvalds/linux/commit/f7ccbae45c5e2c1077654b0e857e7efb1aa31c92;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6981776356697083
4726;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Contradicts;0.5447337627410889
4727;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7570772171020508
4728;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8297281265258789
4729;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.8334482908248901
4730;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7665197253227234
4731;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6371564269065857
4732;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5007693767547607
4733;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5539446473121643
4734;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5314533114433289
4735;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5435172319412231
4736;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5865670442581177
4737;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5061582326889038
4738;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6078563928604126
4739;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5801995992660522
4740;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6060141324996948
4741;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7907009720802307
4742;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5129268765449524
4743;Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.789510190486908
4744;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5133962631225586
4745;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6271927952766418
4746;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7391393780708313
4747;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.5335842967033386
4748;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5774089694023132
4749;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.615979790687561
4750;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.5424882769584656
4751;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5125324726104736
4752;Include the new header in the files that are going to need it;that are going to need it;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6172950863838196
4753;Include the new header in the files that are going to need it;that are going to need it;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7235277891159058
4754;Include the new header in the files that are going to need it;that are going to need it;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8094729781150818
4755;Include the new header in the files that are going to need it;that are going to need it;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5502704381942749
4756;Include the new header in the files that are going to need it;that are going to need it;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6650797724723816
4757;Include the new header in the files that are going to need it;that are going to need it;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.6277185678482056
4758;Include the new header in the files that are going to need it;that are going to need it;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5129048824310303
4759;Include the new header in the files that are going to need it;that are going to need it;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5550417304039001
4760;Include the new header in the files that are going to need it;that are going to need it;https://github.com/torvalds/linux/commit/6e84f31522f931027bf695752087ece278c10d3f;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6981776356697083
4761;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9097524285316468
4762;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5633872747421265
4763;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.6557562351226807
4764;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;https://github.com/torvalds/linux/commit/4d4048be8a93769350efa31d2482a038b7de73d0;Contradicts;0.5286552309989929
4765;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6558552384376526
4766;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5602189898490906
4767;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6640155911445618
4768;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5500253438949585
4769;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5490533113479614
4770;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.9688856601715088
4771;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7667474150657654
4772;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.8031849265098572
4773;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.539561927318573
4774;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5451721549034119
4775;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;https://github.com/torvalds/linux/commit/235190738aba7c5c94300c8d882842a535280e5a;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5053682923316956
4776;detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;https://github.com/torvalds/linux/commit/3e8715fdc03e8df4d26d8e436166e44e3e416d3b;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7612608671188354
4777;detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;https://github.com/torvalds/linux/commit/3e8715fdc03e8df4d26d8e436166e44e3e416d3b;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8858020305633545
4778;detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;https://github.com/torvalds/linux/commit/3e8715fdc03e8df4d26d8e436166e44e3e416d3b;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5450398921966553
4779;detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;https://github.com/torvalds/linux/commit/3e8715fdc03e8df4d26d8e436166e44e3e416d3b;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8225985169410706
4780;detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;https://github.com/torvalds/linux/commit/3e8715fdc03e8df4d26d8e436166e44e3e416d3b;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5248168110847473
4781;detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;https://github.com/torvalds/linux/commit/3e8715fdc03e8df4d26d8e436166e44e3e416d3b;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6494055986404419
4782;detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;https://github.com/torvalds/linux/commit/3e8715fdc03e8df4d26d8e436166e44e3e416d3b;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6115972399711609
4783;detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;https://github.com/torvalds/linux/commit/3e8715fdc03e8df4d26d8e436166e44e3e416d3b;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7321281433105469
4784;detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;https://github.com/torvalds/linux/commit/3e8715fdc03e8df4d26d8e436166e44e3e416d3b;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.6042510271072388
4785;detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;https://github.com/torvalds/linux/commit/3e8715fdc03e8df4d26d8e436166e44e3e416d3b;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.67051762342453
4786;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.6911544799804688
4787;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5849937796592712
4788;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5041346549987793
4789;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;Contradicts;0.5512121915817261
4790;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9462817311286926
4791;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7733404040336609
4792;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5012070536613464
4793;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5347235798835754
4794;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;https://github.com/torvalds/linux/commit/06ad276ac18742c6b281698d41b27a290cd42407;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6659610271453857
4795;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9350807070732116
4796;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;It is configurable;so that large systems, such as those with several thousand tasks, do not incur a performance penalty associated with dumping data they may not desire;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;Contradicts;0.6441469192504883
4797;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5787209868431091
4798;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5215204358100891
4799;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.7925639152526855
4800;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5031330585479736
4801;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;https://github.com/torvalds/linux/commit/9af744d743170b5f5ef70031dea8d772d166ab28;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6505547165870667
4802;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7527368664741516
4803;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5455070734024048
4804;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5780863165855408
4805;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8216260671615601
4806;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6880279183387756
4807;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6048992276191711
4808;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.6610627174377441
4809;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6498826742172241
4810;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5579812526702881
4811;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6180303692817688
4812;Introduce is_sysrq_oom helper function;to improve readability;https://github.com/torvalds/linux/commit/db2a0dd7a43de595d3f0542986bb17ccb6cc364c;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5429892539978027
4813;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.7925377488136292
4814;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.5571462512016296
4815;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5199862718582153
4816;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9718299508094788
4817;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7513887286186218
4818;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5694910287857056
4819;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.565858006477356
4820;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5774467587471008
4821;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7675489783287048
4822;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5370495319366455
4823;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.7919554114341736
4824;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6815948486328125
4825;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.8356180191040039
4826;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.5196126699447632
4827;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5134170651435852
4828;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5114109516143799
4829;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;https://github.com/torvalds/linux/commit/4d7b3394f76ed72cfdec23ca5571dbab6ec41793;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.623429000377655
4830;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.944820761680603
4831;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Contradicts;0.6170499920845032
4832;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5851643085479736
4833;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5416869521141052
4834;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5615707039833069
4835;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.8108484148979187
4836;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.89601731300354
4837;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5755685567855835
4838;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5268073678016663
4839;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.886573076248169
4840;we must not skip this process;because its sub-thread originated the coredump;https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7481783032417297
4841;remove the wrong check along with pr_info();wrong check along with pr_info();https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Contradicts;0.9059136509895324
4842;remove the wrong check along with pr_info();wrong check along with pr_info();https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6223737597465515
4843;remove the wrong check along with pr_info();wrong check along with pr_info();https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.918196439743042
4844;remove the wrong check along with pr_info();wrong check along with pr_info();https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.6316272020339966
4845;remove the wrong check along with pr_info();wrong check along with pr_info();https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5580855011940002
4846;remove the wrong check along with pr_info();wrong check along with pr_info();https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6182725429534912
4847;remove the wrong check along with pr_info();wrong check along with pr_info();https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.667094886302948
4848;remove the wrong check along with pr_info();wrong check along with pr_info();https://github.com/torvalds/linux/commit/0c1b2d783cf3432490bf1e532c742fffeadc0bf3;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6016523241996765
4849;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8352407813072205
4850;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5632044672966003
4851;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.7400585412979126
4852;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;OOM killed task shouldnt escape PM suspend;OOM;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5967308878898621
4853;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5904890298843384
4854;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.7621490955352783
4855;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.755118191242218
4856;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5854853391647339
4857;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;https://github.com/torvalds/linux/commit/337546e83fc7e50917f44846beee936abb9c9f1f;Contradicts;0.7491574883460999
4858;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9012643694877625
4859;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6719356179237366
4860;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;https://github.com/torvalds/linux/commit/da39da3a54fed88e29024f2f1f6cd7357cd03a44;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7715447545051575
4861;"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6581469178199768
4862;"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6633530259132385
4863;"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;Contradicts;0.5380710363388062
4864;"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.743772029876709
4865;"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Contradicts;0.6948955059051514
4866;"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.5530907511711121
4867;"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5257760882377625
4868;"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5051155686378479
4869;"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.8820570111274719
4870;"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6085529923439026
4871;"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7728838324546814
4872;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.6375120282173157
4873;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7202592492103577
4874;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9221621751785278
4875;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.5315762162208557
4876;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6210038065910339
4877;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5165018439292908
4878;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.862424373626709
4879;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7632419466972351
4880;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.7424754500389099
4881;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6388537287712097
4882;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;https://github.com/torvalds/linux/commit/dc6c9a35b66b520cf67e05d8ca60ebecad3b0479;Contradicts;0.5356004238128662
4883;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6882302165031433
4884;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;Reduce the ballast;Doesnt provide any relevant information;https://github.com/torvalds/linux/commit/974f4367dd315acc15ad4a6453f8304aea60dfbd;Contradicts;0.7213019132614136
4885;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7396992444992065
4886;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6727578043937683
4887;"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;https://github.com/torvalds/linux/commit/840807a8f40bb25a8df5b6412bba6bc156643be5;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6134089827537537
4888;fix potentially killing unrelated process;potentially killing unrelated process;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.503163754940033
4889;fix potentially killing unrelated process;potentially killing unrelated process;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6162441968917847
4890;fix potentially killing unrelated process;potentially killing unrelated process;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5717182755470276
4891;get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Contradicts;0.6443899869918823
4892;get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.5995708107948303
4893;get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9526646733283995
4894;get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6834423542022705
4895;get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5806905627250671
4896;get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7850499153137207
4897;get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5493379831314087
4898;get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6612225770950317
4899;get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5104448795318604
4900;get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.541053056716919
4901;get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6817710995674133
4902;get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.7118127942085266
4903;get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.707996666431427
4904;get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7668245434761047
4905;get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;https://github.com/torvalds/linux/commit/880b768937e90c433c0c8254a22b1eb63df005a4;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5972896218299866
4906;remove unnecessary variable;unnecessary;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6924741864204407
4907;"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7412350177764893
4908;"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.648743212223053
4909;"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9883641004562378
4910;"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.57196444272995
4911;"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6060319542884827
4912;"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6527429819107056
4913;"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7242520451545715
4914;"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6287181973457336
4915;"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6587647199630737
4916;"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5379413962364197
4917;"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6524139642715454
4918;"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.773177444934845
4919;"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5101741552352905
4920;"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;https://github.com/torvalds/linux/commit/75e8f8b24cb0dc4951267d31f0a49e5ce2f345c4;"Users of mmap_sem which need it for write should be carefully reviewed to use _killable waiting as much as possible and reduce allocations requests done with the lock held to absolute minimum
";to reduce the risk even further;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6673292517662048
4921;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.7187822461128235
4922;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6416235566139221
4923;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8683457374572754
4924;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7189515233039856
4925;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8259269595146179
4926;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5359484553337097
4927;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.8629601001739502
4928;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5342656970024109
4929;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7048996686935425
4930;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.844849705696106
4931;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;https://github.com/torvalds/linux/commit/071a4befebb655d6b31bf5c6bacd5a6df035224d;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8273972272872925
4932;Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;https://github.com/torvalds/linux/commit/6e0fc46dc2152d3e2d25a5d5b640ae3586c247c6;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.7730115652084351
4933;Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;https://github.com/torvalds/linux/commit/6e0fc46dc2152d3e2d25a5d5b640ae3586c247c6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8236358165740967
4934;Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;https://github.com/torvalds/linux/commit/6e0fc46dc2152d3e2d25a5d5b640ae3586c247c6;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.6919196248054504
4935;Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;https://github.com/torvalds/linux/commit/6e0fc46dc2152d3e2d25a5d5b640ae3586c247c6;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6249280571937561
4936;Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;https://github.com/torvalds/linux/commit/6e0fc46dc2152d3e2d25a5d5b640ae3586c247c6;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5064581632614136
4937;Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;https://github.com/torvalds/linux/commit/6e0fc46dc2152d3e2d25a5d5b640ae3586c247c6;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Contradicts;0.6028134822845459
4938;Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;https://github.com/torvalds/linux/commit/6e0fc46dc2152d3e2d25a5d5b640ae3586c247c6;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6846191883087158
4939;Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;https://github.com/torvalds/linux/commit/6e0fc46dc2152d3e2d25a5d5b640ae3586c247c6;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.629727840423584
4940;Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;https://github.com/torvalds/linux/commit/6e0fc46dc2152d3e2d25a5d5b640ae3586c247c6;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.7477512955665588
4941;Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;https://github.com/torvalds/linux/commit/6e0fc46dc2152d3e2d25a5d5b640ae3586c247c6;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6280312538146973
4942;Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;https://github.com/torvalds/linux/commit/6e0fc46dc2152d3e2d25a5d5b640ae3586c247c6;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.5078888535499573
4943;Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;https://github.com/torvalds/linux/commit/6e0fc46dc2152d3e2d25a5d5b640ae3586c247c6;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7115319967269897
4944;Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;https://github.com/torvalds/linux/commit/6e0fc46dc2152d3e2d25a5d5b640ae3586c247c6;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.528382420539856
4945;Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;https://github.com/torvalds/linux/commit/6e0fc46dc2152d3e2d25a5d5b640ae3586c247c6;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8245479464530945
4946;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.8405327200889587
4947;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.598223090171814
4948;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.585742712020874
4949;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.5574734807014465
4950;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.5271859169006348
4951;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5965442657470703
4952;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.6116045117378235
4953;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.7009574770927429
4954;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8678638339042664
4955;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.8624712228775024
4956;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.9425826072692872
4957;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6563487648963928
4958;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5225244760513306
4959;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5959814786911011
4960;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.504989504814148
4961;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.8665188550949097
4962;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7858034372329712
4963;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5383673310279846
4964;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.7270199656486511
4965;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5675851106643677
4966;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5077517032623291
4967;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5185525417327881
4968;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5938405394554138
4969;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.8009272813796997
4970;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;https://github.com/torvalds/linux/commit/dc56401fc9f25e8f93899991ec858c98a331d88c;avoid attempting to kill init sharing same memory;avoid attempting to kill init;https://github.com/torvalds/linux/commit/a2b829d95958da2025ef844c0f53ac15ad720fac;Contradicts;0.5590583682060242
4971;Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();https://github.com/torvalds/linux/commit/da51b14adb671829077da3aeb9e9edd6f8c80afe;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9638263583183287
4972;Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();https://github.com/torvalds/linux/commit/da51b14adb671829077da3aeb9e9edd6f8c80afe;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5415698885917664
4973;Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();https://github.com/torvalds/linux/commit/da51b14adb671829077da3aeb9e9edd6f8c80afe;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5437315702438354
4974;Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();https://github.com/torvalds/linux/commit/da51b14adb671829077da3aeb9e9edd6f8c80afe;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.8605303168296814
4975;Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();https://github.com/torvalds/linux/commit/da51b14adb671829077da3aeb9e9edd6f8c80afe;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5647294521331787
4976;Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();https://github.com/torvalds/linux/commit/da51b14adb671829077da3aeb9e9edd6f8c80afe;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.9784886837005616
4977;Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();https://github.com/torvalds/linux/commit/da51b14adb671829077da3aeb9e9edd6f8c80afe;Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;Contradicts;0.7281656861305237
4978;Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();https://github.com/torvalds/linux/commit/da51b14adb671829077da3aeb9e9edd6f8c80afe;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.523051381111145
4979;Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();https://github.com/torvalds/linux/commit/da51b14adb671829077da3aeb9e9edd6f8c80afe;mark_tsk_oom_victim is now called under task_lock;I think this should be OK because __thaw_task shouldnt interfere with any locking down wake_up_process;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.5197551250457764
4980;Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();https://github.com/torvalds/linux/commit/da51b14adb671829077da3aeb9e9edd6f8c80afe;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5126016139984131
4981;Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();https://github.com/torvalds/linux/commit/da51b14adb671829077da3aeb9e9edd6f8c80afe;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7185840010643005
4982;Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();https://github.com/torvalds/linux/commit/da51b14adb671829077da3aeb9e9edd6f8c80afe;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6390843391418457
4983;This could have been replaced with waitqueue_active();it only saves a few instructions in one of the coldest paths in the kernel;https://github.com/torvalds/linux/commit/c38f1025f2910d6183e9923d4b4d5804474b50c5;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Contradicts;0.5130345225334167
4984;This could have been replaced with waitqueue_active();it only saves a few instructions in one of the coldest paths in the kernel;https://github.com/torvalds/linux/commit/c38f1025f2910d6183e9923d4b4d5804474b50c5;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8524020314216614
4985;This could have been replaced with waitqueue_active();it only saves a few instructions in one of the coldest paths in the kernel;https://github.com/torvalds/linux/commit/c38f1025f2910d6183e9923d4b4d5804474b50c5;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5992368459701538
4986;This could have been replaced with waitqueue_active();it only saves a few instructions in one of the coldest paths in the kernel;https://github.com/torvalds/linux/commit/c38f1025f2910d6183e9923d4b4d5804474b50c5;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5171988606452942
4987;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Contradicts;0.6055095195770264
4988;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;modify implementation of per-mm counter;reducing patch size in future patch;https://github.com/torvalds/linux/commit/d559db086ff5be9bcc259e5aa50bf3d881eaf1d1;Contradicts;0.5431656837463379
4989;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5910095572471619
4990;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6681007742881775
4991;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5373525023460388
4992;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;fix-up schedule_timeout() usage;fix-up;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;Contradicts;0.5171540975570679
4993;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.7124598622322083
4994;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5320563316345215
4995;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5005276203155518
4996;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6841362118721008
4997;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5503501296043396
4998;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5744403600692749
4999;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;https://github.com/torvalds/linux/commit/16e951966f05da5ccd650104176f6ba289f7fa20;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6902811527252197
5000;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8380813002586365
5001;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6369338631629944
5002;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.5534133315086365
5003;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.7395058870315552
5004;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6321280598640442
5005;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5269540548324585
5006;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5435859560966492
5007;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.671638548374176
5008;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5143372416496277
5009;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.5207264423370361
5010;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5974493026733398
5011;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7843607664108276
5012;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;modify implementation of per-mm counter;reducing patch size in future patch;https://github.com/torvalds/linux/commit/d559db086ff5be9bcc259e5aa50bf3d881eaf1d1;Contradicts;0.8198022246360779
5013;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6812331676483154
5014;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;The counter is updated so early to reduce the race window;to reduce the race window;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.504036545753479
5015;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;I added some more output;Users tend to be irritated by the choice of killed processes;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.6113402247428894
5016;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.647103488445282
5017;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.6182125210762024
5018;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.7458363175392151
5019;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6975069642066956
5020;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7558230757713318
5021;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5300114154815674
5022;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.594458281993866
5023;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.778718888759613
5024;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6923388242721558
5025;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6146659255027771
5026;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5517061352729797
5027;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.5233080983161926
5028;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6455623507499695
5029;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.502167284488678
5030;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7603644728660583
5031;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5449160933494568
5032;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;https://github.com/torvalds/linux/commit/5a0e3ad6af8660be21ca98a971cd00f331318c05;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5906794667243958
5033;modify implementation of per-mm counter;reducing patch size in future patch;https://github.com/torvalds/linux/commit/d559db086ff5be9bcc259e5aa50bf3d881eaf1d1;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6438230872154236
5034;modify implementation of per-mm counter;reducing patch size in future patch;https://github.com/torvalds/linux/commit/d559db086ff5be9bcc259e5aa50bf3d881eaf1d1;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.6721094846725464
5035;modify implementation of per-mm counter;reducing patch size in future patch;https://github.com/torvalds/linux/commit/d559db086ff5be9bcc259e5aa50bf3d881eaf1d1;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5627399682998657
5036;fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;https://github.com/torvalds/linux/commit/5a2d41961dd6815b874b5c0afec0ac96cd90eea4;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9415245652198792
5037;fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;https://github.com/torvalds/linux/commit/5a2d41961dd6815b874b5c0afec0ac96cd90eea4;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7295958399772644
5038;fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;https://github.com/torvalds/linux/commit/5a2d41961dd6815b874b5c0afec0ac96cd90eea4;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5851820111274719
5039;fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;https://github.com/torvalds/linux/commit/5a2d41961dd6815b874b5c0afec0ac96cd90eea4;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.6379196047782898
5040;fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;https://github.com/torvalds/linux/commit/5a2d41961dd6815b874b5c0afec0ac96cd90eea4;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.8140803575515747
5041;fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;https://github.com/torvalds/linux/commit/5a2d41961dd6815b874b5c0afec0ac96cd90eea4;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5097049474716187
5042;fix for this bug;fix;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.6028432250022888
5043;fix for this bug;fix;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5917866826057434
5044;fix for this bug;fix;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5024980902671814
5045;fix for this bug;fix;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5807367563247681
5046;fixes the arg for mem_cgroup_print_oom_info();fixes;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9839550256729126
5047;fixes the arg for mem_cgroup_print_oom_info();fixes;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.597672700881958
5048;fixes the arg for mem_cgroup_print_oom_info();fixes;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5967114567756653
5049;fixes the arg for mem_cgroup_print_oom_info();fixes;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6451006531715393
5050;fixes the arg for mem_cgroup_print_oom_info();fixes;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9349274039268494
5051;fixes the arg for mem_cgroup_print_oom_info();fixes;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.696510374546051
5052;fixes the arg for mem_cgroup_print_oom_info();fixes;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.610711932182312
5053;fixes the arg for mem_cgroup_print_oom_info();fixes;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6737076640129089
5054;Print information of mem_cgroup;The task being killed, not current, belongs to mem_cgroup;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7518500685691833
5055;Print information of mem_cgroup;The task being killed, not current, belongs to mem_cgroup;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5915526151657104
5056;Print information of mem_cgroup;The task being killed, not current, belongs to mem_cgroup;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.66866534948349
5057;Print information of mem_cgroup;The task being killed, not current, belongs to mem_cgroup;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5309504270553589
5058;Print information of mem_cgroup;The task being killed, not current, belongs to mem_cgroup;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5203574299812317
5059;Print information of mem_cgroup;The task being killed, not current, belongs to mem_cgroup;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9873342514038086
5060;Print information of mem_cgroup;The task being killed, not current, belongs to mem_cgroup;https://github.com/torvalds/linux/commit/d31f56dbf8bafaacb0c617f9a6f137498d5c7aed;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6952540874481201
5061;fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.935887098312378
5062;fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6696227788925171
5063;fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5896705389022827
5064;fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6573729515075684
5065;fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.6140785217285156
5066;fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5186372399330139
5067;fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.8995510935783386
5068;fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7192345857620239
5069;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9400403499603271
5070;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.5277032256126404
5071;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6620518565177917
5072;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5747019052505493
5073;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5163553357124329
5074;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.520797073841095
5075;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.6894800066947937
5076;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.7892975807189941
5077;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6512241363525391
5078;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.598476767539978
5079;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.6084970235824585
5080;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5384132862091064
5081;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5268499255180359
5082;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5307623744010925
5083;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5210453271865845
5084;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;Information for all other nodes is irrelevant to the oom condition;we dont care if theres an abundance of memory elsewhere if we cant access it;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5809558629989624
5085;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8286051750183105
5086;Fix node-oriented allocation handling in oom-kill.c;bugfix;https://github.com/torvalds/linux/commit/4365a5676fa3aa1d5ae6c90c22a0044f09ba584e;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.665253758430481
5087;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8564067482948303
5088;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.6596691608428955
5089;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.7610771656036377
5090;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7030984163284302
5091;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5034192800521851
5092;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5684930086135864
5093;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5524619221687317
5094;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.6642661094665527
5095;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5998645424842834
5096;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.980338215827942
5097;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5917354822158813
5098;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5648428201675415
5099;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5451391339302063
5100;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7657294869422913
5101;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;This patch causes only memory information to be displayed for nodes that are allowed by currents cpuset when dumping the VM state;to prevent verbosity that can be harmful and cause other important messages to be scrolled from the kernel log and incur a significant time delay;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.6861062049865723
5102;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.6763244271278381
5103;adds vsz and rss information to the oom log;to help this analysis;https://github.com/torvalds/linux/commit/3b4798cbc13dd8d1150aa6377f97f0e11450a67d;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6893685460090637
5104;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.7350997924804688
5105;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5760301351547241
5106;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.9627922773361206
5107;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5241245031356812
5108;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5746698975563049
5109;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;https://github.com/torvalds/linux/commit/1b604d75bbb6e28628c5a95a433432973c33d581;This patch causes only memory information to be displayed for nodes that are allowed by currents cpuset when dumping the VM state;to prevent verbosity that can be harmful and cause other important messages to be scrolled from the kernel log and incur a significant time delay;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.612407922744751
5110;select_bad_process();it makes consistency more and makes speed up;https://github.com/torvalds/linux/commit/495789a51a91cb8c015d8d77fecbac1caf20b186;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.906706154346466
5111;select_bad_process();it makes consistency more and makes speed up;https://github.com/torvalds/linux/commit/495789a51a91cb8c015d8d77fecbac1caf20b186;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7336713075637817
5112;select_bad_process();it makes consistency more and makes speed up;https://github.com/torvalds/linux/commit/495789a51a91cb8c015d8d77fecbac1caf20b186;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5876230597496033
5113;select_bad_process();it makes consistency more and makes speed up;https://github.com/torvalds/linux/commit/495789a51a91cb8c015d8d77fecbac1caf20b186;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5613333582878113
5114;select_bad_process();it makes consistency more and makes speed up;https://github.com/torvalds/linux/commit/495789a51a91cb8c015d8d77fecbac1caf20b186;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5660702586174011
5115;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9276869297027588
5116;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.7004261016845703
5117;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6613414883613586
5118;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.5675052404403687
5119;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5443803071975708
5120;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5904033780097961
5121;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5575042366981506
5122;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6453640460968018
5123;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5672810673713684
5124;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5805436372756958
5125;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;delete unlock_range();exit_mmap() does not need locked_vm updates;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5312126278877258
5126;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.6278336644172668
5127;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.7630574107170105
5128;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5004377961158752
5129;select_bad_process() must select killable task;killable task;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.8100643157958984
5130;it should be per-process value;OOM-killer kill a process, not thread;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.5775690078735352
5131;it should be per-process value;OOM-killer kill a process, not thread;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6575937867164612
5132;it should be per-process value;OOM-killer kill a process, not thread;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.6417587995529175
5133;it should be per-process value;OOM-killer kill a process, not thread;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.7148098349571228
5134;it should be per-process value;OOM-killer kill a process, not thread;https://github.com/torvalds/linux/commit/28b83c5193e7ab951e402252278f2cc79dc4d298;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.659247875213623
5135;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.9333836436271667
5136;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5600613355636597
5137;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.6117614507675171
5138;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.5268362164497375
5139;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6995568871498108
5140;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;https://github.com/torvalds/linux/commit/2314b42db67be30b747122d65c6cd2c85da34538;Contradicts;0.5139927864074707
5141;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.6807932257652283
5142;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.8359347581863403
5143;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5341793894767761
5144;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5115596055984497
5145;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6610013842582703
5146;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7981259822845459
5147;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.7004416584968567
5148;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.7476921081542969
5149;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;fix vm_oom_kill_table[];ifdeffery;https://github.com/torvalds/linux/commit/a19cad0691597eb79c123b8a19a9faba5ab7d90e;Contradicts;0.5117248296737671
5150;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Contradicts;0.5189441442489624
5151;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.7821800708770752
5152;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;Contradicts;0.6419563293457031
5153;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6526757478713989
5154;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.9186636209487916
5155;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8645408749580383
5156;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Contradicts;0.8840505480766296
5157;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5825333595275879
5158;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7470934391021729
5159;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5049738883972168
5160;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5206150412559509
5161;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6272788047790527
5162;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5437310934066772
5163;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.6518814563751221
5164;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5811601877212524
5165;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.55312180519104
5166;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6629809141159058
5167;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;fix typo in comment;typo in comment;https://github.com/torvalds/linux/commit/bdddbcd45fd191a0213e6d2a032eb55d18bd1fc0;Contradicts;0.5350099205970764
5168;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5579935908317566
5169;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5565386414527893
5170;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;fix typos in comments;typos in comments;https://github.com/torvalds/linux/commit/f0953a1bbaca71e1ebbcb9864eb1b273156157ed;Contradicts;0.6738031506538391
5171;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5674434304237366
5172;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.526203453540802
5173;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;prevent unnecessary oom kills or kernel panics;unnecessary oom kills or kernel panics;https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6594403982162476
5174;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;https://github.com/torvalds/linux/commit/4837fe37adff1d159904f0c013471b1ecbcb455e;detect threads that are in the exit path, specifically those with PF_EXITING set;to prevent needlessly killing additional tasks;https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5346475839614868
5175;gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.5114759206771851
5176;gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5332731008529663
5177;gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.8211571574211121
5178;gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5976386666297913
5179;gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.7233337163925171
5180;gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.6825406551361084
5181;gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.5009152889251709
5182;gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6863700747489929
5183;gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.8505244851112366
5184;gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7396999597549438
5185;The behavior of oom reaper become similar to munmapping before do_exit;should be safe for all archs;https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6797335743904114
5186;The behavior of oom reaper become similar to munmapping before do_exit;should be safe for all archs;https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5709981322288513
5187;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Contradicts;0.978388011455536
5188;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.642852783203125
5189;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5983247756958008
5190;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.5797477960586548
5191;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6651097536087036
5192;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5998102426528931
5193;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6022614240646362
5194;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5083504319190979
5195;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5155885219573975
5196;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;https://github.com/torvalds/linux/commit/dd0fc66fb33cd610bc1a5db8a5e232d34879b4d7;Contradicts;0.6722127795219421
5197;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;convert it to atomic_long_t;to avoid races;https://github.com/torvalds/linux/commit/e1f56c89b040134add93f686931cc266541d239a;Contradicts;0.5389073491096497
5198;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5952852964401245
5199;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.7905800938606262
5200;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7406441569328308
5201;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5048727989196777
5202;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6239674091339111
5203;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;Contradicts;0.5923216938972473
5204;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5399423837661743
5205;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5376081466674805
5206;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.530661404132843
5207;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5968667268753052
5208;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6693482995033264
5209;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.5010536909103394
5210;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5468332767486572
5211;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.561382532119751
5212;Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5851330757141113
5213;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.6276041865348816
5214;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.5699581503868103
5215;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.573058545589447
5216;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Contradicts;0.5184091925621033
5217;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7467125654220581
5218;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.6986024975776672
5219;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.7313892245292664
5220;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6683836579322815
5221;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6698964238166809
5222;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7795489430427551
5223;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6221953630447388
5224;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.8178162574768066
5225;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5615314841270447
5226;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7163238525390625
5227;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5669918060302734
5228;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;https://github.com/torvalds/linux/commit/0205f75571e3a70c35f0dd5e608773cce97d9dbb;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.770496129989624
5229;remove pointless kthread_run() error check;pointless;https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Contradicts;0.7305218577384949
5230;remove pointless kthread_run() error check;pointless;https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6164606809616089
5231;remove pointless kthread_run() error check;pointless;https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5024813413619995
5232;remove pointless kthread_run() error check;pointless;https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5452970862388611
5233;remove pointless kthread_run() error check;pointless;https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7288963198661804
5234;remove pointless kthread_run() error check;pointless;https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.5080428719520569
5235;remove pointless kthread_run() error check;pointless;https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5257040858268738
5236;remove pointless kthread_run() error check;pointless;https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5756281018257141
5237;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Contradicts;0.8528702259063721
5238;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.7039766907691956
5239;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;hold tasklist_lock;tsk->sighand is not guarded by RCU, just as what out_of_memory() does.;https://github.com/torvalds/linux/commit/e115f2d89253490fb2dbf304b627f8d908df26f1;Contradicts;0.5816308259963989
5240;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.5221169590950012
5241;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.5996851921081543
5242;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5445842146873474
5243;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.8375283479690552
5244;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.5995951890945435
5245;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.7316250801086426
5246;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6639407873153687
5247;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6961439251899719
5248;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.6197112202644348
5249;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.7462902069091797
5250;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.883669376373291
5251;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.93816739320755
5252;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;move the cpuset semaphore region outside the tasklist_lock region;The fix seems easy enough;https://github.com/torvalds/linux/commit/505970b96e3b7d22177c38e03435a68376628e7a;Contradicts;0.5334519743919373
5253;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.8130691051483154
5254;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5332955121994019
5255;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6384314894676208
5256;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;convert it to atomic_long_t;to avoid races;https://github.com/torvalds/linux/commit/e1f56c89b040134add93f686931cc266541d239a;Contradicts;0.5605257153511047
5257;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Provide more precise dump info while memcg oom happening;more precise dump info;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5144099593162537
5258;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.943445920944214
5259;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.889208972454071
5260;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Show some helpful information;to indicate why this happens;https://github.com/torvalds/linux/commit/619b5b469bcab84ea3bee1d8d04451c781d23feb;Contradicts;0.7293389439582825
5261;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7386329770088196
5262;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.581883430480957
5263;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.6984069347381592
5264;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.8498400449752808
5265;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.779524028301239
5266;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5491201877593994
5267;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5019171833992004
5268;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;Contradicts;0.8601011633872986
5269;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;Contradicts;0.6040595173835754
5270;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.6214728355407715
5271;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;solve in a more reasonable way;more reasonable way;https://github.com/torvalds/linux/commit/9bfe5ded054b8e28a94c78580f233d6879a00146;Contradicts;0.7638686895370483
5272;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Rename page_counter_limit() to page_counter_set_max();The idea behind this renaming is to have the direct matching between memory cgroup knobs (low, high, max) and page_counters API;https://github.com/torvalds/linux/commit/bbec2e15170aae3e084d7d9afc730aeebe01b654;Contradicts;0.5724145770072937
5273;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6284593343734741
5274;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5542548298835754
5275;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.5479156374931335
5276;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Reduce the ballast;Doesnt provide any relevant information;https://github.com/torvalds/linux/commit/974f4367dd315acc15ad4a6453f8304aea60dfbd;Contradicts;0.5811814665794373
5277;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;delete unlock_range();exit_mmap() does not need locked_vm updates;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.6582459211349487
5278;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.7429275512695312
5279;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.7564942836761475
5280;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.7148231863975525
5281;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.9137211441993712
5282;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;Contradicts;0.5325080156326294
5283;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.647214949131012
5284;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6626231074333191
5285;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.5427050590515137
5286;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9563543796539308
5287;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.6183179616928101
5288;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7002013921737671
5289;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.560921311378479
5290;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6178224086761475
5291;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.8273293972015381
5292;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7730283737182617
5293;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";https://github.com/torvalds/linux/commit/c50842c8e1cddcdb69d3ece4f4df005a0e6c5ceb;avoid attempting to kill init sharing same memory;avoid attempting to kill init;https://github.com/torvalds/linux/commit/a2b829d95958da2025ef844c0f53ac15ad720fac;Contradicts;0.5215787887573242
5294;add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;https://github.com/torvalds/linux/commit/c4812909f5d5a9b7f1c85a2d95be388a066cda52;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.514291524887085
5295;add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;https://github.com/torvalds/linux/commit/c4812909f5d5a9b7f1c85a2d95be388a066cda52;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6360921263694763
5296;add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;https://github.com/torvalds/linux/commit/c4812909f5d5a9b7f1c85a2d95be388a066cda52;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7658119797706604
5297;add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;https://github.com/torvalds/linux/commit/c4812909f5d5a9b7f1c85a2d95be388a066cda52;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5772979259490967
5298;add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;https://github.com/torvalds/linux/commit/c4812909f5d5a9b7f1c85a2d95be388a066cda52;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7351268529891968
5299;add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;https://github.com/torvalds/linux/commit/c4812909f5d5a9b7f1c85a2d95be388a066cda52;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.8442190289497375
5300;add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;https://github.com/torvalds/linux/commit/c4812909f5d5a9b7f1c85a2d95be388a066cda52;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6104397177696228
5301;add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;https://github.com/torvalds/linux/commit/c4812909f5d5a9b7f1c85a2d95be388a066cda52;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8268238306045532
5302;add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;https://github.com/torvalds/linux/commit/c4812909f5d5a9b7f1c85a2d95be388a066cda52;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7406730055809021
5303;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Contradicts;0.9098841547966005
5304;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;hold tasklist_lock;tsk->sighand is not guarded by RCU, just as what out_of_memory() does.;https://github.com/torvalds/linux/commit/e115f2d89253490fb2dbf304b627f8d908df26f1;Contradicts;0.7355880737304688
5305;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.6191005110740662
5306;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Contradicts;0.913314938545227
5307;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5716100931167603
5308;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Contradicts;0.5213159322738647
5309;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.5979611277580261
5310;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.8674189448356628
5311;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.8476529121398926
5312;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.5528806447982788
5313;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.8619633316993713
5314;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.922973930835724
5315;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8723249435424805
5316;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;remove unnecessary exit_state check;unnecessary;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.9047065377235411
5317;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.5095291137695312
5318;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5224792957305908
5319;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;out_of_memory() locking fix;locking fix;https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5984340310096741
5320;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.760879397392273
5321;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.7831552028656006
5322;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.8773390650749207
5323;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Contradicts;0.5948137640953064
5324;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;Contradicts;0.6767022013664246
5325;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.7037819027900696
5326;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5238018035888672
5327;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;convert it to atomic_long_t;to avoid races;https://github.com/torvalds/linux/commit/e1f56c89b040134add93f686931cc266541d239a;Contradicts;0.5276021361351013
5328;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;the OOM victim can not get stuck on locks the looping task may hold;this way;https://github.com/torvalds/linux/commit/3812c8c8f3953921ef18544110dafc3505c1ac62;Contradicts;0.5220234394073486
5329;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.6386827230453491
5330;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7071983218193054
5331;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.5830586552619934
5332;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.6475414037704468
5333;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7735397815704346
5334;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.746452271938324
5335;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.8512213826179504
5336;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.9073082208633424
5337;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;Contradicts;0.6558924913406372
5338;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.529013991355896
5339;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6601005792617798
5340;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;improve that even further;there is a common pattern to do a range lookup first and then do something about that;https://github.com/torvalds/linux/commit/93065ac753e4443840a057bfef4be71ec766fde9;Contradicts;0.642022967338562
5341;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.767974853515625
5342;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5874852538108826
5343;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6858595013618469
5344;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5462345480918884
5345;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.6356472969055176
5346;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.886412501335144
5347;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7017836570739746
5348;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;mark_tsk_oom_victim is now called under task_lock;I think this should be OK because __thaw_task shouldnt interfere with any locking down wake_up_process;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.6085374355316162
5349;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Reduce the ballast;Doesnt provide any relevant information;https://github.com/torvalds/linux/commit/974f4367dd315acc15ad4a6453f8304aea60dfbd;Contradicts;0.54378741979599
5350;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.5226625204086304
5351;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.5887850522994995
5352;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;fix vm_oom_kill_table[];ifdeffery;https://github.com/torvalds/linux/commit/a19cad0691597eb79c123b8a19a9faba5ab7d90e;Contradicts;0.563581645488739
5353;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.9312220215797424
5354;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.7983209490776062
5355;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.5701442956924438
5356;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;LSMs should use the new has_capability_noaudit() interface;The denials will not be recorded;https://github.com/torvalds/linux/commit/a2f2945a99057c7d44043465906c6bb63c3368a0;Contradicts;0.6276431083679199
5357;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.7945926785469055
5358;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.6605261564254761
5359;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.553647518157959
5360;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6602962017059326
5361;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.8078007698059082
5362;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9202320575714112
5363;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.8860102891921997
5364;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.828272819519043
5365;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.6018733978271484
5366;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5506245493888855
5367;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;make the oom_reaper thread freezable;In order to close this race;https://github.com/torvalds/linux/commit/e26796066fdf929cbba22dabb801808f986acdb9;Contradicts;0.6148651242256165
5368;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;wake_oom_reaper used a more robust queuing;The situation would improve considerably;https://github.com/torvalds/linux/commit/03049269de433cb5fe2859be9ae4469ceb1163ed;Contradicts;0.5692961812019348
5369;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.7745959758758545
5370;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;https://github.com/torvalds/linux/commit/4d4bbd8526a8fbeb2c090ea360211fceff952383;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6309405565261841
5371;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;Update the comments for __oom_kill_task();to reflect the code changes;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;Contradicts;0.5002533793449402
5372;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5166324377059937
5373;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;OOM killed task shouldnt escape PM suspend;OOM;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5804096460342407
5374;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8292664289474487
5375;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5408551096916199
5376;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6465579271316528
5377;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5672639012336731
5378;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6039287447929382
5379;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.7836011052131653
5380;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6586962342262268
5381;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5049057006835938
5382;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5034139752388
5383;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.6943904161453247
5384;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.7485290765762329
5385;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;https://github.com/torvalds/linux/commit/337546e83fc7e50917f44846beee936abb9c9f1f;Contradicts;0.7618991732597351
5386;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.680001437664032
5387;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5050747394561768
5388;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8533841967582703
5389;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;https://github.com/torvalds/linux/commit/212925802454672e6cd2949a727f5e2c1377bf06;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5079101920127869
5390;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.6893470287322998
5391;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6512271761894226
5392;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6798552870750427
5393;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5528631210327148
5394;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8070719242095947
5395;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7009749412536621
5396;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6336385011672974
5397;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.731619119644165
5398;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;https://github.com/torvalds/linux/commit/cd04ae1e2dc8e3651b8c427ec1b9500c6eed7b90;A kernel thread has been chosen;we need a reliable way of invocation so workqueue context is not appropriate because all the workers might be busy;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5121195316314697
5399;hold tasklist_lock;tsk->sighand is not guarded by RCU, just as what out_of_memory() does.;https://github.com/torvalds/linux/commit/e115f2d89253490fb2dbf304b627f8d908df26f1;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.5338619947433472
5400;hold tasklist_lock;tsk->sighand is not guarded by RCU, just as what out_of_memory() does.;https://github.com/torvalds/linux/commit/e115f2d89253490fb2dbf304b627f8d908df26f1;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.714342474937439
5401;hold tasklist_lock;tsk->sighand is not guarded by RCU, just as what out_of_memory() does.;https://github.com/torvalds/linux/commit/e115f2d89253490fb2dbf304b627f8d908df26f1;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.7035433053970337
5402;Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;https://github.com/torvalds/linux/commit/1b578df02207a67a29e8ced4db3b36d89df52fef;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.5192543268203735
5403;Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;https://github.com/torvalds/linux/commit/1b578df02207a67a29e8ced4db3b36d89df52fef;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5378913283348083
5404;Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;https://github.com/torvalds/linux/commit/1b578df02207a67a29e8ced4db3b36d89df52fef;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.5041940808296204
5405;Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;https://github.com/torvalds/linux/commit/1b578df02207a67a29e8ced4db3b36d89df52fef;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.5537382960319519
5406;Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;https://github.com/torvalds/linux/commit/1b578df02207a67a29e8ced4db3b36d89df52fef;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7431409955024719
5407;Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;https://github.com/torvalds/linux/commit/1b578df02207a67a29e8ced4db3b36d89df52fef;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5638914108276367
5408;Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;https://github.com/torvalds/linux/commit/1b578df02207a67a29e8ced4db3b36d89df52fef;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5223352909088135
5409;Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;https://github.com/torvalds/linux/commit/1b578df02207a67a29e8ced4db3b36d89df52fef;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5164784789085388
5410;Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;https://github.com/torvalds/linux/commit/1b578df02207a67a29e8ced4db3b36d89df52fef;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5244532823562622
5411;Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;https://github.com/torvalds/linux/commit/1b578df02207a67a29e8ced4db3b36d89df52fef;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7445081472396851
5412;add sysctl to enable task memory dump;enable task memory dump;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5896585583686829
5413;add sysctl to enable task memory dump;enable task memory dump;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7101050019264221
5414;add sysctl to enable task memory dump;enable task memory dump;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5884342193603516
5415;add sysctl to enable task memory dump;enable task memory dump;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8097538948059082
5416;Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5630233287811279
5417;Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5984561443328857
5418;Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.5471875667572021
5419;Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.556115448474884
5420;Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Contradicts;0.719484269618988
5421;Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;Contradicts;0.5001938343048096
5422;Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.652408242225647
5423;It is configurable;so that large systems, such as those with several thousand tasks, do not incur a performance penalty associated with dumping data they may not desire;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.6543150544166565
5424;It is configurable;so that large systems, such as those with several thousand tasks, do not incur a performance penalty associated with dumping data they may not desire;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6250237226486206
5425;The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.72495037317276
5426;The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5104621052742004
5427;The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.641965925693512
5428;The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7478246092796326
5429;The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.7705469727516174
5430;The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.536888599395752
5431;The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6441973447799683
5432;The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6195909976959229
5433;The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5289809703826904
5434;The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.531939685344696
5435;The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7473155856132507
5436;The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;https://github.com/torvalds/linux/commit/fef1bdd68c81b71882ccb6f47c70980a03182063;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6533980369567871
5437;Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6914932727813721
5438;Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5102251768112183
5439;Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5083655118942261
5440;Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.5875198245048523
5441;allow for CAP_SYS_RESOURCE as well;"CAP_SYS_RESOURCE means ""give me extra resources""";https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6561716794967651
5442;allow for CAP_SYS_RESOURCE as well;"CAP_SYS_RESOURCE means ""give me extra resources""";https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6315868496894836
5443;allow for CAP_SYS_RESOURCE as well;"CAP_SYS_RESOURCE means ""give me extra resources""";https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.6253977417945862
5444;allow for CAP_SYS_RESOURCE as well;"CAP_SYS_RESOURCE means ""give me extra resources""";https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.8468199968338013
5445;allow for CAP_SYS_RESOURCE as well;"CAP_SYS_RESOURCE means ""give me extra resources""";https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6286501884460449
5446;allow for CAP_SYS_RESOURCE as well;"CAP_SYS_RESOURCE means ""give me extra resources""";https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5626118779182434
5447;allow for CAP_SYS_RESOURCE as well;"CAP_SYS_RESOURCE means ""give me extra resources""";https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5704503059387207
5448;allow for CAP_SYS_RESOURCE as well;"CAP_SYS_RESOURCE means ""give me extra resources""";https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6449547410011292
5449;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.610601007938385
5450;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5408321022987366
5451;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.7279808521270752
5452;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7201339602470398
5453;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.514333188533783
5454;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.9458023905754088
5455;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;renaming;doesnt bring any functional change;https://github.com/torvalds/linux/commit/bbec2e15170aae3e084d7d9afc730aeebe01b654;Contradicts;0.8156086802482605
5456;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.815811276435852
5457;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;delete unlock_range();exit_mmap() does not need locked_vm updates;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.9550231099128724
5458;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.5468348264694214
5459;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;LSMs should use the new has_capability_noaudit() interface;The denials will not be recorded;https://github.com/torvalds/linux/commit/a2f2945a99057c7d44043465906c6bb63c3368a0;Contradicts;0.5106955170631409
5460;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.7195748686790466
5461;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.7903581857681274
5462;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;delete the corresponding comment;it will be checked in oom_unkillable_task();https://github.com/torvalds/linux/commit/f8159c13905bba26f3e1782a521dacf7a66fc1ce;Contradicts;0.5376424789428711
5463;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.566013514995575
5464;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7040777206420898
5465;uid==0 makes processes only on the host more important;even without any capabilities;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.582138180732727
5466;uid==0 makes processes only on the host more important;even without any capabilities;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5921363234519958
5467;uid==0 makes processes only on the host more important;even without any capabilities;https://github.com/torvalds/linux/commit/97829955ad291acec1d8b94e9911b3ceb1118bb1;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.6923187971115112
5468;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;https://github.com/torvalds/linux/commit/b460cbc581a53cc088ceba80608021dd49c63c43;Contradicts;0.6095103621482849
5469;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.6233958601951599
5470;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.5735738277435303
5471;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8762239813804626
5472;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.8999482989311218
5473;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.8454625010490417
5474;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.633474588394165
5475;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.5465121865272522
5476;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5737799406051636
5477;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6998915076255798
5478;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.8564866185188293
5479;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.6066142916679382
5480;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6239014267921448
5481;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9137638211250304
5482;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5102512836456299
5483;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6557601690292358
5484;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.8579533696174622
5485;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.8342708349227905
5486;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6232447028160095
5487;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5623764991760254
5488;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5438451170921326
5489;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.685836911201477
5490;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;cap_safe_nice() only ever saw current, so now uses capable();only ever saw current, capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.7748452425003052
5491;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5554240345954895
5492;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6329606175422668
5493;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.7437432408332825
5494;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6255261898040771
5495;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5561625957489014
5496;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.601612389087677
5497;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.59401535987854
5498;The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;https://github.com/torvalds/linux/commit/e338d263a76af78fe8f38a72131188b58fceb591;Add a missing newline;missing;https://github.com/torvalds/linux/commit/756a025f00091918d9d09ca3229defb160b409c0;Contradicts;0.5360884070396423
5499;Move the task_struct members specific to rt scheduling together;specific to rt scheduling;https://github.com/torvalds/linux/commit/fa717060f1ab7eb6570f2fb49136f838fc9195a9;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Contradicts;0.5433961749076843
5500;Move the task_struct members specific to rt scheduling together;specific to rt scheduling;https://github.com/torvalds/linux/commit/fa717060f1ab7eb6570f2fb49136f838fc9195a9;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5780795812606812
5501;Move the task_struct members specific to rt scheduling together;specific to rt scheduling;https://github.com/torvalds/linux/commit/fa717060f1ab7eb6570f2fb49136f838fc9195a9;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6565788984298706
5502;Move the task_struct members specific to rt scheduling together;specific to rt scheduling;https://github.com/torvalds/linux/commit/fa717060f1ab7eb6570f2fb49136f838fc9195a9;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5392090082168579
5503;Move the task_struct members specific to rt scheduling together;specific to rt scheduling;https://github.com/torvalds/linux/commit/fa717060f1ab7eb6570f2fb49136f838fc9195a9;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.5465744733810425
5504;Move the task_struct members specific to rt scheduling together;specific to rt scheduling;https://github.com/torvalds/linux/commit/fa717060f1ab7eb6570f2fb49136f838fc9195a9;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5366456508636475
5505;Move the task_struct members specific to rt scheduling together;specific to rt scheduling;https://github.com/torvalds/linux/commit/fa717060f1ab7eb6570f2fb49136f838fc9195a9;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6640838384628296
5506;Move the task_struct members specific to rt scheduling together;specific to rt scheduling;https://github.com/torvalds/linux/commit/fa717060f1ab7eb6570f2fb49136f838fc9195a9;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5825070738792419
5507;Move the task_struct members specific to rt scheduling together;specific to rt scheduling;https://github.com/torvalds/linux/commit/fa717060f1ab7eb6570f2fb49136f838fc9195a9;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6207613348960876
5508;Move the task_struct members specific to rt scheduling together;specific to rt scheduling;https://github.com/torvalds/linux/commit/fa717060f1ab7eb6570f2fb49136f838fc9195a9;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7777890563011169
5509;Move the task_struct members specific to rt scheduling together;specific to rt scheduling;https://github.com/torvalds/linux/commit/fa717060f1ab7eb6570f2fb49136f838fc9195a9;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5186818838119507
5510;Move the task_struct members specific to rt scheduling together;specific to rt scheduling;https://github.com/torvalds/linux/commit/fa717060f1ab7eb6570f2fb49136f838fc9195a9;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5217791199684143
5511;Use helpers to obtain task pid in printks;to obtain task pid in printks;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6384342312812805
5512;Use helpers to obtain task pid in printks;to obtain task pid in printks;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.5134844779968262
5513;Use helpers to obtain task pid in printks;to obtain task pid in printks;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.8007149696350098
5514;Use helpers to obtain task pid in printks;to obtain task pid in printks;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6940857768058777
5515;Use helpers to obtain task pid in printks;to obtain task pid in printks;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6006933450698853
5516;Use helpers to obtain task pid in printks;to obtain task pid in printks;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.608441948890686
5517;Use helpers to obtain task pid in printks;to obtain task pid in printks;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5752491354942322
5518;Use helpers to obtain task pid in printks;to obtain task pid in printks;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.564428985118866
5519;Use helpers to obtain task pid in printks;to obtain task pid in printks;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6188939809799194
5520;Use helpers to obtain task pid in printks;to obtain task pid in printks;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.8459240198135376
5521;start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5306844711303711
5522;start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8817124962806702
5523;start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.8779756426811218
5524;start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7006956338882446
5525;start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.65966796875
5526;start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5876716375350952
5527;start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6222339868545532
5528;start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5168495774269104
5529;start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5770856142044067
5530;start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5227627158164978
5531;start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8336198329925537
5532;start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.551359236240387
5533;start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6382141709327698
5534;start with the pid, printed to dmesg ;safely use task_pid_nr() in this case;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Contradicts;0.5097365379333496
5535;start with the pid, printed to dmesg ;safely use task_pid_nr() in this case;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5745362043380737
5536;start with the pid, printed to dmesg ;safely use task_pid_nr() in this case;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.737127423286438
5537;start with the pid, printed to dmesg ;safely use task_pid_nr() in this case;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5990512371063232
5538;start with the pid, printed to dmesg ;safely use task_pid_nr() in this case;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5479515194892883
5539;start with the pid, printed to dmesg ;safely use task_pid_nr() in this case;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.616783618927002
5540;start with the pid, printed to dmesg ;safely use task_pid_nr() in this case;https://github.com/torvalds/linux/commit/ba25f9dcc4ea6e30839fcab5a5516f2176d5bfed;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5772702097892761
5541;hide it behind the helpers;With pid namespaces this field is now dangerous to use explicitly;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5248941779136658
5542;hide it behind the helpers;With pid namespaces this field is now dangerous to use explicitly;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5581744313240051
5543;hide it behind the helpers;With pid namespaces this field is now dangerous to use explicitly;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.7419416904449463
5544;hide it behind the helpers;With pid namespaces this field is now dangerous to use explicitly;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5847366452217102
5545;hide it behind the helpers;With pid namespaces this field is now dangerous to use explicitly;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;The oom killer does not want to defer in this case;there is no guarantee that thread will ever exit without intervention;https://github.com/torvalds/linux/commit/edd45544c6f09550df0a5491aa8a07af24767e73;Contradicts;0.7307841181755066
5546;start isolating the tons of warnings;cannot be sent right now as this leads to tons of warnings;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Contradicts;0.5980114340782166
5547;start isolating the tons of warnings;cannot be sent right now as this leads to tons of warnings;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5765072107315063
5548;start isolating the tons of warnings;cannot be sent right now as this leads to tons of warnings;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5214409828186035
5549;p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6682213544845581
5550;p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6876901388168335
5551;p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5171175003051758
5552;p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.8168197870254517
5553;p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5045274496078491
5554;p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.775569498538971
5555;p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6033647060394287
5556;p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5368791818618774
5557;p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;https://github.com/torvalds/linux/commit/bac0abd6174e427404dd197cdbefece31e97329b;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7992454767227173
5558;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;https://github.com/torvalds/linux/commit/b460cbc581a53cc088ceba80608021dd49c63c43;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5288401246070862
5559;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;https://github.com/torvalds/linux/commit/b460cbc581a53cc088ceba80608021dd49c63c43;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.59870845079422
5560;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.6122865080833435
5561;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5802368521690369
5562;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5372488498687744
5563;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6886841058731079
5564;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5289592146873474
5565;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5480718016624451
5566;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.902287483215332
5567;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;https://github.com/torvalds/linux/commit/bbe373f2c60b2aa36c3231734a5afc5271a06718;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.630527913570404
5568;update comments to reflect current code;reflect current code;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.7669598460197449
5569;update comments to reflect current code;reflect current code;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;remove unnecessary exit_state check;unnecessary;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Contradicts;0.5288050174713135
5570;update comments to reflect current code;reflect current code;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5346273183822632
5571;update comments to reflect current code;reflect current code;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;remove a stale code;quick fixup;https://github.com/torvalds/linux/commit/9bfe5ded054b8e28a94c78580f233d6879a00146;Contradicts;0.7817121744155884
5572;update comments to reflect current code;reflect current code;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5429107546806335
5573;update comments to reflect current code;reflect current code;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;delete the corresponding comment;it will be checked in oom_unkillable_task();https://github.com/torvalds/linux/commit/f8159c13905bba26f3e1782a521dacf7a66fc1ce;Contradicts;0.5342803001403809
5574;update comments to reflect current code;reflect current code;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.6547873616218567
5575;Update the comments for __oom_kill_task();to reflect the code changes;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5518845319747925
5576;Update the comments for __oom_kill_task();to reflect the code changes;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.653880774974823
5577;Update the comments for __oom_kill_task();to reflect the code changes;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5116941332817078
5578;Update the comments for __oom_kill_task();to reflect the code changes;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5134506821632385
5579;Update the comments for __oom_kill_task();to reflect the code changes;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5332762598991394
5580;Update the comments for __oom_kill_task();to reflect the code changes;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;delete the corresponding comment;it will be checked in oom_unkillable_task();https://github.com/torvalds/linux/commit/f8159c13905bba26f3e1782a521dacf7a66fc1ce;Contradicts;0.815309464931488
5581;Update the comments for __oom_kill_task();to reflect the code changes;https://github.com/torvalds/linux/commit/5a291b98b2116d669449885abef3000f747504b3;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.5159125328063965
5582;Moving the test down;will give the desired behaviour;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8169830441474915
5583;Moving the test down;will give the desired behaviour;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.9501559138298036
5584;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.9363641142845154
5585;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Contradicts;0.9382614493370056
5586;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.6335048079490662
5587;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5919274091720581
5588;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.9728145599365234
5589;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5760741233825684
5590;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5553708076477051
5591;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5879161953926086
5592;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.7598164081573486
5593;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.5603137016296387
5594;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.9074370861053468
5595;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;https://github.com/torvalds/linux/commit/4a3ede107e422a0c53d28024b0aa902ca22a8768;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.514288067817688
5596;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5722048878669739
5597;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5416200757026672
5598;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.8409841060638428
5599;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;considered a reasonable constrain;the overall system health is more important than debugability of a particular application;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5507022738456726
5600;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Patches 3 and 4 should go in ditto;trivial printk -> pr_info conversion;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.5490204691886902
5601;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5127943754196167
5602;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.6572113037109375
5603;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5252839922904968
5604;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.7547205686569214
5605;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.979034662246704
5606;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.9892059564590454
5607;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.8847330808639526
5608;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.5799601674079895
5609;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;https://github.com/torvalds/linux/commit/50ec3bbffbe8a96347c54832d48110a5bc9e9ff8;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.8483377695083618
5610;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5955657362937927
5611;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8205381631851196
5612;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5793761610984802
5613;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5156888365745544
5614;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5084131956100464
5615;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7347205281257629
5616;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5983895063400269
5617;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.7470964789390564
5618;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.720291256904602
5619;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.599168062210083
5620;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5351977944374084
5621;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.523712694644928
5622;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.8504924178123474
5623;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;Reduce the ballast;Doesnt provide any relevant information;https://github.com/torvalds/linux/commit/974f4367dd315acc15ad4a6453f8304aea60dfbd;Contradicts;0.6154605150222778
5624;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6839314699172974
5625;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9443918466567992
5626;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7551764249801636
5627;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;https://github.com/torvalds/linux/commit/7887a3da753e1ba8244556cc9a2b38c815bfe256;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5641332268714905
5628;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5808077454566956
5629;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6161681413650513
5630;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5236291885375977
5631;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8270419836044312
5632;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5273808240890503
5633;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5877251625061035
5634;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6545414924621582
5635;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;https://github.com/torvalds/linux/commit/8bc719d3cab8414938f9ea6e33b58d8810d18068;"Users of mmap_sem which need it for write should be carefully reviewed to use _killable waiting as much as possible and reduce allocations requests done with the lock held to absolute minimum
";to reduce the risk even further;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.8801484107971191
5636;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5060783624649048
5637;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.7079873085021973
5638;remove task_t, convert to struct task_struct;cleanup, remove;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7449345588684082
5639;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5405687689781189
5640;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6050650477409363
5641;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.7903576493263245
5642;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;https://github.com/torvalds/linux/commit/36c8b586896f60cb91a4fd526233190b34316baf;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8624908328056335
5643;fixes a few typos;in the comments in mm/oom_kill.c;https://github.com/torvalds/linux/commit/6937a25cff818d32d0f9ff58a518c9ab96760aeb;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5670311450958252
5644;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6057698130607605
5645;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5830212831497192
5646;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5380865335464478
5647;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Contradicts;0.5840492844581604
5648;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5500314831733704
5649;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Remove the unused arguments and update all callers.;unused.;https://github.com/torvalds/linux/commit/a72afd873089c697053e9daa85ff343b3140d2e7;Contradicts;0.6114537119865417
5650;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Remove the unused arguments and update all callers.;unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;Contradicts;0.6114537119865417
5651;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7250349521636963
5652;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.839577853679657
5653;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;Contradicts;0.6260330080986023
5654;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.7475539445877075
5655;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;fix vm_oom_kill_table[];ifdeffery;https://github.com/torvalds/linux/commit/a19cad0691597eb79c123b8a19a9faba5ab7d90e;Contradicts;0.565211296081543
5656;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.571768581867218
5657;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5067582726478577
5658;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;"This is identical to the global oom killer and is done even before checking for panic_on_oom: a pending SIGKILL here while panic_on_oom is selected is guaranteed to have come from userspace; the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory.";the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.6773255467414856
5659;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;prevent unnecessary oom kills or kernel panics;unnecessary oom kills or kernel panics;https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5162464380264282
5660;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.5009199976921082
5661;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5892136096954346
5662;panic is preferable rather than kill some processes;there are environments where panic is preferable;https://github.com/torvalds/linux/commit/fadd8fbd153c12963f8fe3c9ef7f8967f286f98b;"Users of mmap_sem which need it for write should be carefully reviewed to use _killable waiting as much as possible and reduce allocations requests done with the lock held to absolute minimum
";to reduce the risk even further;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.8403056263923645
5663;fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Contradicts;0.8000869750976562
5664;fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.605262815952301
5665;fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5087162852287292
5666;fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7400048971176147
5667;fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.6497576832771301
5668;fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6122633814811707
5669;fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6792756915092468
5670;fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6722546219825745
5671;fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5714259743690491
5672;fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8450508117675781
5673;Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.5147132873535156
5674;Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.586137056350708
5675;Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Contradicts;0.5430020093917847
5676;Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5023162961006165
5677;Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6251468658447266
5678;Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5236912369728088
5679;Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;fix vm_oom_kill_table[];ifdeffery;https://github.com/torvalds/linux/commit/a19cad0691597eb79c123b8a19a9faba5ab7d90e;Contradicts;0.5315428376197815
5680;Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.7271890044212341
5681;Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5623658895492554
5682;Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7707687616348267
5683;Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6869246959686279
5684;Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;https://github.com/torvalds/linux/commit/013159227b840dfd441bd2e4c8b4d77ffb3cc42e;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5292867422103882
5685;mm locking fix;oom-kill;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5695281624794006
5686;Patches 3 and 4 should go in ditto;trivial printk -> pr_info conversion;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5295060873031616
5687;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6201165914535522
5688;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.6471394300460815
5689;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Contradicts;0.8651572465896606
5690;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5473694801330566
5691;Give the oom victim access to the memory reserves;That shouldnt be necessary;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.9408663511276244
5692;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Contradicts;0.6166080832481384
5693;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Contradicts;0.7715407609939575
5694;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6175445914268494
5695;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5525345206260681
5696;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5121503472328186
5697;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5275275707244873
5698;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.531722366809845
5699;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6114903688430786
5700;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5354483723640442
5701;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.9345135688781738
5702;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6624926924705505
5703;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6180397272109985
5704;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6923937201499939
5705;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7361370921134949
5706;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.7714449167251587
5707;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5324423909187317
5708;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5497590899467468
5709;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;https://github.com/torvalds/linux/commit/1da4db0cd5c8a31d4468ec906b413e75e604b465;Contradicts;0.742797315120697
5710;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Provide more precise dump info while memcg oom happening;more precise dump info;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5156064033508301
5711;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5719289183616638
5712;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;renaming;doesnt bring any functional change;https://github.com/torvalds/linux/commit/bbec2e15170aae3e084d7d9afc730aeebe01b654;Contradicts;0.5516674518585205
5713;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6104786396026611
5714;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Introduce a struct zoneref to store a zone pointer and a zone index;Store a zone pointer and a zone index;https://github.com/torvalds/linux/commit/dd1a239f6f2d4d3eedd318583ec319aa145b324c;Contradicts;0.5237554311752319
5715;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.520789384841919
5716;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.507963240146637
5717;Setting the flag for current is not necessary;check and set is not racy;https://github.com/torvalds/linux/commit/83363b917a2982dd509a5e2125e905b6873505a3;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5083103775978088
5718;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.6743791699409485
5719;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;https://github.com/torvalds/linux/commit/d7a94e7e11badf8404d40b41e008c3131a3cebe3;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5811747908592224
5720;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7323431968688965
5721;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6063095927238464
5722;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5254589319229126
5723;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.8148778080940247
5724;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5381908416748047
5725;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.9321715235710144
5726;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5058798789978027
5727;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.8853147625923157
5728;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5183458924293518
5729;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6048888564109802
5730;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8447339534759521
5731;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5350149273872375
5732;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5784616470336914
5733;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5876880288124084
5734;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.501032829284668
5735;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.7452084422111511
5736;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5327642560005188
5737;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.78321772813797
5738;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.53861403465271
5739;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6106684803962708
5740;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5160773396492004
5741;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.92571222782135
5742;check all threads which could share the same ->mm;to make it more or less correct;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6288939118385315
5743;check all threads which could share the same ->mm;to make it more or less correct;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.9057413935661316
5744;check all threads which could share the same ->mm;to make it more or less correct;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5073435306549072
5745;check all threads which could share the same ->mm;to make it more or less correct;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6908567547798157
5746;check all threads which could share the same ->mm;to make it more or less correct;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5122438073158264
5747;check all threads which could share the same ->mm;to make it more or less correct;https://github.com/torvalds/linux/commit/6a2d5679b4a852a3bf80c570644456ab466ab714;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8906056880950928
5748;fatal_signal_pending() can be true;because of SIGNAL_GROUP_COREDUMP so out_of_memory() and mem_cgroup_out_of_memory() shouldnt blindly trust it;https://github.com/torvalds/linux/commit/d003f371b27016354c392464819530d47a915765;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6837698221206665
5749;fatal_signal_pending() can be true;because of SIGNAL_GROUP_COREDUMP so out_of_memory() and mem_cgroup_out_of_memory() shouldnt blindly trust it;https://github.com/torvalds/linux/commit/d003f371b27016354c392464819530d47a915765;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5867528915405273
5750;fatal_signal_pending() can be true;because of SIGNAL_GROUP_COREDUMP so out_of_memory() and mem_cgroup_out_of_memory() shouldnt blindly trust it;https://github.com/torvalds/linux/commit/d003f371b27016354c392464819530d47a915765;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5055028200149536
5751;Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;https://github.com/torvalds/linux/commit/2314b42db67be30b747122d65c6cd2c85da34538;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.7713767290115356
5752;Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;https://github.com/torvalds/linux/commit/2314b42db67be30b747122d65c6cd2c85da34538;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.5519346594810486
5753;Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;https://github.com/torvalds/linux/commit/2314b42db67be30b747122d65c6cd2c85da34538;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7433024048805237
5754;Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;https://github.com/torvalds/linux/commit/2314b42db67be30b747122d65c6cd2c85da34538;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.699467658996582
5755;Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;https://github.com/torvalds/linux/commit/2314b42db67be30b747122d65c6cd2c85da34538;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7204397320747375
5756;Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;https://github.com/torvalds/linux/commit/2314b42db67be30b747122d65c6cd2c85da34538;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5031778216362
5757;Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;https://github.com/torvalds/linux/commit/2314b42db67be30b747122d65c6cd2c85da34538;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.622855544090271
5758;Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;https://github.com/torvalds/linux/commit/2314b42db67be30b747122d65c6cd2c85da34538;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;Contradicts;0.6180773973464966
5759;Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;https://github.com/torvalds/linux/commit/2314b42db67be30b747122d65c6cd2c85da34538;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6355665922164917
5760;simplify the API back to the single check;to simplify the API back;https://github.com/torvalds/linux/commit/344736f29b359790facd0b7a521e367f1715c11c;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5925992727279663
5761;simplify the API back to the single check;to simplify the API back;https://github.com/torvalds/linux/commit/344736f29b359790facd0b7a521e367f1715c11c;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7573206424713135
5762;OOM killed task shouldnt escape PM suspend;OOM;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.6332420706748962
5763;OOM killed task shouldnt escape PM suspend;OOM;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;I added some more output;Users tend to be irritated by the choice of killed processes;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5990748405456543
5764;OOM killed task shouldnt escape PM suspend;OOM;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5277824401855469
5765;OOM killed task shouldnt escape PM suspend;OOM;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7422463893890381
5766;OOM killed task shouldnt escape PM suspend;OOM;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.7801758646965027
5767;OOM killed task shouldnt escape PM suspend;OOM;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5794808864593506
5768;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.8637358546257019
5769;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5243837833404541
5770;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6531530618667603
5771;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6079166531562805
5772;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;improve that even further;there is a common pattern to do a range lookup first and then do something about that;https://github.com/torvalds/linux/commit/93065ac753e4443840a057bfef4be71ec766fde9;Contradicts;0.5994060635566711
5773;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.5427003502845764
5774;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7080536484718323
5775;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Reduce the ballast;Doesnt provide any relevant information;https://github.com/torvalds/linux/commit/974f4367dd315acc15ad4a6453f8304aea60dfbd;Contradicts;0.6019519567489624
5776;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.6270395517349243
5777;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.6374988555908203
5778;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6742771863937378
5779;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7104372382164001
5780;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7576218843460083
5781;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5206043720245361
5782;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Contradicts;0.5034977197647095
5783;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;no longer get stuck on any lock;a sleeping task may hold;https://github.com/torvalds/linux/commit/3812c8c8f3953921ef18544110dafc3505c1ac62;Contradicts;0.5084598064422607
5784;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8150544166564941
5785;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.638578474521637
5786;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.8495392799377441
5787;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5980979204177856
5788;The counter is updated so early to reduce the race window;to reduce the race window;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Contradicts;0.5108579397201538
5789;The counter is updated so early to reduce the race window;to reduce the race window;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5950416326522827
5790;The counter is updated so early to reduce the race window;to reduce the race window;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5790839791297913
5791;The counter is updated so early to reduce the race window;to reduce the race window;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5249963402748108
5792;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.5525299310684204
5793;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7675958871841431
5794;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6351165771484375
5795;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6040092706680298
5796;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5577185153961182
5797;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;https://github.com/torvalds/linux/commit/dc6c9a35b66b520cf67e05d8ca60ebecad3b0479;Contradicts;0.5522034764289856
5798;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.961441159248352
5799;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8948301672935486
5800;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;https://github.com/torvalds/linux/commit/5695be142e203167e3cb515ef86a88424f3524eb;make the oom_reaper thread freezable;In order to close this race;https://github.com/torvalds/linux/commit/e26796066fdf929cbba22dabb801808f986acdb9;Contradicts;0.5862768888473511
5801;remove unnecessary exit_state check;unnecessary;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5106279850006104
5802;remove unnecessary exit_state check;unnecessary;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.7580173015594482
5803;remove unnecessary exit_state check;unnecessary;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6014225482940674
5804;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Contradicts;0.6773898601531982
5805;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5188030004501343
5806;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.801693856716156
5807;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6711064577102661
5808;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.505500853061676
5809;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5892608165740967
5810;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;https://github.com/torvalds/linux/commit/fb794bcbb4e5552242f9a4c5e1ffe4c6da29a968;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5872620940208435
5811;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Contradicts;0.5799390077590942
5812;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5440680980682373
5813;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.6245113611221313
5814;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7251679301261902
5815;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6758503913879395
5816;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7471275925636292
5817;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;fix vm_oom_kill_table[];ifdeffery;https://github.com/torvalds/linux/commit/a19cad0691597eb79c123b8a19a9faba5ab7d90e;Contradicts;0.5062434673309326
5818;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.5098912119865417
5819;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.560656726360321
5820;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7472575306892395
5821;Convert oom_zonelist_trylock() to return bool instead of int;Only success and failure are tested;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6023077964782715
5822;Convert oom_zonelist_trylock() to return bool instead of int;Only success and failure are tested;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6417443156242371
5823;Convert oom_zonelist_trylock() to return bool instead of int;Only success and failure are tested;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7458382844924927
5824;Convert oom_zonelist_trylock() to return bool instead of int;Only success and failure are tested;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.515985369682312
5825;Convert oom_zonelist_trylock() to return bool instead of int;Only success and failure are tested;https://github.com/torvalds/linux/commit/e972a070e2d3296cd2e2cc2fd0561ce89a1d5ebf;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6056395769119263
5826;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6081147789955139
5827;Fix it up via task_lock();instead;https://github.com/torvalds/linux/commit/97c2c9b84d0c1edf4926b13661d5af3f0edccbce;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5060932040214539
5828;out_of_memory() locking fix;locking fix;https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6397291421890259
5829;out_of_memory() locking fix;locking fix;https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5400663614273071
5830;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5076168775558472
5831;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5618059635162354
5832;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.5554885268211365
5833;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();https://github.com/torvalds/linux/commit/140ffcec4def3ee3af7565b2cf1d3b2580f7e180;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5624971985816956
5834;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.589367687702179
5835;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6043281555175781
5836;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Change __task_will_free_mem to test signal->core_state instead of the flag SIGNAL_GROUP_COREDUMP;In preparation for removing the flag SIGNAL_GROUP_COREDUMP;https://github.com/torvalds/linux/commit/98b24b16b2aebffabf5b8670f44f19666c1e029f;Contradicts;0.5165998935699463
5837;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7307273745536804
5838;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6668172478675842
5839;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.7922723293304443
5840;The solution is similar to what we do when running out of hugepages;similar to what we do when running out of hugepages;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5741819739341736
5841;The solution is similar to what we do when running out of hugepages;similar to what we do when running out of hugepages;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7697442770004272
5842;The solution is similar to what we do when running out of hugepages;similar to what we do when running out of hugepages;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.5663871765136719
5843;The solution is similar to what we do when running out of hugepages;similar to what we do when running out of hugepages;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5711546540260315
5844;reconstruct a list of nodes;performance considerations do not matter much;https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6143436431884766
5845;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;I added some more output;Users tend to be irritated by the choice of killed processes;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.6971049308776855
5846;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7456372976303101
5847;kill the current process;this is a constrained allocation and we should (kill the current process);https://github.com/torvalds/linux/commit/9b0f8b040acd8dfd23860754c0d09ff4f44e2cbc;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.6742164492607117
5848;account the memory consumption of the (direct) children to the father;we do want to;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.6482958197593689
5849;account the memory consumption of the (direct) children to the father;we do want to;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5871486663818359
5850;account the memory consumption of the (direct) children to the father;we do want to;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5582386255264282
5851;account the memory consumption of the (direct) children to the father;we do want to;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5834285020828247
5852;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;https://github.com/torvalds/linux/commit/1da4db0cd5c8a31d4468ec906b413e75e604b465;Contradicts;0.8657600283622742
5853;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7396525740623474
5854;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.5612038969993591
5855;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5065333247184753
5856;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5006803274154663
5857;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.5541977882385254
5858;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;This patch fixes the problem and should be backported into stable/LTS.;Fixes the problem, should be backported into stable/LTS.;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.5701194405555725
5859;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5676083564758301
5860;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5713101625442505
5861;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;This patch fixes the issue by introducing a new MMF_OOM_KILLED mm flag which is set in oom_kill_process atomically and oom reaper is disabled if the flag was already set.;Fixes the issue by introducing a new MMF_OOM_KILLED mm flag and disabling the oom reaper if the flag was already set.;https://github.com/torvalds/linux/commit/855b018325737f7691f9b7d86339df40aa4e47c3;Contradicts;0.5678927898406982
5862;If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.5311281681060791
5863;If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8458179831504822
5864;If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5334742665290833
5865;If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6182491779327393
5866;If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7631000280380249
5867;If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7445845007896423
5868;If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.5729683041572571
5869;If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.630638837814331
5870;accounting for a fourth would be better than for half of it;we could debate;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Contradicts;0.9914054870605468
5871;accounting for a fourth would be better than for half of it;we could debate;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7983367443084717
5872;accounting for a fourth would be better than for half of it;we could debate;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5113550424575806
5873;accounting for a fourth would be better than for half of it;we could debate;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6104653477668762
5874;accounting for a fourth would be better than for half of it;we could debate;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6733935475349426
5875;Stick to accounting for half;Significant improvement;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7277951836585999
5876;I added some more output;Users tend to be irritated by the choice of killed processes;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.6422294974327087
5877;I added some more output;Users tend to be irritated by the choice of killed processes;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5063566565513611
5878;Only account for half of childrens vm size in oom score calculation;This should still give the parent enough point in case of fork bombs;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5890641212463379
5879;Only account for half of childrens vm size in oom score calculation;This should still give the parent enough point in case of fork bombs;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.5024842619895935
5880;Only account for half of childrens vm size in oom score calculation;This should still give the parent enough point in case of fork bombs;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7029095888137817
5881;Only account for half of childrens vm size in oom score calculation;This should still give the parent enough point in case of fork bombs;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.7131689190864563
5882;Only account for half of childrens vm size in oom score calculation;This should still give the parent enough point in case of fork bombs;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5895708203315735
5883;Only account for half of childrens vm size in oom score calculation;This should still give the parent enough point in case of fork bombs;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5376302599906921
5884;Only account for half of childrens vm size in oom score calculation;This should still give the parent enough point in case of fork bombs;https://github.com/torvalds/linux/commit/9827b781f20828e5ceb911b879f268f78fe90815;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6053045988082886
5885;move the cpuset semaphore region outside the tasklist_lock region;The fix seems easy enough;https://github.com/torvalds/linux/commit/505970b96e3b7d22177c38e03435a68376628e7a;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5059950351715088
5886;move the cpuset semaphore region outside the tasklist_lock region;The fix seems easy enough;https://github.com/torvalds/linux/commit/505970b96e3b7d22177c38e03435a68376628e7a;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5415655970573425
5887;move the cpuset semaphore region outside the tasklist_lock region;The fix seems easy enough;https://github.com/torvalds/linux/commit/505970b96e3b7d22177c38e03435a68376628e7a;Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;Contradicts;0.6721149682998657
5888;move the cpuset semaphore region outside the tasklist_lock region;The fix seems easy enough;https://github.com/torvalds/linux/commit/505970b96e3b7d22177c38e03435a68376628e7a;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5754902362823486
5889;move the cpuset semaphore region outside the tasklist_lock region;The fix seems easy enough;https://github.com/torvalds/linux/commit/505970b96e3b7d22177c38e03435a68376628e7a;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8235582113265991
5890;The locking needs to be changed;The oom code where the locking needs to be changed does not have access to the cpuset locks, which are internal to kernel/cpuset.c only;https://github.com/torvalds/linux/commit/505970b96e3b7d22177c38e03435a68376628e7a;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Contradicts;0.5837277770042419
5891;The locking needs to be changed;The oom code where the locking needs to be changed does not have access to the cpuset locks, which are internal to kernel/cpuset.c only;https://github.com/torvalds/linux/commit/505970b96e3b7d22177c38e03435a68376628e7a;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.6335334181785583
5892;The locking needs to be changed;The oom code where the locking needs to be changed does not have access to the cpuset locks, which are internal to kernel/cpuset.c only;https://github.com/torvalds/linux/commit/505970b96e3b7d22177c38e03435a68376628e7a;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.6458547115325928
5893;Provide a couple more cpuset interface routines, available to the rest of the kernel;Take and drop the lock needed here (cpusets callback_sem);https://github.com/torvalds/linux/commit/505970b96e3b7d22177c38e03435a68376628e7a;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.5973823070526123
5894;Provide a couple more cpuset interface routines, available to the rest of the kernel;Take and drop the lock needed here (cpusets callback_sem);https://github.com/torvalds/linux/commit/505970b96e3b7d22177c38e03435a68376628e7a;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5936080813407898
5895;Provide a couple more cpuset interface routines, available to the rest of the kernel;Take and drop the lock needed here (cpusets callback_sem);https://github.com/torvalds/linux/commit/505970b96e3b7d22177c38e03435a68376628e7a;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6317731142044067
5896;Provide a couple more cpuset interface routines, available to the rest of the kernel;Take and drop the lock needed here (cpusets callback_sem);https://github.com/torvalds/linux/commit/505970b96e3b7d22177c38e03435a68376628e7a;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8421618342399597
5897;Provide a couple more cpuset interface routines, available to the rest of the kernel;Take and drop the lock needed here (cpusets callback_sem);https://github.com/torvalds/linux/commit/505970b96e3b7d22177c38e03435a68376628e7a;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5464449524879456
5898;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.5604125261306763
5899;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6643128395080566
5900;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.7305505871772766
5901;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5215539932250977
5902;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.6246518492698669
5903;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;introduce a dedicated system call to cover this use case;to cover this use case;https://github.com/torvalds/linux/commit/884a7e5964e06ed93c7771c0d7cf19c09a8946f1;Contradicts;0.7159638404846191
5904;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7988343238830566
5905;Theres no need to call schedule_timeout_interruptible();task must die ASAP;https://github.com/torvalds/linux/commit/2f659f462d2ab519068d0e2bb677d7a700decb8d;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5502303242683411
5906;replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;https://github.com/torvalds/linux/commit/dd0fc66fb33cd610bc1a5db8a5e232d34879b4d7;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.892270028591156
5907;replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;https://github.com/torvalds/linux/commit/dd0fc66fb33cd610bc1a5db8a5e232d34879b4d7;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5704082250595093
5908;replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;https://github.com/torvalds/linux/commit/dd0fc66fb33cd610bc1a5db8a5e232d34879b4d7;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.620158314704895
5909;replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;https://github.com/torvalds/linux/commit/dd0fc66fb33cd610bc1a5db8a5e232d34879b4d7;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7308333516120911
5910;replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;https://github.com/torvalds/linux/commit/dd0fc66fb33cd610bc1a5db8a5e232d34879b4d7;cap_safe_nice() only ever saw current, so now uses capable();only ever saw current, capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5097276568412781
5911;replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;https://github.com/torvalds/linux/commit/dd0fc66fb33cd610bc1a5db8a5e232d34879b4d7;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8118535876274109
5912;replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;https://github.com/torvalds/linux/commit/dd0fc66fb33cd610bc1a5db8a5e232d34879b4d7;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5215226411819458
5913;fix-up schedule_timeout() usage;fix-up;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.5513904690742493
5914;fix-up schedule_timeout() usage;fix-up;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5247470736503601
5915;fix-up schedule_timeout() usage;fix-up;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5655336976051331
5916;fix-up schedule_timeout() usage;fix-up;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5693501234054565
5917;fix-up schedule_timeout() usage;fix-up;https://github.com/torvalds/linux/commit/13e4b57f6a4e23ceb99794a650d777e74831f4a6;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6201377511024475
5918;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.6698786616325378
5919;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.50553959608078
5920;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6496789455413818
5921;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9623907804489136
5922;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5119917988777161
5923;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5053324103355408
5924;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6083032488822937
5925;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5903425216674805
5926;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5382394194602966
5927;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7291343212127686
5928;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5795361399650574
5929;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.6831978559494019
5930;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.8486196994781494
5931;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6432446837425232
5932;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7024502158164978
5933;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6549318432807922
5934;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6496902108192444
5935;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6968838572502136
5936;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;https://github.com/torvalds/linux/commit/8d060bf490930f305c4efc45724e861a268f4d2f;avoid attempting to kill init sharing same memory;avoid attempting to kill init;https://github.com/torvalds/linux/commit/a2b829d95958da2025ef844c0f53ac15ad720fac;Contradicts;0.5748445987701416
5937;By giving root tasks a bonus that is proportional to their actual size;they remain comparable even when relatively small;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.5253317356109619
5938;By giving root tasks a bonus that is proportional to their actual size;they remain comparable even when relatively small;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6060261726379395
5939;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.8590310215950012
5940;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Contradicts;0.6390157341957092
5941;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7468919157981873
5942;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5939203500747681
5943;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.8480185270309448
5944;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6707490682601929
5945;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5493355393409729
5946;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6396383047103882
5947;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5070335268974304
5948;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7288347482681274
5949;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;https://github.com/torvalds/linux/commit/778c14affaf94a9e4953179d3e13a544ccce7707;The oom killer does not want to defer in this case;there is no guarantee that thread will ever exit without intervention;https://github.com/torvalds/linux/commit/edd45544c6f09550df0a5491aa8a07af24767e73;Contradicts;0.9442152976989746
5950;prefer thread group leaders for display purposes;for display purposes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Contradicts;0.8625452518463135
5951;prefer thread group leaders for display purposes;for display purposes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7328338027000427
5952;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.6414614319801331
5953;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.9363251328468324
5954;it now iterates threads instead;leads to ambiguity;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7192018628120422
5955;it now iterates threads instead;leads to ambiguity;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7263768315315247
5956;it now iterates threads instead;leads to ambiguity;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Use a single linked list;Save a word in task_struct;https://github.com/torvalds/linux/commit/29c696e1c6eceb5db6b21f0c89495fcfcd40c0eb;Contradicts;0.5290002226829529
5957;it now iterates threads instead;leads to ambiguity;https://github.com/torvalds/linux/commit/d49ad9355420c743c736bfd1dee9eaa5b1a7722a;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.8325568437576294
5958;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;https://github.com/torvalds/linux/commit/4d4048be8a93769350efa31d2482a038b7de73d0;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.8661542534828186
5959;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;https://github.com/torvalds/linux/commit/4d4048be8a93769350efa31d2482a038b7de73d0;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6778280138969421
5960;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;https://github.com/torvalds/linux/commit/4d4048be8a93769350efa31d2482a038b7de73d0;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.554858386516571
5961;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;https://github.com/torvalds/linux/commit/4d4048be8a93769350efa31d2482a038b7de73d0;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5364030003547668
5962;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;https://github.com/torvalds/linux/commit/4d4048be8a93769350efa31d2482a038b7de73d0;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5612802505493164
5963;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Contradicts;0.6685500741004944
5964;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7689779996871948
5965;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7681190371513367
5966;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.6141361594200134
5967;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.7467575073242188
5968;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.7668012380599976
5969;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5214998722076416
5970;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.604353666305542
5971;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.565045177936554
5972;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.7423809766769409
5973;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.5887146592140198
5974;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.5531461834907532
5975;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;LSMs should use the new has_capability_noaudit() interface;The denials will not be recorded;https://github.com/torvalds/linux/commit/a2f2945a99057c7d44043465906c6bb63c3368a0;Contradicts;0.6453238129615784
5976;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.6593360900878906
5977;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5294775366783142
5978;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5104065537452698
5979;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.5949037671089172
5980;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5532113909721375
5981;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6010932326316833
5982;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.5682348012924194
5983;Add the necessary rcu_read_lock();necessary;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7521486878395081
5984;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7928029298782349
5985;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5091163516044617
5986;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.623002827167511
5987;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.966275990009308
5988;"we need ""bool ret"" and ""break""";we can not simply return from the loop;https://github.com/torvalds/linux/commit/ad96244179fbd55b40c00f10f399bc04739b8e1f;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.649662971496582
5989;Change oom_kill.c to use for_each_thread();rather than the racy while_each_thread() which can loop forever if we race with exit;https://github.com/torvalds/linux/commit/1da4db0cd5c8a31d4468ec906b413e75e604b465;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5111644864082336
5990;This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;https://github.com/torvalds/linux/commit/1da4db0cd5c8a31d4468ec906b413e75e604b465;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5920255780220032
5991;This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;https://github.com/torvalds/linux/commit/1da4db0cd5c8a31d4468ec906b413e75e604b465;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6294586062431335
5992;This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;https://github.com/torvalds/linux/commit/1da4db0cd5c8a31d4468ec906b413e75e604b465;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7065771222114563
5993;This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;https://github.com/torvalds/linux/commit/1da4db0cd5c8a31d4468ec906b413e75e604b465;This is really unlikely to make any observable difference;some microbenchmarks could benefit from one less branch that needs to be evaluated even though it almost never is true;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.7779878973960876
5994;convert it to atomic_long_t;to avoid races;https://github.com/torvalds/linux/commit/e1f56c89b040134add93f686931cc266541d239a;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5612635016441345
5995;changes the way tasks behave after detecting a memcg OOM;makes sure nobody loops or sleeps with locks held;https://github.com/torvalds/linux/commit/3812c8c8f3953921ef18544110dafc3505c1ac62;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Contradicts;0.5725010633468628
5996;changes the way tasks behave after detecting a memcg OOM;makes sure nobody loops or sleeps with locks held;https://github.com/torvalds/linux/commit/3812c8c8f3953921ef18544110dafc3505c1ac62;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.5443657040596008
5997;changes the way tasks behave after detecting a memcg OOM;makes sure nobody loops or sleeps with locks held;https://github.com/torvalds/linux/commit/3812c8c8f3953921ef18544110dafc3505c1ac62;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5702774524688721
5998;changes the way tasks behave after detecting a memcg OOM;makes sure nobody loops or sleeps with locks held;https://github.com/torvalds/linux/commit/3812c8c8f3953921ef18544110dafc3505c1ac62;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6641212105751038
5999;the OOM victim can not get stuck on locks the looping task may hold;this way;https://github.com/torvalds/linux/commit/3812c8c8f3953921ef18544110dafc3505c1ac62;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.7616190910339355
6000;the OOM victim can not get stuck on locks the looping task may hold;this way;https://github.com/torvalds/linux/commit/3812c8c8f3953921ef18544110dafc3505c1ac62;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.8129701614379883
6001;the OOM victim can not get stuck on locks the looping task may hold;this way;https://github.com/torvalds/linux/commit/3812c8c8f3953921ef18544110dafc3505c1ac62;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.6391871571540833
6002;the OOM victim can not get stuck on locks the looping task may hold;this way;https://github.com/torvalds/linux/commit/3812c8c8f3953921ef18544110dafc3505c1ac62;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.7231805324554443
6003;the OOM victim can not get stuck on locks the looping task may hold;this way;https://github.com/torvalds/linux/commit/3812c8c8f3953921ef18544110dafc3505c1ac62;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.5022029876708984
6004;no longer get stuck on any lock;a sleeping task may hold;https://github.com/torvalds/linux/commit/3812c8c8f3953921ef18544110dafc3505c1ac62;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5512015223503113
6005;Provide more precise dump info while memcg oom happening;more precise dump info;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Contradicts;0.5852569937705994
6006;Provide more precise dump info while memcg oom happening;more precise dump info;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5833776593208313
6007;Provide more precise dump info while memcg oom happening;more precise dump info;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9643287658691406
6008;Provide more precise dump info while memcg oom happening;more precise dump info;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.7041671872138977
6009;Provide more precise dump info while memcg oom happening;more precise dump info;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5952427983283997
6010;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5634943842887878
6011;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.6505390405654907
6012;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6700687408447266
6013;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;https://github.com/torvalds/linux/commit/58cf188ed649b6570dfdc9c62156cdf396c2e395;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;https://github.com/torvalds/linux/commit/337546e83fc7e50917f44846beee936abb9c9f1f;Contradicts;0.5639568567276001
6014;remove redundant sleep in pagefault oom handler;redundant sleep;https://github.com/torvalds/linux/commit/0fa84a4bfa2aac8c04d45351b40765d61e1fd20d;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Contradicts;0.5345351099967957
6015;remove redundant sleep in pagefault oom handler;redundant sleep;https://github.com/torvalds/linux/commit/0fa84a4bfa2aac8c04d45351b40765d61e1fd20d;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7758209705352783
6016;remove redundant sleep in pagefault oom handler;redundant sleep;https://github.com/torvalds/linux/commit/0fa84a4bfa2aac8c04d45351b40765d61e1fd20d;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5552211999893188
6017;cleanup pagefault oom handler;mm, oom;https://github.com/torvalds/linux/commit/efacd02e4f57d94e934ba5c84f10f8ce91158770;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.5093863606452942
6018;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.773921012878418
6019;use N_MEMORY instead;handle with the nodes which have memory,;https://github.com/torvalds/linux/commit/bd3a66c1cdf31274489cc1b5ace879695a5a1797;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.615772008895874
6020;Remove the unused arguments and update all callers.;unused.;https://github.com/torvalds/linux/commit/a72afd873089c697053e9daa85ff343b3140d2e7;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.5761751532554626
6021;Remove the unused arguments and update all callers.;unused.;https://github.com/torvalds/linux/commit/a72afd873089c697053e9daa85ff343b3140d2e7;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5670273900032043
6022;Remove the unused arguments and update all callers.;unused.;https://github.com/torvalds/linux/commit/a72afd873089c697053e9daa85ff343b3140d2e7;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6624510884284973
6023;Remove the unused arguments and update all callers.;unused.;https://github.com/torvalds/linux/commit/a72afd873089c697053e9daa85ff343b3140d2e7;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.8236684799194336
6024;Remove the unused arguments and update all callers.;unused.;https://github.com/torvalds/linux/commit/a72afd873089c697053e9daa85ff343b3140d2e7;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.6622216105461121
6025;Remove the unused arguments and update all callers.;unused.;https://github.com/torvalds/linux/commit/a72afd873089c697053e9daa85ff343b3140d2e7;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6639673709869385
6026;Remove the unused arguments and update all callers.;unused.;https://github.com/torvalds/linux/commit/a72afd873089c697053e9daa85ff343b3140d2e7;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.8214089870452881
6027;Remove the unused arguments and update all callers.;unused.;https://github.com/torvalds/linux/commit/a72afd873089c697053e9daa85ff343b3140d2e7;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.7269022464752197
6028;Remove the unused arguments and update all callers.;unused.;https://github.com/torvalds/linux/commit/a72afd873089c697053e9daa85ff343b3140d2e7;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.8144640922546387
6029;Remove unused start/end arguments from tlb_finish_mmu();unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6914559006690979
6030;Remove unused start/end arguments from tlb_finish_mmu();unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5275495648384094
6031;Remove unused start/end arguments from tlb_finish_mmu();unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6565945744514465
6032;Remove unused start/end arguments from tlb_finish_mmu();unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.6237158179283142
6033;Remove unused start/end arguments from tlb_finish_mmu();unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6912755370140076
6034;Remove the unused arguments and update all callers.;unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.5761751532554626
6035;Remove the unused arguments and update all callers.;unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5670273900032043
6036;Remove the unused arguments and update all callers.;unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6624510884284973
6037;Remove the unused arguments and update all callers.;unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.8236684799194336
6038;Remove the unused arguments and update all callers.;unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.6622216105461121
6039;Remove the unused arguments and update all callers.;unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6639673709869385
6040;Remove the unused arguments and update all callers.;unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.8214089870452881
6041;Remove the unused arguments and update all callers.;unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.7269022464752197
6042;Remove the unused arguments and update all callers.;unused;https://github.com/torvalds/linux/commit/ae8eba8b5d723a4ca543024b6e51f4d0f4fb6b6b;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.8144640922546387
6043;Show some helpful information;to indicate why this happens;https://github.com/torvalds/linux/commit/619b5b469bcab84ea3bee1d8d04451c781d23feb;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5998902320861816
6044;Show some helpful information;to indicate why this happens;https://github.com/torvalds/linux/commit/619b5b469bcab84ea3bee1d8d04451c781d23feb;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.7313597202301025
6045;Show some helpful information;to indicate why this happens;https://github.com/torvalds/linux/commit/619b5b469bcab84ea3bee1d8d04451c781d23feb;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7354815006256104
6046;make the calculation of oom badness more accurate;more accurate;https://github.com/torvalds/linux/commit/9066e5cfb73cdbcdbb49e87999482ab615e9fc76;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5256893634796143
6047;give the functions a kthread_ prefix;to better document the use case;https://github.com/torvalds/linux/commit/f5678e7f2ac31c270334b936352f0ef2fe7dd2b3;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5807777047157288
6048;give the functions a kthread_ prefix;to better document the use case;https://github.com/torvalds/linux/commit/f5678e7f2ac31c270334b936352f0ef2fe7dd2b3;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5295483469963074
6049;integrate them and add some comment to struct alloc_context;reduce future confusion about the meaning of this variable;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;delete the corresponding comment;it will be checked in oom_unkillable_task();https://github.com/torvalds/linux/commit/f8159c13905bba26f3e1782a521dacf7a66fc1ce;Contradicts;0.7278497815132141
6050;integrate them and add some comment to struct alloc_context;reduce future confusion about the meaning of this variable;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6173585653305054
6051;integrate them and add some comment to struct alloc_context;reduce future confusion about the meaning of this variable;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.868998110294342
6052;integrate them and add some comment to struct alloc_context;reduce future confusion about the meaning of this variable;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.6059597730636597
6053;The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;initialize it before;should;https://github.com/torvalds/linux/commit/432b1de0de02a83f64695e69a2d83cbee10c236f;Contradicts;0.5486068725585938
6054;The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5583140850067139
6055;The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.7646331787109375
6056;The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.9037548303604126
6057;The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7533637881278992
6058;The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6538087129592896
6059;The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6012656688690186
6060;The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.5554859638214111
6061;The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;name it appropriately;zone_scan_mutex is actually a spinlock;https://github.com/torvalds/linux/commit/c7d4caeb1d68d07f77cc09fc20b7759d6d7aa3b1;Contradicts;0.5505275130271912
6062;The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.5258193612098694
6063;The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;introduce a dedicated system call to cover this use case;to cover this use case;https://github.com/torvalds/linux/commit/884a7e5964e06ed93c7771c0d7cf19c09a8946f1;Contradicts;0.5394524931907654
6064;The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.8973857760429382
6065;The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5681116580963135
6066;The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.7229575514793396
6067;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.5687980651855469
6068;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6463018655776978
6069;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.5501276850700378
6070;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;https://github.com/torvalds/linux/commit/97a225e69a1f880886f33d2e65a7ace13f152caa;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6138355135917664
6071;dump stack of victim when reaping failed;reaping failed;https://github.com/torvalds/linux/commit/8a7ff02acabbd877669fecb0a2e75d0930b62c85;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5531250238418579
6072;fix pgtables units mismatch in Killed process message;pgtables units mismatch in Killed process message;https://github.com/torvalds/linux/commit/941f762bcb276259a78e7931674668874ccbda59;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.6052336692810059
6073;fix pgtables units mismatch in Killed process message;pgtables units mismatch in Killed process message;https://github.com/torvalds/linux/commit/941f762bcb276259a78e7931674668874ccbda59;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.5755288004875183
6074;fix pgtables units mismatch in Killed process message;pgtables units mismatch in Killed process message;https://github.com/torvalds/linux/commit/941f762bcb276259a78e7931674668874ccbda59;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5160834193229675
6075;fix pgtables units mismatch in Killed process message;pgtables units mismatch in Killed process message;https://github.com/torvalds/linux/commit/941f762bcb276259a78e7931674668874ccbda59;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5459012389183044
6076;Introduce two new options for madvise;To achieve the goal;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.7560105323791504
6077;Introduce two new options for madvise;To achieve the goal;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;remove a stale code;quick fixup;https://github.com/torvalds/linux/commit/9bfe5ded054b8e28a94c78580f233d6879a00146;Contradicts;0.675845742225647
6078;Introduce two new options for madvise;To achieve the goal;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6441007256507874
6079;Introduce two new options for madvise;To achieve the goal;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.7445802092552185
6080;Introduce two new options for madvise;To achieve the goal;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6906798481941223
6081;Introduce two new options for madvise;To achieve the goal;https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Use a single linked list;Save a word in task_struct;https://github.com/torvalds/linux/commit/29c696e1c6eceb5db6b21f0c89495fcfcd40c0eb;Contradicts;0.5408622026443481
6082;"
MADV_PAGEOUT is similar to MADV_DONTNEED 
MADV_COLD is similar to MADV_FREE 
";"
it hints the kernel that memory region is not currently needed and should be reclaimed immediately 
it hints the kernel that memory region is not currently needed and should be reclaimed when memory pressure rises";https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.8597894310951233
6083;"
MADV_PAGEOUT is similar to MADV_DONTNEED 
MADV_COLD is similar to MADV_FREE 
";"
it hints the kernel that memory region is not currently needed and should be reclaimed immediately 
it hints the kernel that memory region is not currently needed and should be reclaimed when memory pressure rises";https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6165996789932251
6084;"
MADV_PAGEOUT is similar to MADV_DONTNEED 
MADV_COLD is similar to MADV_FREE 
";"
it hints the kernel that memory region is not currently needed and should be reclaimed immediately 
it hints the kernel that memory region is not currently needed and should be reclaimed when memory pressure rises";https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.6225162148475647
6085;"
MADV_PAGEOUT is similar to MADV_DONTNEED 
MADV_COLD is similar to MADV_FREE 
";"
it hints the kernel that memory region is not currently needed and should be reclaimed immediately 
it hints the kernel that memory region is not currently needed and should be reclaimed when memory pressure rises";https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.7728106379508972
6086;"
MADV_PAGEOUT is similar to MADV_DONTNEED 
MADV_COLD is similar to MADV_FREE 
";"
it hints the kernel that memory region is not currently needed and should be reclaimed immediately 
it hints the kernel that memory region is not currently needed and should be reclaimed when memory pressure rises";https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6928316354751587
6087;"
MADV_PAGEOUT is similar to MADV_DONTNEED 
MADV_COLD is similar to MADV_FREE 
";"
it hints the kernel that memory region is not currently needed and should be reclaimed immediately 
it hints the kernel that memory region is not currently needed and should be reclaimed when memory pressure rises";https://github.com/torvalds/linux/commit/9c276cc65a58faf98be8e56962745ec99ab87636;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7130507230758667
6088;Add SPDX license identifier for missed files;SPDX license identifier for missed files;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Contradicts;0.9951748847961426
6089;Add SPDX license identifier for missed files;SPDX license identifier for missed files;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Contradicts;0.577992856502533
6090;Add SPDX license identifier for missed files;SPDX license identifier for missed files;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6399301886558533
6091;Add SPDX license identifier for missed files;SPDX license identifier for missed files;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5668523907661438
6092;Add SPDX license identifier for missed files;SPDX license identifier for missed files;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5636674165725708
6093;Add SPDX license identifier for missed files;SPDX license identifier for missed files;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7573792934417725
6094;Add SPDX license identifier for missed files;SPDX license identifier for missed files;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.528717041015625
6095;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.5749443173408508
6096;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5143738389015198
6097;Have no license information of any form;GPL v2 only;https://github.com/torvalds/linux/commit/457c89965399115e5cd8bf38f9c597293405703d;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.5210867524147034
6098;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.8816021680831909
6099;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.5408903360366821
6100;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5988070964813232
6101;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.8695103526115417
6102;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7734586596488953
6103;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5454232096672058
6104;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Contradicts;0.5038816332817078
6105;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.6806040406227112
6106;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Two of the instances of __capable() actually only act on current, and so have been changed to calls to capable();only act on current;https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5579596161842346
6107;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;cap_safe_nice() only ever saw current, so now uses capable();only ever saw current, capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.6382057070732117
6108;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.6399965882301331
6109;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.8123584389686584
6110;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.6468814611434937
6111;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5230274796485901
6112;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5875586867332458
6113;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.9125581979751588
6114;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5197116732597351
6115;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5236850380897522
6116;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.5457996129989624
6117;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.51259446144104
6118;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;LSMs should use the new has_capability_noaudit() interface;The denials will not be recorded;https://github.com/torvalds/linux/commit/a2f2945a99057c7d44043465906c6bb63c3368a0;Contradicts;0.7124930620193481
6119;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5574773550033569
6120;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;https://github.com/torvalds/linux/commit/6f4f13e8d9e27cefd2cd88dd4fd80aa6d68b9131;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5285601019859314
6121;Check if setting global init process to some memory cgroup is technically possible;Possible;https://github.com/torvalds/linux/commit/d342a0b38674867ea67fde47b0e1e60ffe9f17a2;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Contradicts;0.5038319230079651
6122;Check if setting global init process to some memory cgroup is technically possible;Possible;https://github.com/torvalds/linux/commit/d342a0b38674867ea67fde47b0e1e60ffe9f17a2;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Contradicts;0.6109524369239807
6123;Check if setting global init process to some memory cgroup is technically possible;Possible;https://github.com/torvalds/linux/commit/d342a0b38674867ea67fde47b0e1e60ffe9f17a2;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.8655750155448914
6124;Check if setting global init process to some memory cgroup is technically possible;Possible;https://github.com/torvalds/linux/commit/d342a0b38674867ea67fde47b0e1e60ffe9f17a2;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5518481731414795
6125;Check if setting global init process to some memory cgroup is technically possible;Possible;https://github.com/torvalds/linux/commit/d342a0b38674867ea67fde47b0e1e60ffe9f17a2;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5514537692070007
6126;Get/put across the for_each_thread() on the selected task;The easiest fix is;https://github.com/torvalds/linux/commit/cefc7ef3c87d02fc9307835868ff721ea12cc597;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.5484209060668945
6127;Get/put across the for_each_thread() on the selected task;The easiest fix is;https://github.com/torvalds/linux/commit/cefc7ef3c87d02fc9307835868ff721ea12cc597;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5281599164009094
6128;Get/put across the for_each_thread() on the selected task;The easiest fix is;https://github.com/torvalds/linux/commit/cefc7ef3c87d02fc9307835868ff721ea12cc597;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5241835117340088
6129;Get/put across the for_each_thread() on the selected task;The easiest fix is;https://github.com/torvalds/linux/commit/cefc7ef3c87d02fc9307835868ff721ea12cc597;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5103231072425842
6130;Fix this bug;"using an approach used by commit 855b018325737f76 (""oom, oom_reaper: disable oom_reaper for oom_kill_allocating_task"")";https://github.com/torvalds/linux/commit/9bcdeb51bd7d2ae9fe65ea4d60643d2aeef5bfe3;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.7597829699516296
6131;Fix this bug;"using an approach used by commit 855b018325737f76 (""oom, oom_reaper: disable oom_reaper for oom_kill_allocating_task"")";https://github.com/torvalds/linux/commit/9bcdeb51bd7d2ae9fe65ea4d60643d2aeef5bfe3;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6627119183540344
6132;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6338937282562256
6133;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.8909856081008911
6134;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.9835196137428284
6135;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5918724536895752
6136;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;https://github.com/torvalds/linux/commit/dc6c9a35b66b520cf67e05d8ca60ebecad3b0479;Contradicts;0.5463459491729736
6137;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.6812155246734619
6138;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.6421812772750854
6139;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Remove the parameter @mem;removed since v2.6.26;https://github.com/torvalds/linux/commit/fbdd12676c83df77480f00ebd32fc98fbe3bf836;Contradicts;0.8032146096229553
6140;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.5665648579597473
6141;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.8684118390083313
6142;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.7283949255943298
6143;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5088934302330017
6144;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.7264646291732788
6145;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5838228464126587
6146;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;https://github.com/torvalds/linux/commit/f0c867d9588d9efc10d6a55009c9560336673369;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6545549631118774
6147;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;Contradicts;0.572418212890625
6148;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6337102055549622
6149;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Contradicts;0.5774319171905518
6150;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5405638217926025
6151;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.7220926880836487
6152;An admin can easily get the full oom context at a single line;makes parsing much easier;https://github.com/torvalds/linux/commit/ef8444ea01d7442652f8e1b8a8b94278cb57eafd;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5753737092018127
6153;fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Contradicts;0.6092368364334106
6154;fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.6959314942359924
6155;fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.5178483128547668
6156;fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.6750118136405945
6157;fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.6810092329978943
6158;fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.540427565574646
6159;fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5775777697563171
6160;fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();https://github.com/torvalds/linux/commit/79cc81057eef7ad846588976296ab0f266c1a7a5;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6834834814071655
6161;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.8965762853622437
6162;Split oom_kill_process();With an intention to re-use the second half;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Use a single linked list;Save a word in task_struct;https://github.com/torvalds/linux/commit/29c696e1c6eceb5db6b21f0c89495fcfcd40c0eb;Contradicts;0.5314440131187439
6163;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7040598392486572
6164;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.8687471151351929
6165;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;"This is identical to the global oom killer and is done even before checking for panic_on_oom: a pending SIGKILL here while panic_on_oom is selected is guaranteed to have come from userspace; the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory.";the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.6136968731880188
6166;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5035992860794067
6167;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;https://github.com/torvalds/linux/commit/5989ad7b5ede38d605c588981f634c08252abfc3;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7864779233932495
6168;Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8067190051078796
6169;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.661819338798523
6170;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Contradicts;0.7743232250213623
6171;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.735478401184082
6172;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6155425906181335
6173;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5832074284553528
6174;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.8604175448417664
6175;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.7267062664031982
6176;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;delete the corresponding comment;it will be checked in oom_unkillable_task();https://github.com/torvalds/linux/commit/f8159c13905bba26f3e1782a521dacf7a66fc1ce;Contradicts;0.8771485090255737
6177;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.5039423108100891
6178;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.889455258846283
6179;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.6570083498954773
6180;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8891100883483887
6181;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;This patch fixes the issue by introducing a new MMF_OOM_KILLED mm flag which is set in oom_kill_process atomically and oom reaper is disabled if the flag was already set.;Fixes the issue by introducing a new MMF_OOM_KILLED mm flag and disabling the oom reaper if the flag was already set.;https://github.com/torvalds/linux/commit/855b018325737f7691f9b7d86339df40aa4e47c3;Contradicts;0.5890201926231384
6182;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5009163618087769
6183;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;https://github.com/torvalds/linux/commit/431f42fdfdb36f06f43c711fc59be9b814d8fb22;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.9569292068481444
6184;Add a small printk prior to the task dump informing;that the memory units are actually memory _pages_;https://github.com/torvalds/linux/commit/c3b78b11efbb2865433abf9d22c004ffe4a73f5c;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6181504130363464
6185;Add a small printk prior to the task dump informing;that the memory units are actually memory _pages_;https://github.com/torvalds/linux/commit/c3b78b11efbb2865433abf9d22c004ffe4a73f5c;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Contradicts;0.6082457304000854
6186;Add a small printk prior to the task dump informing;that the memory units are actually memory _pages_;https://github.com/torvalds/linux/commit/c3b78b11efbb2865433abf9d22c004ffe4a73f5c;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6437039375305176
6187;Add a small printk prior to the task dump informing;that the memory units are actually memory _pages_;https://github.com/torvalds/linux/commit/c3b78b11efbb2865433abf9d22c004ffe4a73f5c;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8392606377601624
6188;Add a small printk prior to the task dump informing;that the memory units are actually memory _pages_;https://github.com/torvalds/linux/commit/c3b78b11efbb2865433abf9d22c004ffe4a73f5c;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5648545026779175
6189;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.7001520991325378
6190;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;Contradicts;0.5169991254806519
6191;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5053622722625732
6192;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5826014280319214
6193;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.530213475227356
6194;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7062819004058838
6195;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7483444809913635
6196;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.513756513595581
6197;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;The oom killer does not want to defer in this case;there is no guarantee that thread will ever exit without intervention;https://github.com/torvalds/linux/commit/edd45544c6f09550df0a5491aa8a07af24767e73;Contradicts;0.5907673239707947
6198;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7283833026885986
6199;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.5736138224601746
6200;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;https://github.com/torvalds/linux/commit/af5679fbc669f31f7ebd0d473bca76c24c07de30;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7788926362991333
6201;Add comments describing oom_locks scope;describing oom_locks scope;https://github.com/torvalds/linux/commit/a195d3f5b74f3f45a6742f9063b5e95a2522b46d;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5503079295158386
6202;Add comments describing oom_locks scope;describing oom_locks scope;https://github.com/torvalds/linux/commit/a195d3f5b74f3f45a6742f9063b5e95a2522b46d;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7764147520065308
6203;Add comments describing oom_locks scope;describing oom_locks scope;https://github.com/torvalds/linux/commit/a195d3f5b74f3f45a6742f9063b5e95a2522b46d;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;https://github.com/torvalds/linux/commit/bc448e897b6d24aae32701763b8a1fe15d29fa26;Contradicts;0.5577956438064575
6204;Rename page_counter_limit() to page_counter_set_max();The idea behind this renaming is to have the direct matching between memory cgroup knobs (low, high, max) and page_counters API;https://github.com/torvalds/linux/commit/bbec2e15170aae3e084d7d9afc730aeebe01b654;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.644758403301239
6205;Rename page_counter_limit() to page_counter_set_max();The idea behind this renaming is to have the direct matching between memory cgroup knobs (low, high, max) and page_counters API;https://github.com/torvalds/linux/commit/bbec2e15170aae3e084d7d9afc730aeebe01b654;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5967257022857666
6206;Rename page_counter_limit() to page_counter_set_max();The idea behind this renaming is to have the direct matching between memory cgroup knobs (low, high, max) and page_counters API;https://github.com/torvalds/linux/commit/bbec2e15170aae3e084d7d9afc730aeebe01b654;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6444911360740662
6207;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.6104104518890381
6208;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.8196431398391724
6209;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.531347930431366
6210;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7621163129806519
6211;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;A kernel thread has been chosen;we need a reliable way of invocation so workqueue context is not appropriate because all the workers might be busy;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6051508784294128
6212;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;https://github.com/torvalds/linux/commit/27ae357fa82be5ab73b2ef8d39dcb8ca2563483a;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5084049105644226
6213;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Contradicts;0.6175389289855957
6214;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5823331475257874
6215;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.542204737663269
6216;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;Contradicts;0.6131740212440491
6217;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5073438286781311
6218;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6365644335746765
6219;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5318734049797058
6220;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;Add a missing newline;missing;https://github.com/torvalds/linux/commit/756a025f00091918d9d09ca3229defb160b409c0;Contradicts;0.5690721869468689
6221;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;adds MM_SHMEMPAGES counter to mm_rss_stat;to account for shmem pages separately from MM_FILEPAGES;https://github.com/torvalds/linux/commit/eca56ff906bdd0239485e8b47154a6e73dd9a2f3;Contradicts;0.5027051568031311
6222;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.613804280757904
6223;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6308150291442871
6224;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;https://github.com/torvalds/linux/commit/d46078b2888947a86b6bb997cd5927e602e8fdc9;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.509364664554596
6225;remove unnecessary locking in oom_enable();unnecessary locking in oom_enable();https://github.com/torvalds/linux/commit/3f5ab8cfbf15e8e02838ffc3549191351305df0e;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.5815238356590271
6226;remove unnecessary locking in oom_enable();unnecessary locking in oom_enable();https://github.com/torvalds/linux/commit/3f5ab8cfbf15e8e02838ffc3549191351305df0e;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6806057691574097
6227;remove unnecessary locking in oom_enable();unnecessary locking in oom_enable();https://github.com/torvalds/linux/commit/3f5ab8cfbf15e8e02838ffc3549191351305df0e;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6368354558944702
6228;fix typo in comment;typo in comment;https://github.com/torvalds/linux/commit/bdddbcd45fd191a0213e6d2a032eb55d18bd1fc0;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5355424880981445
6229;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;https://github.com/torvalds/linux/commit/dc6c9a35b66b520cf67e05d8ca60ebecad3b0479;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6170759797096252
6230;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;https://github.com/torvalds/linux/commit/dc6c9a35b66b520cf67e05d8ca60ebecad3b0479;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.5667733550071716
6231;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;https://github.com/torvalds/linux/commit/dc6c9a35b66b520cf67e05d8ca60ebecad3b0479;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7065311670303345
6232;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;https://github.com/torvalds/linux/commit/dc6c9a35b66b520cf67e05d8ca60ebecad3b0479;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8355444669723511
6233;make OOM detection in the freezer path raceless;raceless;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5175477862358093
6234;oom_killer_disabled check is moved from the allocation path to the OOM level;to take oom_sem for reading for both the check and the whole OOM invocation;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.7305984497070312
6235;oom_killer_disabled check is moved from the allocation path to the OOM level;to take oom_sem for reading for both the check and the whole OOM invocation;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5170135498046875
6236;oom_killer_disabled check is moved from the allocation path to the OOM level;to take oom_sem for reading for both the check and the whole OOM invocation;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.743354320526123
6237;oom_killer_disabled check is moved from the allocation path to the OOM level;to take oom_sem for reading for both the check and the whole OOM invocation;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5583233833312988
6238;it would be better and more robust to not rely on freezing points here;We used to have freezing points deep in file system code which may be reachable from page fault;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Contradicts;0.6048622131347656
6239;it would be better and more robust to not rely on freezing points here;We used to have freezing points deep in file system code which may be reachable from page fault;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;"This is identical to the global oom killer and is done even before checking for panic_on_oom: a pending SIGKILL here while panic_on_oom is selected is guaranteed to have come from userspace; the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory.";the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory;https://github.com/torvalds/linux/commit/f9434ad1552427fab49336e1a6e3ef121895b9d1;Contradicts;0.539008617401123
6240;it would be better and more robust to not rely on freezing points here;We used to have freezing points deep in file system code which may be reachable from page fault;https://github.com/torvalds/linux/commit/c32b3cbe0d067a9cfae85aa70ba1e97ceba0ced7;make the oom_reaper thread freezable;In order to close this race;https://github.com/torvalds/linux/commit/e26796066fdf929cbba22dabb801808f986acdb9;Contradicts;0.5258660316467285
6241;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5320193767547607
6242;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.5090171098709106
6243;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;detect threads that are in the exit path, specifically those with PF_EXITING set;to prevent needlessly killing additional tasks;https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5172286629676819
6244;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;https://github.com/torvalds/linux/commit/63a8ca9b2084fa5bd91aa380532f18e361764109;make the oom_reaper thread freezable;In order to close this race;https://github.com/torvalds/linux/commit/e26796066fdf929cbba22dabb801808f986acdb9;Contradicts;0.7264402508735657
6245;This patchset addresses a race;"which was described in the changelog for 5695be142e20 (""OOM, PM: OOM killed task shouldnt escape PM suspend"")";https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8475484251976013
6246;mark_tsk_oom_victim is now called under task_lock;I think this should be OK because __thaw_task shouldnt interfere with any locking down wake_up_process;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5578623414039612
6247;mark_tsk_oom_victim is now called under task_lock;I think this should be OK because __thaw_task shouldnt interfere with any locking down wake_up_process;https://github.com/torvalds/linux/commit/49550b605587924b3336386caae53200c68969d3;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6507502198219299
6248;reduce noise in show_mem for lowmem allocations;lowmem allocations;https://github.com/torvalds/linux/commit/974f4367dd315acc15ad4a6453f8304aea60dfbd;Reduce the ballast;Doesnt provide any relevant information;https://github.com/torvalds/linux/commit/974f4367dd315acc15ad4a6453f8304aea60dfbd;Contradicts;0.5881208777427673
6249;reduce noise in show_mem for lowmem allocations;lowmem allocations;https://github.com/torvalds/linux/commit/974f4367dd315acc15ad4a6453f8304aea60dfbd;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Contradicts;0.5040105581283569
6250;reduce noise in show_mem for lowmem allocations;lowmem allocations;https://github.com/torvalds/linux/commit/974f4367dd315acc15ad4a6453f8304aea60dfbd;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5545421242713928
6251;reduce noise in show_mem for lowmem allocations;lowmem allocations;https://github.com/torvalds/linux/commit/974f4367dd315acc15ad4a6453f8304aea60dfbd;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7567334771156311
6252;reduce noise in show_mem for lowmem allocations;lowmem allocations;https://github.com/torvalds/linux/commit/974f4367dd315acc15ad4a6453f8304aea60dfbd;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5043671727180481
6253;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.7505906820297241
6254;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.7574585676193237
6255;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Contradicts;0.8016742467880249
6256;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5204801559448242
6257;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7200504541397095
6258;Remove the oom_reaper from exit_mmap;make the code easier to read;https://github.com/torvalds/linux/commit/bf3980c85212fc71512d27a46f5aab66f46ca284;This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6191675066947937
6259;fix vm_oom_kill_table[];ifdeffery;https://github.com/torvalds/linux/commit/a19cad0691597eb79c123b8a19a9faba5ab7d90e;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5977173447608948
6260;removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5168602466583252
6261;update locked_vm accounting according to the munmapped vmas when munmapping;There is still a need to perform this action;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6773815751075745
6262;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;https://github.com/torvalds/linux/commit/a213e5cf71cbcea4b23caedcb8fe6629a333b275;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5660907030105591
6263;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;https://github.com/torvalds/linux/commit/ba535c1caf3ee78aa7719e9e4b07a0dc1d153b9e;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;https://github.com/torvalds/linux/commit/337546e83fc7e50917f44846beee936abb9c9f1f;Contradicts;0.6952609419822693
6264;Our container agent wants to know when a container exits if it was OOM killed or not;to report to the user;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5577144622802734
6265;OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Contradicts;0.5579057335853577
6266;OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.799543559551239
6267;OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5473006367683411
6268;OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.8739319443702698
6269;OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.5705015063285828
6270;OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9405930638313292
6271;OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.7611726522445679
6272;OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.6814369559288025
6273;OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;make the oom_reaper thread freezable;In order to close this race;https://github.com/torvalds/linux/commit/e26796066fdf929cbba22dabb801808f986acdb9;Contradicts;0.6438871026039124
6274;OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Use a single linked list;Save a word in task_struct;https://github.com/torvalds/linux/commit/29c696e1c6eceb5db6b21f0c89495fcfcd40c0eb;Contradicts;0.8309371471405029
6275;OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6190518140792847
6276;OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6222272515296936
6277;OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;adds MM_SHMEMPAGES counter to mm_rss_stat;to account for shmem pages separately from MM_FILEPAGES;https://github.com/torvalds/linux/commit/eca56ff906bdd0239485e8b47154a6e73dd9a2f3;Contradicts;0.7788538336753845
6278;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;https://github.com/torvalds/linux/commit/b6bf9abb0aa44e53ffe9c1e6e1d32568f5b25e4a;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8136938810348511
6279;Change __task_will_free_mem to test signal->core_state instead of the flag SIGNAL_GROUP_COREDUMP;In preparation for removing the flag SIGNAL_GROUP_COREDUMP;https://github.com/torvalds/linux/commit/98b24b16b2aebffabf5b8670f44f19666c1e029f;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Contradicts;0.522804319858551
6280;Change __task_will_free_mem to test signal->core_state instead of the flag SIGNAL_GROUP_COREDUMP;In preparation for removing the flag SIGNAL_GROUP_COREDUMP;https://github.com/torvalds/linux/commit/98b24b16b2aebffabf5b8670f44f19666c1e029f;Add a new flag PF_POSTCOREDUMP;so that tasks that have passed through coredump_task_exit can be recognized and ignored in zap_process;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.7347159385681152
6281;Change __task_will_free_mem to test signal->core_state instead of the flag SIGNAL_GROUP_COREDUMP;In preparation for removing the flag SIGNAL_GROUP_COREDUMP;https://github.com/torvalds/linux/commit/98b24b16b2aebffabf5b8670f44f19666c1e029f;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7638440132141113
6282;Change __task_will_free_mem to test signal->core_state instead of the flag SIGNAL_GROUP_COREDUMP;In preparation for removing the flag SIGNAL_GROUP_COREDUMP;https://github.com/torvalds/linux/commit/98b24b16b2aebffabf5b8670f44f19666c1e029f;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5045075416564941
6283;Change __task_will_free_mem to test signal->core_state instead of the flag SIGNAL_GROUP_COREDUMP;In preparation for removing the flag SIGNAL_GROUP_COREDUMP;https://github.com/torvalds/linux/commit/98b24b16b2aebffabf5b8670f44f19666c1e029f;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8822046518325806
6284;Change __task_will_free_mem to test signal->core_state instead of the flag SIGNAL_GROUP_COREDUMP;In preparation for removing the flag SIGNAL_GROUP_COREDUMP;https://github.com/torvalds/linux/commit/98b24b16b2aebffabf5b8670f44f19666c1e029f;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.838217556476593
6285;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;https://github.com/torvalds/linux/commit/3723929eb0f50e2101de739cdb66458a4f1f4b27;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6600924730300903
6286;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5697078108787537
6287;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7468487620353699
6288;This patch fixes the problem and should be backported into stable/LTS.;Fixes the problem, should be backported into stable/LTS.;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.5957701802253723
6289;This patch fixes the problem and should be backported into stable/LTS.;Fixes the problem, should be backported into stable/LTS.;https://github.com/torvalds/linux/commit/60e2793d440a3ec95abb5d6d4fc034a4b480472d;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.7741624712944031
6290;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;https://github.com/torvalds/linux/commit/337546e83fc7e50917f44846beee936abb9c9f1f;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.5747790336608887
6291;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;https://github.com/torvalds/linux/commit/337546e83fc7e50917f44846beee936abb9c9f1f;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.7766308188438416
6292;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;https://github.com/torvalds/linux/commit/337546e83fc7e50917f44846beee936abb9c9f1f;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.9390047192573548
6293;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;https://github.com/torvalds/linux/commit/337546e83fc7e50917f44846beee936abb9c9f1f;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5057668089866638
6294;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;https://github.com/torvalds/linux/commit/337546e83fc7e50917f44846beee936abb9c9f1f;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8417239189147949
6295;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;https://github.com/torvalds/linux/commit/337546e83fc7e50917f44846beee936abb9c9f1f;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5830438137054443
6296;This fix has considerable negative impact on process_mrelease performance;will likely need later optimization;https://github.com/torvalds/linux/commit/337546e83fc7e50917f44846beee936abb9c9f1f;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5068621039390564
6297;Print the tasks cpuset name for informational purposes;for informational purposes;https://github.com/torvalds/linux/commit/75aa199410359dc5fbcf9025ff7af98a9d20f0d5;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.7662755250930786
6298;Print the tasks cpuset name for informational purposes;for informational purposes;https://github.com/torvalds/linux/commit/75aa199410359dc5fbcf9025ff7af98a9d20f0d5;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.9422451853752136
6299;Print the tasks cpuset name for informational purposes;for informational purposes;https://github.com/torvalds/linux/commit/75aa199410359dc5fbcf9025ff7af98a9d20f0d5;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5289375185966492
6300;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;https://github.com/torvalds/linux/commit/1c0fe6e3bda0464728c23c8d84aa47567e8b716c;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.8089017271995544
6301;LSMs should use the new has_capability_noaudit() interface;The denials will not be recorded;https://github.com/torvalds/linux/commit/a2f2945a99057c7d44043465906c6bb63c3368a0;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5242573022842407
6302;LSMs should use the new has_capability_noaudit() interface;The denials will not be recorded;https://github.com/torvalds/linux/commit/a2f2945a99057c7d44043465906c6bb63c3368a0;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6779041886329651
6303;dump task state information for thread group leaders;When /proc/sys/vm/oom_dump_tasks is enabled, its only necessary;https://github.com/torvalds/linux/commit/b4416d2bea007f07f2e74cdc4cb64042ec996c83;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5966613292694092
6304;dump task state information for thread group leaders;When /proc/sys/vm/oom_dump_tasks is enabled, its only necessary;https://github.com/torvalds/linux/commit/b4416d2bea007f07f2e74cdc4cb64042ec996c83;considered a reasonable constrain;the overall system health is more important than debugability of a particular application;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7755119204521179
6305;Two of the instances of __capable() actually only act on current, and so have been changed to calls to capable();only act on current;https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;cap_safe_nice() only ever saw current, so now uses capable();only ever saw current, capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Contradicts;0.60219806432724
6306;Two of the instances of __capable() actually only act on current, and so have been changed to calls to capable();only act on current;https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.5143002867698669
6307;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6129467487335205
6308;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;A kernel thread has been chosen;we need a reliable way of invocation so workqueue context is not appropriate because all the workers might be busy;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.504116952419281
6309;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7144358158111572
6310;allow privileged processes to receive SIGIO on files theyre manipulating;privileged processes;https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6562844514846802
6311;allow privileged processes to receive SIGIO on files theyre manipulating;privileged processes;https://github.com/torvalds/linux/commit/5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5722489356994629
6312;Introduce a struct zoneref to store a zone pointer and a zone index;Store a zone pointer and a zone index;https://github.com/torvalds/linux/commit/dd1a239f6f2d4d3eedd318583ec319aa145b324c;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7923154830932617
6313;Introduce a struct zoneref to store a zone pointer and a zone index;Store a zone pointer and a zone index;https://github.com/torvalds/linux/commit/dd1a239f6f2d4d3eedd318583ec319aa145b324c;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.6202539801597595
6314;fallback allocations when the target/preferred node has no free pages;target/preferred node has no free pages;https://github.com/torvalds/linux/commit/54a6eb5c4765aa573a030ceeba2c14e3d2ea5706;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.90188729763031
6315;fallback allocations when the target/preferred node has no free pages;target/preferred node has no free pages;https://github.com/torvalds/linux/commit/54a6eb5c4765aa573a030ceeba2c14e3d2ea5706;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.6013736128807068
6316;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.586496114730835
6317;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6234500408172607
6318;This fixes an unimportant bug where PIDTYPE_PID is used whereas PIDTYPE_TGID should have been used.;unimportant;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Contradicts;0.6542985439300537
6319;This fixes an unimportant bug where PIDTYPE_PID is used whereas PIDTYPE_TGID should have been used.;unimportant;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.8308591246604919
6320;This fixes an unimportant bug where PIDTYPE_PID is used whereas PIDTYPE_TGID should have been used.;unimportant;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.6891096234321594
6321;This fixes an unimportant bug where PIDTYPE_PID is used whereas PIDTYPE_TGID should have been used.;unimportant;https://github.com/torvalds/linux/commit/ee9955d61a0a770152f9c3af470bd1689f034c74;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8414263129234314
6322;This ensures that an accurate copy of the process can be captured in the coredump;no cleanup for the process happens before the coredump completes;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Contradicts;0.7529974579811096
6323;This ensures that an accurate copy of the process can be captured in the coredump;no cleanup for the process happens before the coredump completes;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7121864557266235
6324;This ensures that an accurate copy of the process can be captured in the coredump;no cleanup for the process happens before the coredump completes;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5033921003341675
6325;ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6416562795639038
6326;ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;Contradicts;0.6490075588226318
6327;ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8604398369789124
6328;ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;skip zombies when iterating tasklist;oom;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;Contradicts;0.5165637135505676
6329;Add a new flag PF_POSTCOREDUMP;so that tasks that have passed through coredump_task_exit can be recognized and ignored in zap_process;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;remove the prototype for the old function;the prototype still existed;https://github.com/torvalds/linux/commit/11239836c04b50ba8453ec58ca7a7bd716ef02c1;Contradicts;0.6295884847640991
6330;Add a new flag PF_POSTCOREDUMP;so that tasks that have passed through coredump_task_exit can be recognized and ignored in zap_process;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5272482633590698
6331;Add a new flag PF_POSTCOREDUMP;so that tasks that have passed through coredump_task_exit can be recognized and ignored in zap_process;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7223788499832153
6332;Add a new flag PF_POSTCOREDUMP;so that tasks that have passed through coredump_task_exit can be recognized and ignored in zap_process;https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6316403150558472
6333;"Replace ""may_ptrace_stop()"" with a simple test of ""current->ptrace""";"a simple test of ""current->ptrace"" is more efficient and clear";https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.5746737122535706
6334;"Replace ""may_ptrace_stop()"" with a simple test of ""current->ptrace""";"a simple test of ""current->ptrace"" is more efficient and clear";https://github.com/torvalds/linux/commit/92307383082daff5df884a25df9e283efb7ef261;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.8193113803863525
6335;This way the memory is freed in a more controllable way with CPU affinity and priority of the caller;more controllable way with CPU affinity and priority of the caller;https://github.com/torvalds/linux/commit/884a7e5964e06ed93c7771c0d7cf19c09a8946f1;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.655906081199646
6336;introduce a dedicated system call to cover this use case;to cover this use case;https://github.com/torvalds/linux/commit/884a7e5964e06ed93c7771c0d7cf19c09a8946f1;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.7454710006713867
6337;introduce a dedicated system call to cover this use case;to cover this use case;https://github.com/torvalds/linux/commit/884a7e5964e06ed93c7771c0d7cf19c09a8946f1;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5580883622169495
6338;Rename the function to make that purpose explicit;The oom proper is the only existing user;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.6152234673500061
6339;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5422006249427795
6340;The final code can be reduced to a check for MPOL_BIND;MPOL_BIND is the only memory policy that is a hard requirement and thus relevant to a constrained OOM logic;https://github.com/torvalds/linux/commit/b26e517a058bd40c790a1d9868c896842f2e4155;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5165365934371948
6341;Fix typo in comment: kthead -> kthread;typo;https://github.com/torvalds/linux/commit/4c9c3809ae2ecfcece9acb3f51427e617d21fafb;delete the corresponding comment;it will be checked in oom_unkillable_task();https://github.com/torvalds/linux/commit/f8159c13905bba26f3e1782a521dacf7a66fc1ce;Contradicts;0.5880420207977295
6342;Fix typo in comment: kthead -> kthread;typo;https://github.com/torvalds/linux/commit/4c9c3809ae2ecfcece9acb3f51427e617d21fafb;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8515148162841797
6343;fix typos in comments;typos in comments;https://github.com/torvalds/linux/commit/f0953a1bbaca71e1ebbcb9864eb1b273156157ed;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5079925656318665
6344;Fix ~94 single-word typos in locking code comments, plus a few very obvious grammar mistakes.;Improve code quality and readability.;https://github.com/torvalds/linux/commit/f0953a1bbaca71e1ebbcb9864eb1b273156157ed;Kill it and directly access;directly access;https://github.com/torvalds/linux/commit/d21142ece414ce1088cfcae760689aa60d6fee80;Contradicts;0.6804373264312744
6345;Fix ~94 single-word typos in locking code comments, plus a few very obvious grammar mistakes.;Improve code quality and readability.;https://github.com/torvalds/linux/commit/f0953a1bbaca71e1ebbcb9864eb1b273156157ed;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.8522428870201111
6346;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;https://github.com/torvalds/linux/commit/72788c385604523422592249c19cba0187021e9b;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Contradicts;0.5036665797233582
6347;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5048859715461731
6348;Architectures that implement their own show_mem() actually dont do anything with the argument yet, but they could be made to filter nodes that arent allowed in the current context in the future just like the generic implementation.;They could be made to filter nodes that arent allowed in the current context in the future just like the generic implementation.;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;https://github.com/torvalds/linux/commit/ddd588b5dd55f14320379961e47683db4e4c1d90;Contradicts;0.5700886249542236
6349;Architectures that implement their own show_mem() actually dont do anything with the argument yet, but they could be made to filter nodes that arent allowed in the current context in the future just like the generic implementation.;They could be made to filter nodes that arent allowed in the current context in the future just like the generic implementation.;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Contradicts;0.5228818655014038
6350;Architectures that implement their own show_mem() actually dont do anything with the argument yet, but they could be made to filter nodes that arent allowed in the current context in the future just like the generic implementation.;They could be made to filter nodes that arent allowed in the current context in the future just like the generic implementation.;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5927456021308899
6351;Architectures that implement their own show_mem() actually dont do anything with the argument yet, but they could be made to filter nodes that arent allowed in the current context in the future just like the generic implementation.;They could be made to filter nodes that arent allowed in the current context in the future just like the generic implementation.;https://github.com/torvalds/linux/commit/b2b755b5f10eb32fbdc73a9907c07006b17f714b;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.7071848511695862
6352;Find kill other threads that pin the same ->mm or find another task to kill.;Memory needs to be freed.;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;make the oom_reaper thread freezable;In order to close this race;https://github.com/torvalds/linux/commit/e26796066fdf929cbba22dabb801808f986acdb9;Contradicts;0.6014081239700317
6353;Find kill other threads that pin the same ->mm or find another task to kill.;Memory needs to be freed.;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5770525336265564
6354;Find kill other threads that pin the same ->mm or find another task to kill.;Memory needs to be freed.;https://github.com/torvalds/linux/commit/30e2b41f20b6238f51e7cffb879c7a0f0073f5fe;avoid attempting to kill init sharing same memory;avoid attempting to kill init;https://github.com/torvalds/linux/commit/a2b829d95958da2025ef844c0f53ac15ad720fac;Contradicts;0.7792028188705444
6355;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);https://github.com/torvalds/linux/commit/3a5dda7a17cf3706f79b86293f29db02d61e0d48;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.6862335205078125
6356;make the oom_reaper thread freezable;In order to close this race;https://github.com/torvalds/linux/commit/e26796066fdf929cbba22dabb801808f986acdb9;A kernel thread has been chosen;we need a reliable way of invocation so workqueue context is not appropriate because all the workers might be busy;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.883894681930542
6357;Use a single linked list;Save a word in task_struct;https://github.com/torvalds/linux/commit/29c696e1c6eceb5db6b21f0c89495fcfcd40c0eb;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5233929753303528
6358;This patch fixes the issue by introducing a new MMF_OOM_KILLED mm flag which is set in oom_kill_process atomically and oom reaper is disabled if the flag was already set.;Fixes the issue by introducing a new MMF_OOM_KILLED mm flag and disabling the oom reaper if the flag was already set.;https://github.com/torvalds/linux/commit/855b018325737f7691f9b7d86339df40aa4e47c3;This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.816350519657135
6359;This patch fixes the issue by introducing a new MMF_OOM_KILLED mm flag which is set in oom_kill_process atomically and oom reaper is disabled if the flag was already set.;Fixes the issue by introducing a new MMF_OOM_KILLED mm flag and disabling the oom reaper if the flag was already set.;https://github.com/torvalds/linux/commit/855b018325737f7691f9b7d86339df40aa4e47c3;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Contradicts;0.5249038934707642
6360;This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;Add a missing newline;missing;https://github.com/torvalds/linux/commit/756a025f00091918d9d09ca3229defb160b409c0;Contradicts;0.5209917426109314
6361;This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;avoid attempting to kill init sharing same memory;avoid attempting to kill init;https://github.com/torvalds/linux/commit/a2b829d95958da2025ef844c0f53ac15ad720fac;Contradicts;0.92942476272583
6362;"Users of mmap_sem which need it for write should be carefully reviewed to use _killable waiting as much as possible and reduce allocations requests done with the lock held to absolute minimum
";to reduce the risk even further;https://github.com/torvalds/linux/commit/aac453635549699c13a84ea1456d5b0e574ef855;adds MM_SHMEMPAGES counter to mm_rss_stat;to account for shmem pages separately from MM_FILEPAGES;https://github.com/torvalds/linux/commit/eca56ff906bdd0239485e8b47154a6e73dd9a2f3;Contradicts;0.5286574959754944
