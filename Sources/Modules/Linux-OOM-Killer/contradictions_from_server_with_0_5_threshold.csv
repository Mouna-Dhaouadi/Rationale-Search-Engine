Decision1;Rationale1;Decision2;Rationale2;Relationship;Alpha
speed up select_bad_process() loop;mm, oom;Only oom kill exiting tasks with attached memory;oom;Contradicts;0.5990683436393738
speed up select_bad_process() loop;mm, oom;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Contradicts;0.5752081274986267
speed up select_bad_process() loop;mm, oom;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.6709030866622925
speed up select_bad_process() loop;mm, oom;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Contradicts;0.5062636733055115
speed up select_bad_process() loop;mm, oom;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.6405929923057556
speed up select_bad_process() loop;mm, oom;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5546959638595581
speed up select_bad_process() loop;mm, oom;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6090050935745239
speed up select_bad_process() loop;mm, oom;fix constraint deadlock;constraint deadlock;Contradicts;0.7066870927810669
speed up select_bad_process() loop;mm, oom;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.6512245535850525
speed up select_bad_process() loop;mm, oom;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5625301003456116
speed up select_bad_process() loop;mm, oom;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5166118741035461
speed up select_bad_process() loop;mm, oom;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8962968587875366
speed up select_bad_process() loop;mm, oom;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6939772367477417
speed up select_bad_process() loop;mm, oom;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5617384910583496
speed up select_bad_process() loop;mm, oom;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8040061593055725
speed up select_bad_process() loop;mm, oom;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5710026025772095
speed up select_bad_process() loop;mm, oom;mm locking fix;oom-kill;Contradicts;0.5820884704589844
speed up select_bad_process() loop;mm, oom;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5238509178161621
speed up select_bad_process() loop;mm, oom;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7834425568580627
speed up select_bad_process() loop;mm, oom;Fix it up via task_lock();instead;Contradicts;0.5637125968933105
speed up select_bad_process() loop;mm, oom;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.6272343993186951
speed up select_bad_process() loop;mm, oom;dump stack of victim when reaping failed;reaping failed;Contradicts;0.5102951526641846
speed up select_bad_process() loop;mm, oom;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.547498345375061
speed up select_bad_process() loop;mm, oom;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5240192413330078
speed up select_bad_process() loop;mm, oom;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.505247175693512
speed up select_bad_process() loop;mm, oom;skip zombies when iterating tasklist;oom;Contradicts;0.5156200528144836
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.894819974899292
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.7321236729621887
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5378387570381165
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.8434686064720154
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;Remove the count;Its better to remove the count;Contradicts;0.7474036812782288
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.8528431057929993
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5126088261604309
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5125724673271179
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6142014265060425
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8256665468215942
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6335657835006714
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.8719528317451477
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6679354310035706
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7692376375198364
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5861647725105286
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.646752655506134
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.6140869855880737
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.5322325229644775
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;Have no license information of any form;GPL v2 only;Contradicts;0.816951334476471
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7478606104850769
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.550162672996521
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5154388546943665
Track number of TIF_MEMDIE threads inside signal_struct;We dont need to do TIF_MEMDIE test on each thread;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6141901016235352
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Contradicts;0.7822984457015991
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);Contradicts;0.9945105314254761
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Contradicts;0.9556928277015686
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Kill current;It is better than another task needlessly.;Contradicts;0.6125971078872681
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;Contradicts;0.7391332387924194
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";Contradicts;0.5282205939292908
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;Contradicts;0.9155578017234802
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Only oom kill exiting tasks with attached memory;oom;Contradicts;0.8485736846923828
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;Contradicts;0.8728078007698059
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;Contradicts;0.875335693359375
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();There is no need to call for int_sqrt;if argument is 0;Contradicts;0.8288981318473816
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Use printk_ratelimit();to quieten it;Contradicts;0.6326473355293274
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.7601117491722107
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();kill duplicate OOM_DISABLE check;duplicate;Contradicts;0.5188351273536682
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();put those freeable pages in inactive file LRU;it would make sense to;Contradicts;0.5597824454307556
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;Contradicts;0.5640569925308228
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;Contradicts;0.5329278707504272
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();remove redundant task_in_mem_cgroup() check;redundant;Contradicts;0.917155921459198
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Contradicts;0.5098869204521179
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;Contradicts;0.5669341087341309
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.8596396446228027
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.7071806192398071
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Remove this dubious PF_EXITING check;dubious;Contradicts;0.8744167685508728
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Contradicts;0.7158554196357727
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Contradicts;0.6721364259719849
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.7061522006988525
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.6154334545135498
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Share the same oom_score_adj;As a result;Contradicts;0.5138040781021118
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();force oom kill on sysrq+f;oom;Contradicts;0.6652995347976685
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.7774709463119507
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.6538623571395874
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;Contradicts;0.5288402438163757
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;Contradicts;0.9238361716270447
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.9981389045715332
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Remove the count;Its better to remove the count;Contradicts;0.9986255168914795
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;Contradicts;0.5007063746452332
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();remove deprecated oom_adj;deprecated;Contradicts;0.8045188188552856
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.6298248767852783
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Fix this by always printing the nodemask;always printing the nodemask;Contradicts;0.6960492730140686
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.5661903023719788
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.9806713461875916
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;Contradicts;0.5008293986320496
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.9362782835960388
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.710712194442749
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Introduce is_init;to capture this case;Contradicts;0.505039393901825
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Contradicts;0.706887423992157
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.786687970161438
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();panic ASAP;want failover;Contradicts;0.5328000783920288
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.9122530221939087
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;Contradicts;0.7724829316139221
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.9121739268302917
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;Contradicts;0.6550315618515015
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.5796716213226318
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;Contradicts;0.5725714564323425
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;Contradicts;0.6003844738006592
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;Contradicts;0.584601640701294
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.9694297909736633
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();remove the wrong check along with pr_info();wrong check along with pr_info();Contradicts;0.8814011812210083
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.581727921962738
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();remove unnecessary variable;unnecessary;Contradicts;0.5319815278053284
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.9510989189147949
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7292488813400269
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.8364743590354919
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Contradicts;0.7165673971176147
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9982798099517822
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.7761568427085876
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();remove pointless kthread_run() error check;pointless;Contradicts;0.7682705521583557
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6767060160636902
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.8266218304634094
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.9411827921867371
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;Contradicts;0.5618190765380859
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.7750676274299622
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;Contradicts;0.5855803489685059
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();remove task_t, convert to struct task_struct;cleanup, remove;Contradicts;0.9311471581459045
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.9535442590713501
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7854273319244385
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.7406228184700012
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.8235911130905151
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;Contradicts;0.5277389883995056
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8539357781410217
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();remove unnecessary exit_state check;unnecessary;Contradicts;0.6647443175315857
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Fix it up via task_lock();instead;Contradicts;0.671226441860199
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.8897309899330139
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.7547094225883484
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.747614324092865
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Stick to accounting for half;Significant improvement;Contradicts;0.7296482920646667
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.633201003074646
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.6711586713790894
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();it now iterates threads instead;leads to ambiguity;Contradicts;0.6646363735198975
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5955362319946289
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Add the necessary rcu_read_lock();necessary;Contradicts;0.5671178698539734
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.6701342463493347
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Change oom_kill.c to use for_each_thread();rather than the racy while_each_thread() which can loop forever if we race with exit;Contradicts;0.6966086626052856
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.9218712449073792
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.838927686214447
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6911022067070007
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.6084901690483093
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Have no license information of any form;GPL v2 only;Contradicts;0.8836236000061035
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.55525803565979
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5211588740348816
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.8902783989906311
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.7640795707702637
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;Contradicts;0.5905908942222595
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.838307797908783
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.8089990019798279
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;Contradicts;0.8156700134277344
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6664442420005798
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.681914210319519
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.800771951675415
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;Contradicts;0.6448466777801514
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();delete unlock_range();exit_mmap() does not need locked_vm updates;Contradicts;0.5135859251022339
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;Contradicts;0.6274981498718262
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Change __task_will_free_mem to test signal->core_state instead of the flag SIGNAL_GROUP_COREDUMP;In preparation for removing the flag SIGNAL_GROUP_COREDUMP;Contradicts;0.5864359736442566
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.6249017715454102
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.5702596306800842
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Remove the parameter @mem;removed since v2.6.26;Contradicts;0.9767622351646423
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.6773090362548828
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Introduce a struct zoneref to store a zone pointer and a zone index;Store a zone pointer and a zone index;Contradicts;0.69687819480896
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;Contradicts;0.5597879886627197
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.8495542407035828
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.8241966366767883
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();remove the prototype for the old function;the prototype still existed;Contradicts;0.8366668224334717
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Kill it and directly access;directly access;Contradicts;0.972334623336792
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.8379882574081421
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.9572837948799133
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5674243569374084
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7332208752632141
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Use a single linked list;Save a word in task_struct;Contradicts;0.6775363683700562
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();This patch fixes the issue by introducing a new MMF_OOM_KILLED mm flag which is set in oom_kill_process atomically and oom reaper is disabled if the flag was already set.;Fixes the issue by introducing a new MMF_OOM_KILLED mm flag and disabling the oom reaper if the flag was already set.;Contradicts;0.5614741444587708
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5392852425575256
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.8690351843833923
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();adds MM_SHMEMPAGES counter to mm_rss_stat;to account for shmem pages separately from MM_FILEPAGES;Contradicts;0.8885346055030823
strive for making this context as reliable and independent on other subsystems;as much as possible;Kill current;It is better than another task needlessly.;Contradicts;0.6727662086486816
strive for making this context as reliable and independent on other subsystems;as much as possible;Only oom kill exiting tasks with attached memory;oom;Contradicts;0.5989738702774048
strive for making this context as reliable and independent on other subsystems;as much as possible;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.7776078581809998
strive for making this context as reliable and independent on other subsystems;as much as possible;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.7160595655441284
strive for making this context as reliable and independent on other subsystems;as much as possible;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.7554869651794434
strive for making this context as reliable and independent on other subsystems;as much as possible;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5932019948959351
strive for making this context as reliable and independent on other subsystems;as much as possible;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.511362612247467
strive for making this context as reliable and independent on other subsystems;as much as possible;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.5024238228797913
strive for making this context as reliable and independent on other subsystems;as much as possible;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5835567116737366
strive for making this context as reliable and independent on other subsystems;as much as possible;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7124754190444946
strive for making this context as reliable and independent on other subsystems;as much as possible;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7510360479354858
strive for making this context as reliable and independent on other subsystems;as much as possible;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5931209921836853
strive for making this context as reliable and independent on other subsystems;as much as possible;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.7210493087768555
strive for making this context as reliable and independent on other subsystems;as much as possible;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7767588496208191
strive for making this context as reliable and independent on other subsystems;as much as possible;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6712334156036377
strive for making this context as reliable and independent on other subsystems;as much as possible;Have no license information of any form;GPL v2 only;Contradicts;0.5246307253837585
strive for making this context as reliable and independent on other subsystems;as much as possible;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5230076313018799
strive for making this context as reliable and independent on other subsystems;as much as possible;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.7168590426445007
strive for making this context as reliable and independent on other subsystems;as much as possible;Kill it and directly access;directly access;Contradicts;0.9396885633468628
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);Contradicts;0.9966832995414734
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Contradicts;0.7578295469284058
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;ruling out the OOM killer;lockup machine in most of the cases;Contradicts;0.9638046622276306
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Kill current;It is better than another task needlessly.;Contradicts;0.5941295027732849
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;Contradicts;0.6349170804023743
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;Contradicts;0.5174017548561096
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";Contradicts;0.5088992714881897
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;Contradicts;0.9203083515167236
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;Contradicts;0.5816338062286377
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;Contradicts;0.5086758732795715
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.8544471263885498
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Use printk_ratelimit();to quieten it;Contradicts;0.7229362726211548
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.596187949180603
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;dont try to kill oom_unkillable child;oom_unkillable;Contradicts;0.8181211948394775
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;Contradicts;0.8255009055137634
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;remove redundant task_in_mem_cgroup() check;redundant;Contradicts;0.676793098449707
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6173444390296936
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Issue a SIGKILL to any thread sharing the same mm;Were safe;Contradicts;0.5264031887054443
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;make it as simple and predictable as possible;so the results are better understood and we end up killing the task which will lead to the most memory freeing while still respecting the fine-tuning from userspace;Contradicts;0.6478832364082336
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Remove this dubious PF_EXITING check;dubious;Contradicts;0.9507530331611633
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Using SCHED_FIFO:1 with the lowest RT priority;This task wont interfere with any running RT task;Contradicts;0.5797135233879089
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.9361679553985596
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;Contradicts;0.9911165237426758
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Share the same oom_score_adj;As a result;Contradicts;0.7898758053779602
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6116501688957214
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;Contradicts;0.767618715763092
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.9738510847091675
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Remove the count;Its better to remove the count;Contradicts;0.9439813494682312
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;Contradicts;0.5319575667381287
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;remove deprecated oom_adj;deprecated;Contradicts;0.8621535301208496
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.5464189052581787
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.8402546048164368
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;SIGBUS is triggered;the flag is set;Contradicts;0.5544295907020569
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.8213157653808594
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;Contradicts;0.8245332837104797
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;do not attempt to reap a task twice;do not attempt to reap a task twice;Contradicts;0.5731094479560852
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.9006791710853577
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.6431556344032288
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.8117415904998779
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Introduce is_init;to capture this case;Contradicts;0.9475558996200562
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Contradicts;0.5613440871238708
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.5072160363197327
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.7852793335914612
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.6834812164306641
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.8454820513725281
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.9779118299484253
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;Contradicts;0.5510949492454529
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.6284799575805664
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;Contradicts;0.7982139587402344
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.987362265586853
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Introduce is_sysrq_oom helper function;to improve readability;Contradicts;0.6132139563560486
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;remove the wrong check along with pr_info();wrong check along with pr_info();Contradicts;0.8091573119163513
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5316396355628967
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;remove unnecessary variable;unnecessary;Contradicts;0.6552190780639648
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.7368077635765076
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6543951034545898
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5876936316490173
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9813884496688843
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.7786041498184204
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;remove pointless kthread_run() error check;pointless;Contradicts;0.7495121359825134
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.8148419260978699
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.6188775300979614
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.7575823664665222
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;hold tasklist_lock;tsk->sighand is not guarded by RCU, just as what out_of_memory() does.;Contradicts;0.6349077820777893
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;Contradicts;0.7714052796363831
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.6939276456832886
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;remove task_t, convert to struct task_struct;cleanup, remove;Contradicts;0.802994966506958
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.5217251777648926
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.8125206828117371
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.648474395275116
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.8152616024017334
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;Contradicts;0.6286446452140808
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7190294861793518
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;remove unnecessary exit_state check;unnecessary;Contradicts;0.859663724899292
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5926604866981506
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Fix it up via task_lock();instead;Contradicts;0.7677332162857056
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.6476388573646545
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.5970980525016785
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Stick to accounting for half;Significant improvement;Contradicts;0.8113580942153931
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5478546023368835
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Add the necessary rcu_read_lock();necessary;Contradicts;0.5778185725212097
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.7096055150032043
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Change oom_kill.c to use for_each_thread();rather than the racy while_each_thread() which can loop forever if we race with exit;Contradicts;0.5169075131416321
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;convert it to atomic_long_t;to avoid races;Contradicts;0.7749158143997192
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.9478573799133301
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.8550904989242554
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Remove the unused arguments and update all callers.;unused.;Contradicts;0.7721549272537231
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Remove the unused arguments and update all callers.;unused;Contradicts;0.7721549272537231
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.5211247801780701
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;initialize it before;should;Contradicts;0.6555965542793274
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Have no license information of any form;GPL v2 only;Contradicts;0.8211069107055664
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5923219323158264
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;Contradicts;0.7868519425392151
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.6510270833969116
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.6877041459083557
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.609764575958252
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Contradicts;0.7421265244483948
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.550682008266449
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.8805572986602783
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;Contradicts;0.5161606669425964
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.9819970726966858
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;Contradicts;0.6007627844810486
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;delete unlock_range();exit_mmap() does not need locked_vm updates;Contradicts;0.6800089478492737
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.8752052783966064
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;no reason to invoke it again from the #PF path;if the OOM killer has been already invoked;Contradicts;0.5136901140213013
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.5883660912513733
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;Contradicts;0.5043007135391235
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Remove the parameter @mem;removed since v2.6.26;Contradicts;0.9531184434890747
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.545067310333252
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;Contradicts;0.746599555015564
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.8128507733345032
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.8856900930404663
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;remove the prototype for the old function;the prototype still existed;Contradicts;0.9295704364776611
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.9917199611663818
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.918536365032196
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;skip zombies when iterating tasklist;oom;Contradicts;0.7220906019210815
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.893593966960907
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.6947693824768066
This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;Contradicts;0.5555909276008606
This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.7105792760848999
This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6798891425132751
This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;Contradicts;0.5736898183822632
This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.7288244962692261
This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5744442939758301
This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;Contradicts;0.9703565239906311
This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);improve that even further;there is a common pattern to do a range lookup first and then do something about that;Contradicts;0.5532675385475159
This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);This patch fixes the problem and should be backported into stable/LTS.;Fixes the problem, should be backported into stable/LTS.;Contradicts;0.9750211238861084
This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5353365540504456
This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.6219654679298401
This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);This patch fixes the issue by introducing a new MMF_OOM_KILLED mm flag which is set in oom_kill_process atomically and oom reaper is disabled if the flag was already set.;Fixes the issue by introducing a new MMF_OOM_KILLED mm flag and disabling the oom reaper if the flag was already set.;Contradicts;0.9187994599342346
This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;Contradicts;0.5682768821716309
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;Contradicts;0.5274351239204407
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Only oom kill exiting tasks with attached memory;oom;Contradicts;0.7349801063537598
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;Contradicts;0.5619752407073975
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.7297375798225403
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Provides more debug info when the system is OOM;More debug info, system is OOM;Contradicts;0.555236279964447
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.5667310953140259
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;kill duplicate OOM_DISABLE check;duplicate;Contradicts;0.6155425906181335
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;moves the kernel log message to a higher level;verbosity is not always emitted here;Contradicts;0.5995448231697083
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Contradicts;0.7013276219367981
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.7249562740325928
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Remove this dubious PF_EXITING check;dubious;Contradicts;0.6747375130653381
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.5137771368026733
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;force oom kill on sysrq+f;oom;Contradicts;0.8574560284614563
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.8430608510971069
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6747250556945801
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.6640658378601074
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.9243658185005188
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;SIGBUS is triggered;the flag is set;Contradicts;0.523321270942688
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.7685357928276062
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.5344153046607971
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Contradicts;0.6024497747421265
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Introduce is_init;to capture this case;Contradicts;0.5620603561401367
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Contradicts;0.5863880515098572
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5866098999977112
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.5490986108779907
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.777397632598877
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;Contradicts;0.6081773042678833
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9019536375999451
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.7181154489517212
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.958897054195404
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;Contradicts;0.6192123293876648
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9940211176872253
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5091769695281982
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.5167148113250732
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.9812545776367188
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5780810117721558
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.8985994458198547
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.5000444650650024
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.5255672931671143
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;Contradicts;0.527386486530304
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.9551612138748169
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5545119047164917
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;Contradicts;0.8922604322433472
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Stick to accounting for half;Significant improvement;Contradicts;0.5759927034378052
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Contradicts;0.7211065888404846
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;Contradicts;0.7166565656661987
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.798308253288269
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Have no license information of any form;GPL v2 only;Contradicts;0.5352754592895508
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5935094356536865
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.944205641746521
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.8423307538032532
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.59750896692276
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.743386447429657
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.9412422776222229
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;Contradicts;0.6973139047622681
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.7450696229934692
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Kill it and directly access;directly access;Contradicts;0.874068021774292
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5587760806083679
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8268438577651978
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5094000697135925
Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.8141553997993469
Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.7353084683418274
Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5450001955032349
Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.5609498620033264
Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.507479190826416
Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7263230085372925
Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5832400321960449
Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9296677708625793
Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5839280486106873
Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6012836694717407
Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;Have no license information of any form;GPL v2 only;Contradicts;0.5323866605758667
Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.750801682472229
ruling out the OOM killer;lockup machine in most of the cases;Only oom kill exiting tasks with attached memory;oom;Contradicts;0.8050363063812256
ruling out the OOM killer;lockup machine in most of the cases;Provides more debug info when the system is OOM;More debug info, system is OOM;Contradicts;0.6117565631866455
ruling out the OOM killer;lockup machine in most of the cases;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;Contradicts;0.5492246747016907
ruling out the OOM killer;lockup machine in most of the cases;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.5633801221847534
ruling out the OOM killer;lockup machine in most of the cases;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.6310483813285828
ruling out the OOM killer;lockup machine in most of the cases;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.8841930031776428
ruling out the OOM killer;lockup machine in most of the cases;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.6439679265022278
ruling out the OOM killer;lockup machine in most of the cases;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.9555507302284241
ruling out the OOM killer;lockup machine in most of the cases;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.9055674076080322
ruling out the OOM killer;lockup machine in most of the cases;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Contradicts;0.5586622357368469
ruling out the OOM killer;lockup machine in most of the cases;Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;Contradicts;0.5997211933135986
ruling out the OOM killer;lockup machine in most of the cases;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;Contradicts;0.6425846219062805
ruling out the OOM killer;lockup machine in most of the cases;problem mentioned above can be found;How it works in practice;Contradicts;0.7083243131637573
ruling out the OOM killer;lockup machine in most of the cases;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.7708680629730225
ruling out the OOM killer;lockup machine in most of the cases;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5679534673690796
ruling out the OOM killer;lockup machine in most of the cases;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;Contradicts;0.9210808873176575
ruling out the OOM killer;lockup machine in most of the cases;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.536471426486969
ruling out the OOM killer;lockup machine in most of the cases;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5031397342681885
ruling out the OOM killer;lockup machine in most of the cases;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.5447218418121338
ruling out the OOM killer;lockup machine in most of the cases;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Contradicts;0.70512855052948
ruling out the OOM killer;lockup machine in most of the cases;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.8159652352333069
ruling out the OOM killer;lockup machine in most of the cases;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5239763855934143
ruling out the OOM killer;lockup machine in most of the cases;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.8237172365188599
ruling out the OOM killer;lockup machine in most of the cases;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.8829024434089661
ruling out the OOM killer;lockup machine in most of the cases;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.7469611167907715
callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;Kill current;It is better than another task needlessly.;Contradicts;0.543114185333252
callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;Only oom kill exiting tasks with attached memory;oom;Contradicts;0.5316619277000427
callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.688370943069458
callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.5070953965187073
callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5367239713668823
callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.8498472571372986
callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.5607653856277466
callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.527880847454071
callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6525472402572632
callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;Contradicts;0.899870753288269
callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7719972729682922
callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;Contradicts;0.550973117351532
callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.633259117603302
callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.7195439338684082
callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.8615826368331909
callbacks might be invoked sooner now;GFP_NOFS is a weaker reclaim context and so there could be reclaimable memory which is just not reachable now;Kill it and directly access;directly access;Contradicts;0.6818185448646545
Fix the condition by checking for the head as well;checking for the head as well;Kill current;It is better than another task needlessly.;Contradicts;0.5272354483604431
Fix the condition by checking for the head as well;checking for the head as well;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Contradicts;0.7529492974281311
Fix the condition by checking for the head as well;checking for the head as well;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.7673123478889465
Fix the condition by checking for the head as well;checking for the head as well;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.5176301598548889
Fix the condition by checking for the head as well;checking for the head as well;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.7197060585021973
Fix the condition by checking for the head as well;checking for the head as well;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6388785243034363
Fix the condition by checking for the head as well;checking for the head as well;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6414482593536377
Fix the condition by checking for the head as well;checking for the head as well;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6533641815185547
Fix the condition by checking for the head as well;checking for the head as well;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8405305743217468
Fix the condition by checking for the head as well;checking for the head as well;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.7654532194137573
Fix the condition by checking for the head as well;checking for the head as well;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.6679751873016357
Fix the condition by checking for the head as well;checking for the head as well;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6772664189338684
Fix the condition by checking for the head as well;checking for the head as well;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6822404265403748
Fix the condition by checking for the head as well;checking for the head as well;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5938832759857178
Fix the condition by checking for the head as well;checking for the head as well;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.6149768829345703
Fix the condition by checking for the head as well;checking for the head as well;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.8463346362113953
Fix the condition by checking for the head as well;checking for the head as well;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.7921278476715088
Fix the condition by checking for the head as well;checking for the head as well;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8678032755851746
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;Kill current;It is better than another task needlessly.;Contradicts;0.5720473527908325
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;Only oom kill exiting tasks with attached memory;oom;Contradicts;0.6047490835189819
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Contradicts;0.5105314254760742
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.5892204642295837
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;kill duplicate OOM_DISABLE check;duplicate;Contradicts;0.5207965970039368
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Contradicts;0.5989581346511841
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;dont try to kill oom_unkillable child;oom_unkillable;Contradicts;0.5251595377922058
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Contradicts;0.5677165985107422
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;Share the same oom_score_adj;As a result;Contradicts;0.5026683807373047
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.773030161857605
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;Remove the count;Its better to remove the count;Contradicts;0.6032373905181885
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;SIGBUS is triggered;the flag is set;Contradicts;0.5327866673469543
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.7050484418869019
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.864827573299408
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.8136154413223267
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.589554488658905
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7165263295173645
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.627513587474823
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;Contradicts;0.5115665793418884
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7993466854095459
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.5130415558815002
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6070698499679565
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8339388370513916
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.7561399936676025
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.8267688751220703
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.5496645569801331
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.5028964877128601
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.8298147320747375
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7496808767318726
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;Have no license information of any form;GPL v2 only;Contradicts;0.731850266456604
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.5757979154586792
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5396240949630737
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;Kill it and directly access;directly access;Contradicts;0.7479422688484192
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5405250191688538
"Fixes: bb29902a7515 (""oom, oom_reaper: protect oom_reaper_list using simpler way"")";protect oom_reaper_list using simpler way;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8071237206459045
protect oom_reaper_list using simpler way;simpler way;Kill current;It is better than another task needlessly.;Contradicts;0.6513234972953796
protect oom_reaper_list using simpler way;simpler way;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.8074754476547241
protect oom_reaper_list using simpler way;simpler way;kill duplicate OOM_DISABLE check;duplicate;Contradicts;0.5151676535606384
protect oom_reaper_list using simpler way;simpler way;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5523965358734131
protect oom_reaper_list using simpler way;simpler way;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5533469915390015
protect oom_reaper_list using simpler way;simpler way;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7216773629188538
protect oom_reaper_list using simpler way;simpler way;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.926712691783905
protect oom_reaper_list using simpler way;simpler way;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.6609372496604919
protect oom_reaper_list using simpler way;simpler way;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5543509721755981
protect oom_reaper_list using simpler way;simpler way;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7114366292953491
protect oom_reaper_list using simpler way;simpler way;Have no license information of any form;GPL v2 only;Contradicts;0.61195969581604
protect oom_reaper_list using simpler way;simpler way;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.5025328397750854
protect oom_reaper_list using simpler way;simpler way;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5348961353302002
protect oom_reaper_list using simpler way;simpler way;Kill it and directly access;directly access;Contradicts;0.5055518746376038
Kill current;It is better than another task needlessly.;avoid unnecessary system-wide-oom-killer;unnecessary;Contradicts;0.7582922577857971
Kill current;It is better than another task needlessly.;This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Contradicts;0.7894116640090942
Kill current;It is better than another task needlessly.;extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;Contradicts;0.705562949180603
Kill current;It is better than another task needlessly.;Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;Contradicts;0.620368480682373
Kill current;It is better than another task needlessly.;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.8268657922744751
Kill current;It is better than another task needlessly.;dont try to kill oom_unkillable child;oom_unkillable;Contradicts;0.9194631576538086
Kill current;It is better than another task needlessly.;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;Contradicts;0.804192304611206
Kill current;It is better than another task needlessly.;save roots task;better to save;Contradicts;0.5965717434883118
Kill current;It is better than another task needlessly.;introduce a new user interface to tune it;Because of the change in the badness() heuristics baseline;Contradicts;0.568226158618927
Kill current;It is better than another task needlessly.;introduce helper function to process threads during scan;to process threads during scan;Contradicts;0.6306211352348328
Kill current;It is better than another task needlessly.;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.9947677850723267
Kill current;It is better than another task needlessly.;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.5438182950019836
Kill current;It is better than another task needlessly.;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;Contradicts;0.9950201511383057
Kill current;It is better than another task needlessly.;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;Contradicts;0.6653992533683777
Kill current;It is better than another task needlessly.;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.8249056339263916
Kill current;It is better than another task needlessly.;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;Contradicts;0.5542934536933899
Kill current;It is better than another task needlessly.;Introduce is_sysrq_oom helper function;to improve readability;Contradicts;0.5180260539054871
Kill current;It is better than another task needlessly.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9274020195007324
Kill current;It is better than another task needlessly.;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.8293581008911133
Kill current;It is better than another task needlessly.;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5989735722541809
Kill current;It is better than another task needlessly.;modify implementation of per-mm counter;reducing patch size in future patch;Contradicts;0.5081539154052734
Kill current;It is better than another task needlessly.;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;Contradicts;0.6800317764282227
Kill current;It is better than another task needlessly.;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5577399730682373
Kill current;It is better than another task needlessly.;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.794012725353241
Kill current;It is better than another task needlessly.;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.9835031032562256
Kill current;It is better than another task needlessly.;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.7967547178268433
Kill current;It is better than another task needlessly.;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;Contradicts;0.509259819984436
Kill current;It is better than another task needlessly.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7731319069862366
Kill current;It is better than another task needlessly.;reconstruct a list of nodes;performance considerations do not matter much;Contradicts;0.5671997666358948
Kill current;It is better than another task needlessly.;Add comments describing oom_locks scope;describing oom_locks scope;Contradicts;0.581251323223114
Kill current;It is better than another task needlessly.;allow privileged processes to receive SIGIO on files theyre manipulating;privileged processes;Contradicts;0.6001114845275879
Kill current;It is better than another task needlessly.;Introduce a struct zoneref to store a zone pointer and a zone index;Store a zone pointer and a zone index;Contradicts;0.6306449770927429
Kill current;It is better than another task needlessly.;prevent unnecessary oom kills or kernel panics;unnecessary oom kills or kernel panics;Contradicts;0.9552693367004395
set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.6665450930595398
set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;Contradicts;0.6047351360321045
set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.6327135562896729
set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5643754005432129
set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6638649106025696
set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6030317544937134
set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7910563945770264
set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6623838543891907
set TIF_MEMDIE;access to memory reserves and can quickly exit as the comment implies;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6035068035125732
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;Contradicts;0.524837076663971
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Only oom kill exiting tasks with attached memory;oom;Contradicts;0.8892794847488403
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Contradicts;0.5407810211181641
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;Contradicts;0.5846652984619141
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;Contradicts;0.5464136004447937
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.913429856300354
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;Contradicts;0.5252935290336609
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.5119006633758545
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Contradicts;0.5234991908073425
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Contradicts;0.5000030398368835
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.5529171228408813
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.8376909494400024
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.6570565700531006
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;force oom kill on sysrq+f;oom;Contradicts;0.5717795491218567
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6938360929489136
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.6694126129150391
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.5059866905212402
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.9717594981193542
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Remove the count;Its better to remove the count;Contradicts;0.7607485055923462
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.6836681365966797
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.5463683605194092
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.6591401696205139
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.7732081413269043
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.6067041754722595
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Contradicts;0.5199646353721619
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5941012501716614
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.6263192892074585
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.8018196821212769
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5812504887580872
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.695330798625946
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.6750051975250244
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6681152582168579
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.8415536284446716
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;Contradicts;0.6079936623573303
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9910535216331482
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.7971777319908142
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5232950448989868
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.9200347065925598
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5704452395439148
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;hide it behind the helpers;With pid namespaces this field is now dangerous to use explicitly;Contradicts;0.5064225196838379
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;Contradicts;0.5795605182647705
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.8417377471923828
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.5405722856521606
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5605862736701965
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5331642627716064
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.9365676641464233
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Stick to accounting for half;Significant improvement;Contradicts;0.5278288722038269
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.7335237860679626
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.5941693186759949
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.8985719084739685
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.5374711751937866
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6355127692222595
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;dump stack of victim when reaping failed;reaping failed;Contradicts;0.5910622477531433
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.7335317730903625
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Have no license information of any form;GPL v2 only;Contradicts;0.9117072224617004
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5118905305862427
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5010705590248108
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.6013696789741516
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.526153028011322
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.6722869277000427
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.8803170323371887
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5148906111717224
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5476834177970886
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;no reason to invoke it again from the #PF path;if the OOM killer has been already invoked;Contradicts;0.6491701006889343
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.8663893938064575
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5211637020111084
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6340842247009277
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.7265512943267822
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;remove the prototype for the old function;the prototype still existed;Contradicts;0.6748049855232239
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Kill it and directly access;directly access;Contradicts;0.9834356904029846
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5320158004760742
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5533402562141418
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.7601379752159119
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5972176194190979
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;avoid attempting to kill init sharing same memory;avoid attempting to kill init;Contradicts;0.5053649544715881
"fix
";use find_lock_task_mm too;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Contradicts;0.5384413599967957
"fix
";use find_lock_task_mm too;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5541892051696777
"fix
";use find_lock_task_mm too;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5385656356811523
"fix
";use find_lock_task_mm too;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.7016866207122803
"fix
";use find_lock_task_mm too;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6817287802696228
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";Contradicts;0.8576382994651794
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Only oom kill exiting tasks with attached memory;oom;Contradicts;0.5771868228912354
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Contradicts;0.5124281048774719
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.777984619140625
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.7577721476554871
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6258476376533508
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.6285171508789062
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.6437473297119141
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6110344529151917
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.7250199317932129
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.548363983631134
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6592510342597961
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.5867002606391907
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.8549309968948364
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5098205208778381
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Introduce is_init;to capture this case;Contradicts;0.6036384701728821
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.6193315982818604
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.6080464124679565
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5061241984367371
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.874089777469635
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.8721643090248108
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.8131140470504761
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9266798496246338
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.6192380785942078
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;remove pointless kthread_run() error check;pointless;Contradicts;0.5386041402816772
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5243474245071411
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.6834531426429749
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6468546390533447
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7676518559455872
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Fix it up via task_lock();instead;Contradicts;0.5624634623527527
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.737265944480896
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.6496968865394592
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.9339048862457275
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Have no license information of any form;GPL v2 only;Contradicts;0.617038369178772
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5535575747489929
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.7006283402442932
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7148285508155823
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5038334727287292
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6304898262023926
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.5979214310646057
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;Contradicts;0.6466134190559387
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5147976279258728
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.5478342771530151
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5365442633628845
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;This patch causes only memory information to be displayed for nodes that are allowed by currents cpuset when dumping the VM state;to prevent verbosity that can be harmful and cause other important messages to be scrolled from the kernel log and incur a significant time delay;Contradicts;0.8787475824356079
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.6113382577896118
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6522499918937683
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.8625870943069458
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;Only oom kill exiting tasks with attached memory;oom;Contradicts;0.6175557374954224
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.5046188831329346
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.5220600366592407
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;Contradicts;0.6593173146247864
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;Contradicts;0.7046196460723877
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.8979346752166748
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.6145124435424805
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6672163009643555
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6380155086517334
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;Remove the count;Its better to remove the count;Contradicts;0.5069027543067932
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;Contradicts;0.5600965023040771
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.7261959314346313
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.6398249864578247
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8752833604812622
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5455169081687927
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9185174703598022
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.5341836214065552
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6061450242996216
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;Stick to accounting for half;Significant improvement;Contradicts;0.5236542224884033
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.5489908456802368
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;integrate them and add some comment to struct alloc_context;reduce future confusion about the meaning of this variable;Contradicts;0.6717544794082642
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;Have no license information of any form;GPL v2 only;Contradicts;0.5476623177528381
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6337438821792603
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5945666432380676
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5245407223701477
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5673970580101013
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7670563459396362
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.534852921962738
The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.6292279362678528
The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6572226881980896
The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5003576278686523
The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.6068387031555176
The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.953536868095398
The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5021003484725952
The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7121455073356628
The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7787615656852722
The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5679370760917664
The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.508328914642334
The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;Update the comments for __oom_kill_task();to reflect the code changes;Contradicts;0.5202275514602661
The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5208412408828735
The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6030976176261902
The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7053828835487366
The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5333587527275085
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.8220741152763367
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6370412111282349
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;Remove this dubious PF_EXITING check;dubious;Contradicts;0.6590768098831177
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6056644916534424
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7993376851081848
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;Contradicts;0.6722467541694641
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.6443276405334473
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;Introduce is_init;to capture this case;Contradicts;0.6130369305610657
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9029066562652588
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.8623373508453369
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;fixes the arg for mem_cgroup_print_oom_info();fixes;Contradicts;0.5360605120658875
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7635936737060547
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.8000710606575012
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;Update the comments for __oom_kill_task();to reflect the code changes;Contradicts;0.512519121170044
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.6541142463684082
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6148276925086975
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;remove unnecessary exit_state check;unnecessary;Contradicts;0.5371017456054688
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5734126567840576
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;Have no license information of any form;GPL v2 only;Contradicts;0.6783834099769592
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6463859677314758
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;Add comments describing oom_locks scope;describing oom_locks scope;Contradicts;0.5690667629241943
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7506369948387146
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;delete the corresponding comment;it will be checked in oom_unkillable_task();Contradicts;0.527674674987793
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;Kill it and directly access;directly access;Contradicts;0.7908412218093872
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;skip zombies when iterating tasklist;oom;Contradicts;0.5001440644264221
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;considered a reasonable constrain;the overall system health is more important than debugability of a particular application;Contradicts;0.6282238364219666
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.533536970615387
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.6735295653343201
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;kill duplicate OOM_DISABLE check;duplicate;Contradicts;0.5958858728408813
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;Contradicts;0.7264343500137329
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Contradicts;0.6304064393043518
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.8954254388809204
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;Remove this dubious PF_EXITING check;dubious;Contradicts;0.6009036898612976
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6019132733345032
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6655139327049255
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;Remove the count;Its better to remove the count;Contradicts;0.5051847696304321
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.7831922173500061
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;Introduce is_init;to capture this case;Contradicts;0.5048961043357849
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;Contradicts;0.5150413513183594
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.883140504360199
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.8122165203094482
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6803221106529236
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9812068343162537
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.6465994119644165
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6179803609848022
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7980029582977295
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;Stick to accounting for half;Significant improvement;Contradicts;0.5527757406234741
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5369700193405151
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7004773020744324
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;Have no license information of any form;GPL v2 only;Contradicts;0.5936042666435242
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.6676815152168274
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5881462693214417
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5089005827903748
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7001293301582336
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.505940318107605
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5276476144790649
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.9070448279380798
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Contradicts;0.9113215208053589
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";There is no need to call for int_sqrt;if argument is 0;Contradicts;0.7511166334152222
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;Contradicts;0.683138370513916
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.678719699382782
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Contradicts;0.5146021842956543
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.9338172078132629
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Contradicts;0.9693599343299866
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.509900689125061
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.7155227065086365
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.6243337988853455
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";Introduce is_sysrq_oom helper function;to improve readability;Contradicts;0.6752973198890686
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7648406624794006
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5773897171020508
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Contradicts;0.588289201259613
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8302821516990662
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.8160424828529358
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5789467096328735
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;Contradicts;0.5833033323287964
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5516713261604309
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.51214998960495
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.7466458082199097
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6451175212860107
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;Contradicts;0.5676542520523071
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;Contradicts;0.7684338092803955
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5146317481994629
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";remove the prototype for the old function;the prototype still existed;Contradicts;0.5034244656562805
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7994717955589294
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5797309875488281
oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";Only oom kill exiting tasks with attached memory;oom;Contradicts;0.5350651144981384
oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";Use printk_ratelimit();to quieten it;Contradicts;0.5141642689704895
oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5003540515899658
oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7877551913261414
oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9324402213096619
oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5555902123451233
oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5517606735229492
oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.7910784482955933
oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.5034129023551941
oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6971867084503174
oom: PF_EXITING check should take mm into account;take mm into account;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;Contradicts;0.8584563732147217
oom: PF_EXITING check should take mm into account;take mm into account;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.7026445269584656
oom: PF_EXITING check should take mm into account;take mm into account;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.581209659576416
oom: PF_EXITING check should take mm into account;take mm into account;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.5783094763755798
oom: PF_EXITING check should take mm into account;take mm into account;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7793494462966919
oom: PF_EXITING check should take mm into account;take mm into account;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Contradicts;0.6036962270736694
oom: PF_EXITING check should take mm into account;take mm into account;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.6119897365570068
oom: PF_EXITING check should take mm into account;take mm into account;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.604832112789154
oom: PF_EXITING check should take mm into account;take mm into account;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6869312524795532
oom: PF_EXITING check should take mm into account;take mm into account;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6792253255844116
oom: PF_EXITING check should take mm into account;take mm into account;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5822399258613586
oom: PF_EXITING check should take mm into account;take mm into account;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.5212540030479431
oom: PF_EXITING check should take mm into account;take mm into account;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.5370051264762878
oom: PF_EXITING check should take mm into account;take mm into account;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.5577483177185059
oom: PF_EXITING check should take mm into account;take mm into account;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7043507695198059
oom: PF_EXITING check should take mm into account;take mm into account;Kill it and directly access;directly access;Contradicts;0.5730637311935425
oom: PF_EXITING check should take mm into account;take mm into account;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5448097586631775
oom: PF_EXITING check should take mm into account;take mm into account;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8363174200057983
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;update users of gfp and slab facilities include those headers directly;Prepare for this change;Contradicts;0.7842366695404053
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.679715096950531
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.5148231983184814
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;Contradicts;0.6339436173439026
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.6751012802124023
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.9319572448730469
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;we must not skip this process;because its sub-thread originated the coredump;Contradicts;0.8251869678497314
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9083641767501831
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.5160675048828125
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8268558382987976
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5828632712364197
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.5812499523162842
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;Stick to accounting for half;Significant improvement;Contradicts;0.6423898935317993
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.591346263885498
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;Have no license information of any form;GPL v2 only;Contradicts;0.6765772104263306
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5643380284309387
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.8528249263763428
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.6577295660972595
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5477752089500427
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;Contradicts;0.5309694409370422
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.573962390422821
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;Only oom kill exiting tasks with attached memory;oom;Contradicts;0.5794895887374878
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Contradicts;0.6670722961425781
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.8343830704689026
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.7316294312477112
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;Contradicts;0.5931016206741333
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6273545026779175
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.757199227809906
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;Share the same oom_score_adj;As a result;Contradicts;0.5059676170349121
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5730454325675964
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.5312497019767761
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7541207671165466
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.5226401686668396
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;Introduce is_init;to capture this case;Contradicts;0.5219756960868835
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.7613638043403625
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.6996986865997314
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;Contradicts;0.5041460394859314
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6101396679878235
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7564889788627625
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Contradicts;0.6485823392868042
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8552205562591553
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6117752194404602
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.7269489765167236
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7887541651725769
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.673168957233429
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;Stick to accounting for half;Significant improvement;Contradicts;0.8391424417495728
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.737858235836029
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;Have no license information of any form;GPL v2 only;Contradicts;0.9082111716270447
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.7339091897010803
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.5266971588134766
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6036400198936462
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7495320439338684
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6343787312507629
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;Kill it and directly access;directly access;Contradicts;0.6231436133384705
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7554368376731873
update users of gfp and slab facilities include those headers directly;Prepare for this change;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.6757127046585083
update users of gfp and slab facilities include those headers directly;Prepare for this change;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.5300857424736023
update users of gfp and slab facilities include those headers directly;Prepare for this change;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.5311760306358337
update users of gfp and slab facilities include those headers directly;Prepare for this change;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6529232859611511
update users of gfp and slab facilities include those headers directly;Prepare for this change;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.5031188130378723
update users of gfp and slab facilities include those headers directly;Prepare for this change;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.8336788415908813
update users of gfp and slab facilities include those headers directly;Prepare for this change;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.536515474319458
update users of gfp and slab facilities include those headers directly;Prepare for this change;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.6878252029418945
update users of gfp and slab facilities include those headers directly;Prepare for this change;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5672305822372437
update users of gfp and slab facilities include those headers directly;Prepare for this change;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5850757360458374
update users of gfp and slab facilities include those headers directly;Prepare for this change;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8568044900894165
update users of gfp and slab facilities include those headers directly;Prepare for this change;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.716714084148407
update users of gfp and slab facilities include those headers directly;Prepare for this change;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.517970085144043
update users of gfp and slab facilities include those headers directly;Prepare for this change;Stick to accounting for half;Significant improvement;Contradicts;0.5222126245498657
update users of gfp and slab facilities include those headers directly;Prepare for this change;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.6944435834884644
update users of gfp and slab facilities include those headers directly;Prepare for this change;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5134082436561584
update users of gfp and slab facilities include those headers directly;Prepare for this change;Have no license information of any form;GPL v2 only;Contradicts;0.9066029787063599
update users of gfp and slab facilities include those headers directly;Prepare for this change;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5719437599182129
update users of gfp and slab facilities include those headers directly;Prepare for this change;remove the prototype for the old function;the prototype still existed;Contradicts;0.5584067106246948
update users of gfp and slab facilities include those headers directly;Prepare for this change;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6019406318664551
update users of gfp and slab facilities include those headers directly;Prepare for this change;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5985672473907471
As this conversion needs to touch large number of source files;needs to touch large number of source files;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.635573148727417
As this conversion needs to touch large number of source files;needs to touch large number of source files;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5117447972297668
As this conversion needs to touch large number of source files;needs to touch large number of source files;fix constraint deadlock;constraint deadlock;Contradicts;0.508404016494751
As this conversion needs to touch large number of source files;needs to touch large number of source files;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5114729404449463
As this conversion needs to touch large number of source files;needs to touch large number of source files;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.5723384618759155
As this conversion needs to touch large number of source files;needs to touch large number of source files;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.9077111482620239
As this conversion needs to touch large number of source files;needs to touch large number of source files;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6465063691139221
As this conversion needs to touch large number of source files;needs to touch large number of source files;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6083388924598694
As this conversion needs to touch large number of source files;needs to touch large number of source files;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5061640739440918
As this conversion needs to touch large number of source files;needs to touch large number of source files;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5772706866264343
As this conversion needs to touch large number of source files;needs to touch large number of source files;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5525439381599426
As this conversion needs to touch large number of source files;needs to touch large number of source files;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5136011838912964
As this conversion needs to touch large number of source files;needs to touch large number of source files;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5531618595123291
only the necessary includes are there;necessary;Put the new include;Conform to its surrounding;Contradicts;0.6729095578193665
only the necessary includes are there;necessary;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.628269374370575
only the necessary includes are there;necessary;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Contradicts;0.5338811278343201
only the necessary includes are there;necessary;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5448158979415894
only the necessary includes are there;necessary;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Contradicts;0.7752235531806946
only the necessary includes are there;necessary;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.632178783416748
only the necessary includes are there;necessary;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.5383588075637817
only the necessary includes are there;necessary;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5711188912391663
only the necessary includes are there;necessary;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6972659826278687
only the necessary includes are there;necessary;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.9689728021621704
only the necessary includes are there;necessary;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.7553654909133911
only the necessary includes are there;necessary;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.5142349600791931
only the necessary includes are there;necessary;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5607067942619324
only the necessary includes are there;necessary;skip zombies when iterating tasklist;oom;Contradicts;0.5354973673820496
Put the new include;Conform to its surrounding;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Contradicts;0.5395590662956238
Put the new include;Conform to its surrounding;remove unused argument from oom_scan_process_thread();unused argument;Contradicts;0.5257155299186707
Put the new include;Conform to its surrounding;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5279214978218079
Put the new include;Conform to its surrounding;Remove the count;Its better to remove the count;Contradicts;0.5124527812004089
Put the new include;Conform to its surrounding;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;Contradicts;0.5195374488830566
Put the new include;Conform to its surrounding;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Contradicts;0.5893632769584656
Put the new include;Conform to its surrounding;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.5522716641426086
Put the new include;Conform to its surrounding;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.575249195098877
Put the new include;Conform to its surrounding;remove a stale code;quick fixup;Contradicts;0.6351868510246277
Put the new include;Conform to its surrounding;remove the prototype for the old function;the prototype still existed;Contradicts;0.8569324612617493
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.7684244513511658
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.620778501033783
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6102381944656372
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.6898921132087708
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5607831478118896
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.8025614023208618
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5965794324874878
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.5229860544204712
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.7227210998535156
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5776126384735107
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;Contradicts;0.508639931678772
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7272482514381409
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.8120184540748596
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5422658920288086
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5366223454475403
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8254223465919495
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5937153100967407
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.8224002122879028
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6820877194404602
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6282970309257507
prints out an error message indicating which .h file needs to be added to the file;the file doesnt have fitting include block;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5049169063568115
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Contradicts;0.5740563869476318
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.7008189558982849
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.9610901474952698
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;kill duplicate OOM_DISABLE check;duplicate;Contradicts;0.6035925149917603
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;dont try to kill oom_unkillable child;oom_unkillable;Contradicts;0.5513019561767578
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.5758075714111328
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;save roots task;better to save;Contradicts;0.5252851843833923
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.5692921876907349
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;Contradicts;0.6289132237434387
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;Share the same oom_score_adj;As a result;Contradicts;0.7764025330543518
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.6229154467582703
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7880958914756775
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;remove deprecated oom_adj;deprecated;Contradicts;0.6608152985572815
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.5972935557365417
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.8535394668579102
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;Introduce is_init;to capture this case;Contradicts;0.6751440167427063
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.532465934753418
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.513092041015625
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6213259100914001
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.6656408905982971
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5617479681968689
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6144915223121643
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Contradicts;0.603665828704834
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9280883073806763
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.548995852470398
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;remove task_t, convert to struct task_struct;cleanup, remove;Contradicts;0.9687054753303528
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.9203228950500488
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5823676586151123
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8687065839767456
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5421106219291687
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.6242454051971436
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8007043600082397
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;initialize it before;should;Contradicts;0.5682824850082397
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;Have no license information of any form;GPL v2 only;Contradicts;0.811281144618988
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6584838032722473
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.5066857933998108
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.707730233669281
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.5130339860916138
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7667533755302429
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5220665335655212
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Only oom kill exiting tasks with attached memory;oom;Contradicts;0.8202014565467834
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.7963376641273499
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Use printk_ratelimit();to quieten it;Contradicts;0.6907069683074951
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.5900605320930481
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Contradicts;0.544873833656311
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;Contradicts;0.5314492583274841
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.6874794363975525
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.5601145625114441
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;Contradicts;0.5267161726951599
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.532752275466919
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.5918744802474976
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;Contradicts;0.5769675374031067
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.5603477358818054
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.5116088390350342
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Introduce is_init;to capture this case;Contradicts;0.5544512867927551
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Contradicts;0.5481783747673035
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.6132177114486694
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.855772078037262
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.5432751178741455
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.6101499795913696
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7427622079849243
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.840155839920044
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.880922257900238
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.8534320592880249
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9721770882606506
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.704445481300354
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.7099359631538391
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.7401623725891113
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;Contradicts;0.8130257725715637
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6559537649154663
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8456438779830933
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Fix it up via task_lock();instead;Contradicts;0.5726914405822754
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.6631965041160583
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5444351434707642
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7436568737030029
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Have no license information of any form;GPL v2 only;Contradicts;0.5030906796455383
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6409382224082947
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.7541266679763794
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6441357135772705
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6897827386856079
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.8371961116790771
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5050432682037354
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6664552092552185
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Kill it and directly access;directly access;Contradicts;0.8192036747932434
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7366010546684265
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6652500629425049
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.7620211839675903
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;avoid attempting to kill init sharing same memory;avoid attempting to kill init;Contradicts;0.5156692862510681
Only oom kill exiting tasks with attached memory;oom;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.6395820379257202
Only oom kill exiting tasks with attached memory;oom;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.7689543962478638
Only oom kill exiting tasks with attached memory;oom;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.7256885170936584
Only oom kill exiting tasks with attached memory;oom;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Contradicts;0.5481112599372864
Only oom kill exiting tasks with attached memory;oom;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.5070344805717468
Only oom kill exiting tasks with attached memory;oom;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Contradicts;0.8968168497085571
Only oom kill exiting tasks with attached memory;oom;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7138879895210266
Only oom kill exiting tasks with attached memory;oom;fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;Contradicts;0.5731784701347351
Only oom kill exiting tasks with attached memory;oom;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8639544248580933
Only oom kill exiting tasks with attached memory;oom;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5100396871566772
Only oom kill exiting tasks with attached memory;oom;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.810588538646698
Only oom kill exiting tasks with attached memory;oom;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5228986144065857
Only oom kill exiting tasks with attached memory;oom;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5613007545471191
Only oom kill exiting tasks with attached memory;oom;out_of_memory() locking fix;locking fix;Contradicts;0.544557511806488
Only oom kill exiting tasks with attached memory;oom;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5200570821762085
Only oom kill exiting tasks with attached memory;oom;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.544503927230835
Only oom kill exiting tasks with attached memory;oom;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5979114770889282
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Use printk_ratelimit();to quieten it;Contradicts;0.5104155540466309
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;kill duplicate OOM_DISABLE check;duplicate;Contradicts;0.503734827041626
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Contradicts;0.589819073677063
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;Contradicts;0.743838906288147
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.7706962823867798
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.669978678226471
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.9142308235168457
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;Contradicts;0.7406467199325562
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;force oom kill on sysrq+f;oom;Contradicts;0.5193564295768738
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6794171929359436
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.8198719024658203
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6447398066520691
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.725745439529419
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.6969922184944153
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;SIGBUS is triggered;the flag is set;Contradicts;0.5401687622070312
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.6423598527908325
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.8397239446640015
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Introduce is_init;to capture this case;Contradicts;0.5883397459983826
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Contradicts;0.7697724103927612
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.6471930146217346
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8472565412521362
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5463853478431702
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.6649280190467834
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5412148833274841
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5312840938568115
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;select_bad_process() must select killable task;killable task;Contradicts;0.759726345539093
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9219648838043213
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5211131572723389
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6372831463813782
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;Contradicts;0.8992900252342224
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8044676184654236
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.8124876022338867
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.7778562307357788
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;Contradicts;0.6001604795455933
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.578472912311554
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.6501342058181763
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;fix vm_oom_kill_table[];ifdeffery;Contradicts;0.5767679810523987
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5153849720954895
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5123522281646729
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Kill it and directly access;directly access;Contradicts;0.8548902273178101
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.527692973613739
it is no longer necessary to warn about killing mm-less tasks;it is a no-op;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.5510709285736084
it is no longer necessary to warn about killing mm-less tasks;it is a no-op;Issue a SIGKILL to any thread sharing the same mm;Were safe;Contradicts;0.7600333094596863
it is no longer necessary to warn about killing mm-less tasks;it is a no-op;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6314616203308105
it is no longer necessary to warn about killing mm-less tasks;it is a no-op;panic ASAP;want failover;Contradicts;0.521298885345459
it is no longer necessary to warn about killing mm-less tasks;it is a no-op;we must not skip this process;because its sub-thread originated the coredump;Contradicts;0.5698453783988953
it is no longer necessary to warn about killing mm-less tasks;it is a no-op;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5020040273666382
it is no longer necessary to warn about killing mm-less tasks;it is a no-op;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5748100876808167
it is no longer necessary to warn about killing mm-less tasks;it is a no-op;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6221621632575989
it is no longer necessary to warn about killing mm-less tasks;it is a no-op;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8746451735496521
it is no longer necessary to warn about killing mm-less tasks;it is a no-op;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6818580627441406
it is no longer necessary to warn about killing mm-less tasks;it is a no-op;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;Contradicts;0.6528971791267395
it is no longer necessary to warn about killing mm-less tasks;it is a no-op;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.5436021089553833
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.5437880754470825
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.6266550421714783
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;Contradicts;0.867327868938446
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Contradicts;0.5705838799476624
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;Remove this dubious PF_EXITING check;dubious;Contradicts;0.5566272139549255
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.5275328755378723
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.555432915687561
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.5626477599143982
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.6402156352996826
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.5252207517623901
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;Introduce is_init;to capture this case;Contradicts;0.5694165825843811
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.6043304204940796
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.6764570474624634
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9120756387710571
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9637935161590576
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5494017601013184
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6690713763237
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5189633965492249
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;Add the necessary rcu_read_lock();necessary;Contradicts;0.9013544321060181
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5597320795059204
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6943728923797607
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.7270506024360657
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6819716691970825
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.6221157312393188
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7021526098251343
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.520306408405304
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Contradicts;0.6392191648483276
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.6950019598007202
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.5546199083328247
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.5430313348770142
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5913610458374023
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.8045144081115723
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.5354325175285339
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5088216066360474
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5233117341995239
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7538928389549255
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9587295055389404
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.5900847911834717
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5278574228286743
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8157784938812256
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;Stick to accounting for half;Significant improvement;Contradicts;0.7390073537826538
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5425677299499512
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6747347712516785
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6223591566085815
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;Kill it and directly access;directly access;Contradicts;0.5147260427474976
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7359705567359924
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.6061772108078003
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;cleanup has_intersects_mems_allowed();oom;Contradicts;0.7808769941329956
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;it can be merged into that function at the same time;__oom_kill_task() only has a single caller;Contradicts;0.6125354170799255
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;Contradicts;0.5004681348800659
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6677560806274414
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.8956490755081177
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.5735922455787659
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Contradicts;0.5461677312850952
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.9952272176742554
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.8975353837013245
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5717800259590149
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.5274310111999512
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.8207902908325195
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;fix constraint deadlock;constraint deadlock;Contradicts;0.520301342010498
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.5719929933547974
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8522216081619263
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.50724858045578
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5679653882980347
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7895530462265015
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8945302963256836
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5960275530815125
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.561758279800415
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.7779582142829895
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5492348074913025
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5496201515197754
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5548878312110901
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6342231035232544
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.7852240800857544
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5732911229133606
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.6028656363487244
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;Kill it and directly access;directly access;Contradicts;0.8584233522415161
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;make the oom_reaper thread freezable;In order to close this race;Contradicts;0.5584709048271179
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.840794563293457
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;kill duplicate OOM_DISABLE check;duplicate;Contradicts;0.5288284420967102
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;dont try to kill oom_unkillable child;oom_unkillable;Contradicts;0.5935648679733276
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6929785013198853
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;Remove this dubious PF_EXITING check;dubious;Contradicts;0.5553463697433472
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Contradicts;0.6722492575645447
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;force oom kill on sysrq+f;oom;Contradicts;0.5402986407279968
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7056318521499634
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;Contradicts;0.6408789157867432
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.6822123527526855
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5401709675788879
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;panic ASAP;want failover;Contradicts;0.8695992827415466
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.8021965026855469
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.6287212371826172
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.6838239431381226
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5396885871887207
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.5218151211738586
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;we must not skip this process;because its sub-thread originated the coredump;Contradicts;0.6091143488883972
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7431417107582092
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7381415367126465
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9478530883789062
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5443646907806396
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.6054266095161438
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.9067856669425964
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.784111738204956
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.5052851438522339
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;Stick to accounting for half;Significant improvement;Contradicts;0.7357198596000671
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;Add the necessary rcu_read_lock();necessary;Contradicts;0.8106920719146729
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.5962788462638855
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7038354277610779
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;Have no license information of any form;GPL v2 only;Contradicts;0.8129801750183105
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.5583347678184509
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6930184960365295
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.7668067216873169
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5201958417892456
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;Kill it and directly access;directly access;Contradicts;0.6476238369941711
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Contradicts;0.6018743515014648
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.6558719277381897
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.9453167915344238
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;kill duplicate OOM_DISABLE check;duplicate;Contradicts;0.6002604365348816
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;dont try to kill oom_unkillable child;oom_unkillable;Contradicts;0.5205603837966919
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.5560576319694519
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;Contradicts;0.5146532654762268
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;Share the same oom_score_adj;As a result;Contradicts;0.7717635035514832
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.6086201071739197
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7541287541389465
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.5721797943115234
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.6055703163146973
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;Introduce is_init;to capture this case;Contradicts;0.5190035104751587
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.6064395308494568
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6823211312294006
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6636518239974976
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9370294213294983
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5159890055656433
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;remove task_t, convert to struct task_struct;cleanup, remove;Contradicts;0.9617614150047302
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.78412926197052
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6219704747200012
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8148780465126038
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5016936659812927
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;Stick to accounting for half;Significant improvement;Contradicts;0.5357294678688049
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7793968915939331
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;Have no license information of any form;GPL v2 only;Contradicts;0.7547668218612671
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6442232131958008
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.7728794813156128
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7005152702331543
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5862472653388977
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5063705444335938
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8134045600891113
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5352514982223511
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.549335241317749
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Use printk_ratelimit();to quieten it;Contradicts;0.7731258273124695
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.8344030976295471
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;dont try to kill oom_unkillable child;oom_unkillable;Contradicts;0.560167670249939
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;Contradicts;0.8337305188179016
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Contradicts;0.6193037033081055
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Contradicts;0.509527325630188
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.8878660202026367
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;Contradicts;0.7962914109230042
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.5173841118812561
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Remove this dubious PF_EXITING check;dubious;Contradicts;0.7432403564453125
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Contradicts;0.5142706632614136
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Contradicts;0.6870310306549072
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.5175997018814087
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.8835561275482178
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;Contradicts;0.6326372027397156
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.8237264156341553
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.65727299451828
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;Contradicts;0.5658540725708008
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7666406631469727
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;Contradicts;0.663413405418396
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.6460208892822266
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.6586440801620483
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Contradicts;0.6346898674964905
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.6194745302200317
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;Contradicts;0.6790366172790527
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Introduce is_sysrq_oom helper function;to improve readability;Contradicts;0.5871632099151611
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8682993650436401
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.7237609624862671
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7686316967010498
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6225264072418213
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;fixes the arg for mem_cgroup_print_oom_info();fixes;Contradicts;0.5411199331283569
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;Contradicts;0.514880895614624
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;select_bad_process() must select killable task;killable task;Contradicts;0.6363065838813782
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9897860288619995
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.6324512362480164
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.7397463321685791
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;Contradicts;0.744959831237793
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.7083034515380859
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.663525402545929
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.5686519742012024
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.7624959349632263
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8576744198799133
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;Contradicts;0.6768842935562134
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Fix it up via task_lock();instead;Contradicts;0.7962932586669922
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.7231736183166504
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5251778364181519
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;By giving root tasks a bonus that is proportional to their actual size;they remain comparable even when relatively small;Contradicts;0.5141024589538574
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.6446603536605835
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Add the necessary rcu_read_lock();necessary;Contradicts;0.8067344427108765
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.9335047602653503
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Have no license information of any form;GPL v2 only;Contradicts;0.7673247456550598
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Get/put across the for_each_thread() on the selected task;The easiest fix is;Contradicts;0.508033812046051
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.9800918102264404
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.9759407639503479
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.6343147158622742
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;Contradicts;0.5500652194023132
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7052300572395325
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.7678893804550171
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;make OOM detection in the freezer path raceless;raceless;Contradicts;0.593641996383667
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7871471047401428
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;mark_tsk_oom_victim is now called under task_lock;I think this should be OK because __thaw_task shouldnt interfere with any locking down wake_up_process;Contradicts;0.8699485659599304
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;fix vm_oom_kill_table[];ifdeffery;Contradicts;0.5300590991973877
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;delete unlock_range();exit_mmap() does not need locked_vm updates;Contradicts;0.5024501085281372
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5987460613250732
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;Contradicts;0.5359122157096863
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;Contradicts;0.5604587197303772
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.7099748849868774
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Kill it and directly access;directly access;Contradicts;0.7257187962532043
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;Contradicts;0.5334411263465881
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.8563452363014221
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.6700835227966309
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.6850618720054626
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6656738519668579
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.6901640295982361
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.540742039680481
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.8565354943275452
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.5332203507423401
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;Contradicts;0.5157617330551147
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.92540442943573
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;Remove the count;Its better to remove the count;Contradicts;0.5039257407188416
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;Contradicts;0.605638325214386
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.6432763338088989
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;Introduce is_init;to capture this case;Contradicts;0.5445030331611633
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.8004776835441589
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6883321404457092
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.5846621990203857
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7016168832778931
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9223048686981201
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5030430555343628
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.555952787399292
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7197370529174805
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.5698322653770447
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;Have no license information of any form;GPL v2 only;Contradicts;0.6973196268081665
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6537679433822632
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.56988924741745
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.6486528515815735
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6738277077674866
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.7016083598136902
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5383915901184082
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;Contradicts;0.5442935824394226
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;Kill it and directly access;directly access;Contradicts;0.8819542527198792
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;make the oom_reaper thread freezable;In order to close this race;Contradicts;0.5033769607543945
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.6059722900390625
fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.6579332947731018
fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.5488517880439758
fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.5515391230583191
fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.5421500205993652
fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;Share the same oom_score_adj;As a result;Contradicts;0.5366697907447815
fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;force oom kill on sysrq+f;oom;Contradicts;0.5248507857322693
fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5675463080406189
fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.5203022956848145
fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8973982930183411
fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.849184513092041
fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5562528371810913
fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5417495965957642
fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;Have no license information of any form;GPL v2 only;Contradicts;0.522227942943573
fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.7551310658454895
fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5990819334983826
fix possible oom_dump_tasks NULL pointer;possible oom_dump_tasks NULL pointer;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5700320601463318
There is no need to call for int_sqrt;if argument is 0;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;Contradicts;0.5653445720672607
There is no need to call for int_sqrt;if argument is 0;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.5658695697784424
There is no need to call for int_sqrt;if argument is 0;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;Contradicts;0.5378532409667969
There is no need to call for int_sqrt;if argument is 0;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.540352463722229
There is no need to call for int_sqrt;if argument is 0;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5417222380638123
There is no need to call for int_sqrt;if argument is 0;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.8092303276062012
There is no need to call for int_sqrt;if argument is 0;select_bad_process() must select killable task;killable task;Contradicts;0.7210484743118286
There is no need to call for int_sqrt;if argument is 0;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7619883418083191
There is no need to call for int_sqrt;if argument is 0;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.602943480014801
There is no need to call for int_sqrt;if argument is 0;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5916860103607178
There is no need to call for int_sqrt;if argument is 0;out_of_memory() locking fix;locking fix;Contradicts;0.5123624205589294
There is no need to call for int_sqrt;if argument is 0;account the memory consumption of the (direct) children to the father;we do want to;Contradicts;0.5188390612602234
There is no need to call for int_sqrt;if argument is 0;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5449199080467224
There is no need to call for int_sqrt;if argument is 0;Add the necessary rcu_read_lock();necessary;Contradicts;0.5742253065109253
There is no need to call for int_sqrt;if argument is 0;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.84061598777771
There is no need to call for int_sqrt;if argument is 0;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5002124905586243
There is no need to call for int_sqrt;if argument is 0;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.5085724592208862
There is no need to call for int_sqrt;if argument is 0;Introduce a struct zoneref to store a zone pointer and a zone index;Store a zone pointer and a zone index;Contradicts;0.5512994527816772
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.8454128503799438
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;kill duplicate OOM_DISABLE check;duplicate;Contradicts;0.5941449999809265
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6743550896644592
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.8817073702812195
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.5288875102996826
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.9117246270179749
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5154014825820923
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.939628541469574
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5873883962631226
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9921058416366577
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6925369501113892
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.6871079802513123
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5733795166015625
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.593672513961792
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.5678330063819885
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;Have no license information of any form;GPL v2 only;Contradicts;0.6658228635787964
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.7670212388038635
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;make OOM detection in the freezer path raceless;raceless;Contradicts;0.6141389608383179
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6143342852592468
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5023103952407837
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5690876245498657
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6465579271316528
avoid this deadlock;This patch;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.7160258293151855
avoid this deadlock;This patch;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8909358978271484
avoid this deadlock;This patch;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7870815396308899
avoid this deadlock;This patch;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6127064228057861
avoid unnecessary system-wide-oom-killer;unnecessary;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.6830415725708008
avoid unnecessary system-wide-oom-killer;unnecessary;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Contradicts;0.5207134485244751
avoid unnecessary system-wide-oom-killer;unnecessary;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.7663145661354065
avoid unnecessary system-wide-oom-killer;unnecessary;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.5772485136985779
avoid unnecessary system-wide-oom-killer;unnecessary;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.8516669869422913
avoid unnecessary system-wide-oom-killer;unnecessary;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.6783111095428467
avoid unnecessary system-wide-oom-killer;unnecessary;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.5095897912979126
avoid unnecessary system-wide-oom-killer;unnecessary;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8531315326690674
avoid unnecessary system-wide-oom-killer;unnecessary;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5098524689674377
avoid unnecessary system-wide-oom-killer;unnecessary;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6466554403305054
avoid unnecessary system-wide-oom-killer;unnecessary;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7156034708023071
avoid unnecessary system-wide-oom-killer;unnecessary;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5211408734321594
avoid unnecessary system-wide-oom-killer;unnecessary;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.7297782897949219
avoid unnecessary system-wide-oom-killer;unnecessary;"Users of mmap_sem which need it for write should be carefully reviewed to use _killable waiting as much as possible and reduce allocations requests done with the lock held to absolute minimum
";to reduce the risk even further;Contradicts;0.7218480110168457
set_current_state()/schedule_timeout();to reduce kernel size;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.5607345700263977
set_current_state()/schedule_timeout();to reduce kernel size;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7327899932861328
set_current_state()/schedule_timeout();to reduce kernel size;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.510456919670105
set_current_state()/schedule_timeout();to reduce kernel size;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5346609950065613
set_current_state()/schedule_timeout();to reduce kernel size;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5619654655456543
set_current_state()/schedule_timeout();to reduce kernel size;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7298069000244141
set_current_state()/schedule_timeout();to reduce kernel size;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9236894845962524
set_current_state()/schedule_timeout();to reduce kernel size;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.8638092279434204
set_current_state()/schedule_timeout();to reduce kernel size;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7070195078849792
set_current_state()/schedule_timeout();to reduce kernel size;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8388816714286804
set_current_state()/schedule_timeout();to reduce kernel size;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.537667989730835
set_current_state()/schedule_timeout();to reduce kernel size;Fix it up via task_lock();instead;Contradicts;0.6298630237579346
set_current_state()/schedule_timeout();to reduce kernel size;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.6736057996749878
set_current_state()/schedule_timeout();to reduce kernel size;Have no license information of any form;GPL v2 only;Contradicts;0.5911768674850464
set_current_state()/schedule_timeout();to reduce kernel size;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5037330985069275
set_current_state()/schedule_timeout();to reduce kernel size;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6189450621604919
set_current_state()/schedule_timeout();to reduce kernel size;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.550701916217804
keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.7452998161315918
keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5382459163665771
keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.707563579082489
keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.6150700449943542
keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6080948114395142
keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.897132396697998
keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6530811786651611
keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5559552907943726
keeps a task in or under one mem_exclusive cpuset;from provoking an oom kill of a task under a non-overlapping mem_exclusive cpuset;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.6596198081970215
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;Contradicts;0.5334354043006897
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;dont try to kill oom_unkillable child;oom_unkillable;Contradicts;0.5244067907333374
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Contradicts;0.7228931188583374
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;Contradicts;0.8235772848129272
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.5324500799179077
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.5422000288963318
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Remove this dubious PF_EXITING check;dubious;Contradicts;0.6782770752906799
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;Contradicts;0.8766111731529236
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.9737445712089539
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;Contradicts;0.5231226682662964
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;force oom kill on sysrq+f;oom;Contradicts;0.7353079319000244
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.877219021320343
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.6242459416389465
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7777895331382751
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Remove the count;Its better to remove the count;Contradicts;0.5868569016456604
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.543163537979126
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.6632578372955322
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Contradicts;0.5449587106704712
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Contradicts;0.5925490856170654
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;fix constraint deadlock;constraint deadlock;Contradicts;0.516744077205658
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.7350332140922546
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.6969596743583679
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.8799232244491577
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;Contradicts;0.5097721815109253
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;Contradicts;0.509755551815033
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.9530337452888489
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6497960686683655
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.6828941106796265
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.8416335582733154
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Contradicts;0.7482898235321045
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;select_bad_process() must select killable task;killable task;Contradicts;0.7355377674102783
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8095681071281433
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6363192796707153
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.7530745267868042
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.551373302936554
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.5942302346229553
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;Contradicts;0.7220961451530457
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.6154248118400574
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.8694837689399719
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6981093287467957
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.7702985405921936
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.5752868056297302
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.784922182559967
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.9394241571426392
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.9351270794868469
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.5704054832458496
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Stick to accounting for half;Significant improvement;Contradicts;0.7027997374534607
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.6488044261932373
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.6459351778030396
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6551182270050049
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Have no license information of any form;GPL v2 only;Contradicts;0.8987600803375244
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.928763747215271
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.8651437759399414
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.728287398815155
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5787238478660583
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Remove the parameter @mem;removed since v2.6.26;Contradicts;0.642319917678833
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6140251159667969
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.688143789768219
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Kill it and directly access;directly access;Contradicts;0.7846750020980835
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;skip zombies when iterating tasklist;oom;Contradicts;0.5145854353904724
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Find kill other threads that pin the same ->mm or find another task to kill.;Memory needs to be freed.;Contradicts;0.5331359505653381
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7214488983154297
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Add a missing newline;missing;Contradicts;0.5187970995903015
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.6711894273757935
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Contradicts;0.5565400123596191
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6998109221458435
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.8069908618927002
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Contradicts;0.5650909543037415
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.5038790106773376
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.6818838119506836
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.8010926246643066
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.5552207827568054
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.6596353054046631
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;Introduce is_init;to capture this case;Contradicts;0.6184204816818237
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.5641368627548218
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9225919246673584
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.6443023681640625
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6248482465744019
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6577503085136414
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;Contradicts;0.6690499782562256
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7171785831451416
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.8207917213439941
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6353219747543335
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;Contradicts;0.5063852667808533
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;Contradicts;0.6537335515022278
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7300602793693542
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;Have no license information of any form;GPL v2 only;Contradicts;0.6569883227348328
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.8207091689109802
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.7761911749839783
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5005303621292114
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;improve that even further;there is a common pattern to do a range lookup first and then do something about that;Contradicts;0.8378428220748901
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.9976246953010559
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;This way the memory is freed in a more controllable way with CPU affinity and priority of the caller;more controllable way with CPU affinity and priority of the caller;Contradicts;0.8377003073692322
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;Kill it and directly access;directly access;Contradicts;0.7867385745048523
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;skip zombies when iterating tasklist;oom;Contradicts;0.5435817837715149
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6202412843704224
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5436100959777832
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.7186251878738403
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6452880501747131
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6782446503639221
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6439054012298584
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.5535675287246704
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.7507942318916321
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.9701551795005798
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.633957028388977
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5248815417289734
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9396225214004517
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5525442957878113
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5202882885932922
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.804180920124054
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.721733570098877
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5273575782775879
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.5527432560920715
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7656394839286804
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;Have no license information of any form;GPL v2 only;Contradicts;0.7415874600410461
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5391031503677368
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6340156197547913
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6676836609840393
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7182384729385376
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6412515640258789
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.6111476421356201
Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.638367235660553
Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.5598862767219543
Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;Contradicts;0.6372302174568176
Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.6352502107620239
Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7745832204818726
Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6381479501724243
Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6908008456230164
Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.7320847511291504
Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;Have no license information of any form;GPL v2 only;Contradicts;0.6821544766426086
Let memory allocations for user space (GFP_USER) be constrained by a tasks current cpuset, but memory allocations for kernel space (GFP_KERNEL) be constrained by the nearest mem_exclusive ancestor of the current cpuset, even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset;even though kernel space allocations will still _prefer_ to remain within the current tasks cpuset, if memory is easily available;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5206820368766785
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.8617096543312073
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;kill duplicate OOM_DISABLE check;duplicate;Contradicts;0.515893280506134
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6224324107170105
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.7268694639205933
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.645568311214447
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.7493917346000671
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.5486062169075012
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.75078946352005
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.6832689046859741
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6023285388946533
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6364065408706665
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8676230907440186
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;Contradicts;0.812720775604248
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.77944016456604
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6614636182785034
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6556022763252258
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.7389068007469177
Let the oom killer be constrained to consider only tasks that are in overlapping mem_exclusive cpusets;it wont help much to kill a task that normally cannot allocate memory on any of the same nodes as the ones on which the current task can allocate.;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.73048996925354
Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.540492594242096
Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6247155070304871
Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6961789131164551
Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.560949981212616
Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8410873413085938
Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5910384654998779
Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6861736178398132
Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5093637108802795
Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5367884039878845
Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5387299060821533
Some minor cleanup, and some improvements to the code layout;to make subsequent patches cleaner;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.6353201866149902
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.5329091548919678
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Contradicts;0.512689471244812
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.6260184049606323
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5084633231163025
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.5342743396759033
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5854120254516602
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.8024380803108215
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5978785157203674
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7516130805015564
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7246488332748413
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.891836404800415
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7921693325042725
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;Have no license information of any form;GPL v2 only;Contradicts;0.590833842754364
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;This is done as 2 patches;so that no call site is forgotten especialy as it uses this following coccinelle patch;Contradicts;0.5737640261650085
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6960235238075256
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7445522546768188
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6167377233505249
Patch (1), the one time I looked on an SN2 (ia64) build, actually saved 32 bytes of kernel text space;actually saved 32 bytes of kernel text space;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.6918438076972961
Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6014757752418518
Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6672952771186829
Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7494274973869324
Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5202298164367676
Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6907097697257996
Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.5660898685455322
Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5534196496009827
Patches (3) and (4) added;about 600 bytes each of kernel text space, mostly in kernel/cpuset.c, which matters only if CONFIG_CPUSET is enabled;delete the corresponding comment;it will be checked in oom_unkillable_task();Contradicts;0.5193522572517395
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.9171719551086426
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;kill duplicate OOM_DISABLE check;duplicate;Contradicts;0.6477149724960327
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;dont try to kill oom_unkillable child;oom_unkillable;Contradicts;0.6048332452774048
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Contradicts;0.63344806432724
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.5118204355239868
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.5551031827926636
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Contradicts;0.6976865530014038
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Contradicts;0.7109358906745911
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.7345564961433411
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Contradicts;0.6642050743103027
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.9478389620780945
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;Contradicts;0.6374332308769226
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Contradicts;0.5090306401252747
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.6326460242271423
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.5670166611671448
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;fix constraint deadlock;constraint deadlock;Contradicts;0.5425630211830139
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.5605344176292419
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5832736492156982
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.5555012822151184
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;Contradicts;0.7495309710502625
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5633593201637268
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.8080927729606628
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6687723994255066
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;Contradicts;0.5077559351921082
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9971392154693604
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5994346737861633
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.552270233631134
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.7103206515312195
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.7163117527961731
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7420071959495544
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8380426168441772
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5360171794891357
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.8497006893157959
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8896900415420532
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Have no license information of any form;GPL v2 only;Contradicts;0.8022302389144897
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5066642165184021
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6265853643417358
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6314395666122437
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.7094950675964355
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6700220704078674
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6526027321815491
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.549422025680542
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6311756372451782
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;delete the corresponding comment;it will be checked in oom_unkillable_task();Contradicts;0.8850640654563904
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Kill it and directly access;directly access;Contradicts;0.5167738795280457
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.7701413035392761
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5212292671203613
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;skip zombies when iterating tasklist;oom;Contradicts;0.7060713768005371
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.7186104655265808
The comment changed in oom_kill.c was seriously misleading;seriously misleading;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.7857457399368286
The comment changed in oom_kill.c was seriously misleading;seriously misleading;kill duplicate OOM_DISABLE check;duplicate;Contradicts;0.6914198398590088
The comment changed in oom_kill.c was seriously misleading;seriously misleading;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6880045533180237
The comment changed in oom_kill.c was seriously misleading;seriously misleading;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.6232977509498596
The comment changed in oom_kill.c was seriously misleading;seriously misleading;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.6566998958587646
The comment changed in oom_kill.c was seriously misleading;seriously misleading;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5134674310684204
The comment changed in oom_kill.c was seriously misleading;seriously misleading;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.5185293555259705
The comment changed in oom_kill.c was seriously misleading;seriously misleading;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;Contradicts;0.5106028914451599
The comment changed in oom_kill.c was seriously misleading;seriously misleading;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8766393065452576
The comment changed in oom_kill.c was seriously misleading;seriously misleading;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;Contradicts;0.8396530151367188
The comment changed in oom_kill.c was seriously misleading;seriously misleading;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7810201048851013
The comment changed in oom_kill.c was seriously misleading;seriously misleading;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5594018697738647
The comment changed in oom_kill.c was seriously misleading;seriously misleading;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5016074776649475
The comment changed in oom_kill.c was seriously misleading;seriously misleading;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5434077978134155
The comment changed in oom_kill.c was seriously misleading;seriously misleading;Have no license information of any form;GPL v2 only;Contradicts;0.6112967133522034
The comment changed in oom_kill.c was seriously misleading;seriously misleading;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5712825059890747
The comment changed in oom_kill.c was seriously misleading;seriously misleading;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.8548235297203064
The comment changed in oom_kill.c was seriously misleading;seriously misleading;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.514496386051178
Use printk_ratelimit();to quieten it;has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;Contradicts;0.5166600942611694
Use printk_ratelimit();to quieten it;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Contradicts;0.520993173122406
Use printk_ratelimit();to quieten it;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5298246145248413
Use printk_ratelimit();to quieten it;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.9149708151817322
Use printk_ratelimit();to quieten it;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9071820378303528
Use printk_ratelimit();to quieten it;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.9045703411102295
Use printk_ratelimit();to quieten it;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.7031263709068298
Use printk_ratelimit();to quieten it;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.543936014175415
Use printk_ratelimit();to quieten it;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5537917017936707
Use printk_ratelimit();to quieten it;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.8871060609817505
Use printk_ratelimit();to quieten it;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5353772640228271
Use printk_ratelimit();to quieten it;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5771154761314392
Use printk_ratelimit();to quieten it;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.711043119430542
Use printk_ratelimit();to quieten it;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.8606225252151489
Use printk_ratelimit();to quieten it;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5381954908370972
Provides more debug info when the system is OOM;More debug info, system is OOM;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.7998629808425903
Provides more debug info when the system is OOM;More debug info, system is OOM;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.6442437767982483
Provides more debug info when the system is OOM;More debug info, system is OOM;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6010898351669312
Provides more debug info when the system is OOM;More debug info, system is OOM;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8926007151603699
Provides more debug info when the system is OOM;More debug info, system is OOM;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.609906017780304
Provides more debug info when the system is OOM;More debug info, system is OOM;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Contradicts;0.5750814080238342
Provides more debug info when the system is OOM;More debug info, system is OOM;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5460839867591858
Provides more debug info when the system is OOM;More debug info, system is OOM;Have no license information of any form;GPL v2 only;Contradicts;0.9212200045585632
Provides more debug info when the system is OOM;More debug info, system is OOM;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6193762421607971
Provides more debug info when the system is OOM;More debug info, system is OOM;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.580325722694397
Provides more debug info when the system is OOM;More debug info, system is OOM;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6543401479721069
Provides more debug info when the system is OOM;More debug info, system is OOM;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5806273818016052
Provides more debug info when the system is OOM;More debug info, system is OOM;This patch causes only memory information to be displayed for nodes that are allowed by currents cpuset when dumping the VM state;to prevent verbosity that can be harmful and cause other important messages to be scrolled from the kernel log and incur a significant time delay;Contradicts;0.8007947206497192
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Contradicts;0.514635443687439
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;dont try to kill oom_unkillable child;oom_unkillable;Contradicts;0.5859793424606323
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.655624270439148
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Issue a SIGKILL to any thread sharing the same mm;Were safe;Contradicts;0.9225598573684692
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Preventing the livelock;caring more about preventing the livelock;Contradicts;0.5134401917457581
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Contradicts;0.606108546257019
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;Contradicts;0.6475167870521545
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;Contradicts;0.8271818161010742
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.9264863133430481
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.5673384070396423
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.8488796949386597
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Contradicts;0.8987082242965698
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;force oom kill on sysrq+f;oom;Contradicts;0.968532383441925
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.9838082194328308
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.6230158805847168
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;Contradicts;0.6087995767593384
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7511710524559021
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Remove the count;Its better to remove the count;Contradicts;0.5449900031089783
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.9075447916984558
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;remove deprecated oom_adj;deprecated;Contradicts;0.5943536758422852
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.7863723635673523
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.5305875539779663
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.5189833045005798
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.6152323484420776
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.6580360531806946
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Introduce is_init;to capture this case;Contradicts;0.5291327834129333
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Contradicts;0.513511598110199
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.5055822730064392
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Contradicts;0.9211438894271851
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;Contradicts;0.6444045305252075
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5995673537254333
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.5201002955436707
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.6129381060600281
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.7736890316009521
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;Contradicts;0.5589573979377747
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.5344921350479126
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.7696573138237
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8052539229393005
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.6528230905532837
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.7904558777809143
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5499014258384705
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.8247938752174377
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Fix node-oriented allocation handling in oom-kill.c;bugfix;Contradicts;0.5449724197387695
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;Contradicts;0.808784544467926
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9285837411880493
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5866101384162903
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.7454941868782043
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.8093970417976379
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.6566586494445801
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;Contradicts;0.585603654384613
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Update the comments for __oom_kill_task();to reflect the code changes;Contradicts;0.6454925537109375
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;Contradicts;0.6359824538230896
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.5601221919059753
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7812015414237976
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8246960043907166
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.5750634074211121
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Stick to accounting for half;Significant improvement;Contradicts;0.7454754114151001
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.6542158722877502
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Contradicts;0.9179094433784485
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;Contradicts;0.871688961982727
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Change oom_kill.c to use for_each_thread();rather than the racy while_each_thread() which can loop forever if we race with exit;Contradicts;0.5785303115844727
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.6125702857971191
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.6529377102851868
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8130355477333069
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Have no license information of any form;GPL v2 only;Contradicts;0.7358505725860596
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5792376399040222
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6263412237167358
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5679842233657837
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5985956192016602
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.9664448499679565
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;Contradicts;0.6109522581100464
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.6020671725273132
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Remove the parameter @mem;removed since v2.6.26;Contradicts;0.6313337683677673
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.600857675075531
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5383484959602356
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6462618708610535
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Kill it and directly access;directly access;Contradicts;0.5720433592796326
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8241645693778992
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.5164274573326111
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5757974982261658
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5501962304115295
"create a separate ""historical"" git archive of that later";if we want to, and in the meantime its about 3.2GB when imported into git - space that would just make the early git days unnecessarily complicated, when we dont have a lot of good infrastructure for it;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5667603611946106
"create a separate ""historical"" git archive of that later";if we want to, and in the meantime its about 3.2GB when imported into git - space that would just make the early git days unnecessarily complicated, when we dont have a lot of good infrastructure for it;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6370440125465393
"create a separate ""historical"" git archive of that later";if we want to, and in the meantime its about 3.2GB when imported into git - space that would just make the early git days unnecessarily complicated, when we dont have a lot of good infrastructure for it;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5450171232223511
"create a separate ""historical"" git archive of that later";if we want to, and in the meantime its about 3.2GB when imported into git - space that would just make the early git days unnecessarily complicated, when we dont have a lot of good infrastructure for it;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.778721809387207
"create a separate ""historical"" git archive of that later";if we want to, and in the meantime its about 3.2GB when imported into git - space that would just make the early git days unnecessarily complicated, when we dont have a lot of good infrastructure for it;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6450426578521729
"create a separate ""historical"" git archive of that later";if we want to, and in the meantime its about 3.2GB when imported into git - space that would just make the early git days unnecessarily complicated, when we dont have a lot of good infrastructure for it;cap_safe_nice() only ever saw current, so now uses capable();only ever saw current, capable();Contradicts;0.5070188641548157
"create a separate ""historical"" git archive of that later";if we want to, and in the meantime its about 3.2GB when imported into git - space that would just make the early git days unnecessarily complicated, when we dont have a lot of good infrastructure for it;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5550128221511841
consider vfork();we dont have any reason;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5316189527511597
consider vfork();we dont have any reason;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.5353671312332153
consider vfork();we dont have any reason;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.9032042622566223
consider vfork();we dont have any reason;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5359092950820923
consider vfork();we dont have any reason;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6423966884613037
consider vfork();we dont have any reason;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5684958696365356
consider vfork();we dont have any reason;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.6569815278053284
cleanup has_intersects_mems_allowed();oom;oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Contradicts;0.5637617111206055
cleanup has_intersects_mems_allowed();oom;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.591166615486145
cleanup has_intersects_mems_allowed();oom;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7267941832542419
cleanup has_intersects_mems_allowed();oom;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.7181939482688904
cleanup has_intersects_mems_allowed();oom;Clean up the OOM killer messages;to be more consistent;Contradicts;0.5730238556861877
cleanup has_intersects_mems_allowed();oom;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5292288661003113
cleanup has_intersects_mems_allowed();oom;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6893300414085388
cleanup has_intersects_mems_allowed();oom;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.543497622013092
cleanup has_intersects_mems_allowed();oom;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.961542546749115
cleanup has_intersects_mems_allowed();oom;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.7753151059150696
cleanup has_intersects_mems_allowed();oom;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5045265555381775
cleanup has_intersects_mems_allowed();oom;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6982923746109009
cleanup has_intersects_mems_allowed();oom;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5257710814476013
cleanup has_intersects_mems_allowed();oom;Have no license information of any form;GPL v2 only;Contradicts;0.6397369503974915
cleanup has_intersects_mems_allowed();oom;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5603480935096741
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6676236391067505
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6259259581565857
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7296532988548279
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.7141445875167847
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5896537899971008
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7373581528663635
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7370173931121826
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6569639444351196
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8863935470581055
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5469362139701843
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.613554835319519
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7983484268188477
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5628893971443176
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;Have no license information of any form;GPL v2 only;Contradicts;0.7660278677940369
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.7064550518989563
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5768914222717285
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5365179181098938
has_intersects_mems_allowed() should use while_each_thread();has own thread iterate logic;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5368172526359558
kill duplicate OOM_DISABLE check;duplicate;dont try to kill oom_unkillable child;oom_unkillable;Contradicts;0.6042275428771973
kill duplicate OOM_DISABLE check;duplicate;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;Contradicts;0.8262661695480347
kill duplicate OOM_DISABLE check;duplicate;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.5026364922523499
kill duplicate OOM_DISABLE check;duplicate;Remove this dubious PF_EXITING check;dubious;Contradicts;0.6182029843330383
kill duplicate OOM_DISABLE check;duplicate;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Contradicts;0.6818652153015137
kill duplicate OOM_DISABLE check;duplicate;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.5734231472015381
kill duplicate OOM_DISABLE check;duplicate;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.9616995453834534
kill duplicate OOM_DISABLE check;duplicate;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.5968945622444153
kill duplicate OOM_DISABLE check;duplicate;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.7323336005210876
kill duplicate OOM_DISABLE check;duplicate;Introduce is_init;to capture this case;Contradicts;0.5325137376785278
kill duplicate OOM_DISABLE check;duplicate;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.5859073996543884
kill duplicate OOM_DISABLE check;duplicate;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9295799732208252
kill duplicate OOM_DISABLE check;duplicate;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5193379521369934
kill duplicate OOM_DISABLE check;duplicate;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9455313682556152
kill duplicate OOM_DISABLE check;duplicate;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.8894975781440735
kill duplicate OOM_DISABLE check;duplicate;panic is preferable rather than kill some processes;there are environments where panic is preferable;Contradicts;0.8876124024391174
kill duplicate OOM_DISABLE check;duplicate;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6916202306747437
kill duplicate OOM_DISABLE check;duplicate;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6794182658195496
kill duplicate OOM_DISABLE check;duplicate;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5466694831848145
kill duplicate OOM_DISABLE check;duplicate;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.817082941532135
kill duplicate OOM_DISABLE check;duplicate;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.8871037364006042
kill duplicate OOM_DISABLE check;duplicate;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5224387645721436
kill duplicate OOM_DISABLE check;duplicate;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6010425090789795
treat kernel thread honestly;/proc/<pid>/oom_score;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Contradicts;0.5010112524032593
treat kernel thread honestly;/proc/<pid>/oom_score;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.7497883439064026
treat kernel thread honestly;/proc/<pid>/oom_score;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5764918327331543
treat kernel thread honestly;/proc/<pid>/oom_score;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7790055871009827
treat kernel thread honestly;/proc/<pid>/oom_score;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5887531042098999
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.5662152767181396
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;fix NULL pointer dereference;NULL pointer dereference;Contradicts;0.5436108708381653
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Remove this dubious PF_EXITING check;dubious;Contradicts;0.6633346080780029
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.6010112762451172
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;Contradicts;0.6101137399673462
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Contradicts;0.5928919911384583
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;Contradicts;0.5779337286949158
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;make sure that the mmput_async is only called;when we do not back off and reap some memory;Contradicts;0.5588164925575256
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.8837061524391174
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.791588306427002
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;SIGBUS is triggered;the flag is set;Contradicts;0.6208782196044922
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.5009927749633789
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.6656371355056763
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Contradicts;0.6437197327613831
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Introduce is_init;to capture this case;Contradicts;0.752074122428894
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;suppress extraneous stack and memory dump;oom;Contradicts;0.6643964052200317
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.5704991817474365
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.6916758418083191
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5820232629776001
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7370592355728149
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";Contradicts;0.5601469874382019
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5001721978187561
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6865270137786865
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;select_bad_process() must select killable task;killable task;Contradicts;0.5385349988937378
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9552862048149109
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.9206472039222717
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;remove pointless kthread_run() error check;pointless;Contradicts;0.5211799144744873
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.7253899574279785
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;hold tasklist_lock;tsk->sighand is not guarded by RCU, just as what out_of_memory() does.;Contradicts;0.5127859711647034
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.5232871174812317
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6381018757820129
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.6246262192726135
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.768436849117279
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;simplify the API back to the single check;to simplify the API back;Contradicts;0.5100694298744202
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7238456010818481
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;Contradicts;0.5362611413002014
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.6835029721260071
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5772714018821716
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Add the necessary rcu_read_lock();necessary;Contradicts;0.5087200999259949
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.7176852226257324
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8118224740028381
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Have no license information of any form;GPL v2 only;Contradicts;0.5566959381103516
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Get/put across the for_each_thread() on the selected task;The easiest fix is;Contradicts;0.5583220720291138
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;Contradicts;0.6459952592849731
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5996972918510437
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;Contradicts;0.5094380974769592
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6453862190246582
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.522612988948822
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7040684819221497
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;fix vm_oom_kill_table[];ifdeffery;Contradicts;0.6370072364807129
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;Contradicts;0.5980634689331055
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.6298096776008606
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.7115071415901184
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;Contradicts;0.5006601214408875
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.7380698919296265
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Kill it and directly access;directly access;Contradicts;0.8255107998847961
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5751166939735413
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.5976530909538269
dont try to kill oom_unkillable child;oom_unkillable;It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;Contradicts;0.5907610058784485
dont try to kill oom_unkillable child;oom_unkillable;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6344743371009827
dont try to kill oom_unkillable child;oom_unkillable;Issue a SIGKILL to any thread sharing the same mm;Were safe;Contradicts;0.6087777018547058
dont try to kill oom_unkillable child;oom_unkillable;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.5760268568992615
dont try to kill oom_unkillable child;oom_unkillable;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.9920228719711304
dont try to kill oom_unkillable child;oom_unkillable;force oom kill on sysrq+f;oom;Contradicts;0.703023374080658
dont try to kill oom_unkillable child;oom_unkillable;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.7676553130149841
dont try to kill oom_unkillable child;oom_unkillable;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.5942331552505493
dont try to kill oom_unkillable child;oom_unkillable;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.7603309750556946
dont try to kill oom_unkillable child;oom_unkillable;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.9051265716552734
dont try to kill oom_unkillable child;oom_unkillable;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.6198853850364685
dont try to kill oom_unkillable child;oom_unkillable;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5263875722885132
dont try to kill oom_unkillable child;oom_unkillable;Introduce is_init;to capture this case;Contradicts;0.5737565159797668
dont try to kill oom_unkillable child;oom_unkillable;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.725975751876831
dont try to kill oom_unkillable child;oom_unkillable;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5675369501113892
dont try to kill oom_unkillable child;oom_unkillable;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8371546864509583
dont try to kill oom_unkillable child;oom_unkillable;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5406417846679688
dont try to kill oom_unkillable child;oom_unkillable;select_bad_process() must select killable task;killable task;Contradicts;0.7956840991973877
dont try to kill oom_unkillable child;oom_unkillable;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7217867970466614
dont try to kill oom_unkillable child;oom_unkillable;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5570616126060486
dont try to kill oom_unkillable child;oom_unkillable;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5896924734115601
dont try to kill oom_unkillable child;oom_unkillable;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5153002142906189
dont try to kill oom_unkillable child;oom_unkillable;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.5769443511962891
dont try to kill oom_unkillable child;oom_unkillable;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Contradicts;0.6739000082015991
dont try to kill oom_unkillable child;oom_unkillable;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.5937032103538513
dont try to kill oom_unkillable child;oom_unkillable;Have no license information of any form;GPL v2 only;Contradicts;0.5618839859962463
dont try to kill oom_unkillable child;oom_unkillable;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5321933627128601
dont try to kill oom_unkillable child;oom_unkillable;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.7000663876533508
dont try to kill oom_unkillable child;oom_unkillable;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.738496720790863
dont try to kill oom_unkillable child;oom_unkillable;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.6399497985839844
dont try to kill oom_unkillable child;oom_unkillable;Kill it and directly access;directly access;Contradicts;0.9846404790878296
dont try to kill oom_unkillable child;oom_unkillable;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7225344777107239
dont try to kill oom_unkillable child;oom_unkillable;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7734497785568237
dont try to kill oom_unkillable child;oom_unkillable;"Users of mmap_sem which need it for write should be carefully reviewed to use _killable waiting as much as possible and reduce allocations requests done with the lock held to absolute minimum
";to reduce the risk even further;Contradicts;0.5912882089614868
Fix it.;Fixes;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.587826669216156
Fix it.;Fixes;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9506991505622864
Fix it.;Fixes;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5445274710655212
Fix it.;Fixes;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.6335687637329102
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.5028982162475586
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.546666145324707
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.7467431426048279
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;Contradicts;0.8843815326690674
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Remove the count;Its better to remove the count;Contradicts;0.5623876452445984
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.5240190625190735
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;Contradicts;0.5231443643569946
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.7140244245529175
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.5088474750518799
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.8979879021644592
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5381003022193909
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.634476900100708
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.6556447744369507
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6045211553573608
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6807932257652283
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9529120922088623
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5688023567199707
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.7577970027923584
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.7042667269706726
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5701755881309509
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8696470260620117
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Stick to accounting for half;Significant improvement;Contradicts;0.604295551776886
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.6747715473175049
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.746135950088501
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.9072422981262207
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Have no license information of any form;GPL v2 only;Contradicts;0.5288489460945129
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5724197626113892
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.8003244400024414
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.512657642364502
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5836399793624878
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.6178070902824402
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.6389501094818115
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.7426342368125916
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;delete the corresponding comment;it will be checked in oom_unkillable_task();Contradicts;0.9446593523025513
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Kill it and directly access;directly access;Contradicts;0.5404228568077087
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6568658351898193
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6402615308761597
remove unnecessary code and cleanup;unnecessary code and cleanup;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5399757027626038
remove unnecessary code and cleanup;unnecessary code and cleanup;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8633631467819214
remove unnecessary code and cleanup;unnecessary code and cleanup;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8764044046401978
remove unnecessary code and cleanup;unnecessary code and cleanup;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.6160554885864258
Remove the redundancy in __oom_kill_task();redundancy;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6773592829704285
Remove the redundancy in __oom_kill_task();redundancy;Share the same oom_score_adj;As a result;Contradicts;0.5482438802719116
Remove the redundancy in __oom_kill_task();redundancy;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.7363162636756897
Remove the redundancy in __oom_kill_task();redundancy;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.604451596736908
Remove the redundancy in __oom_kill_task();redundancy;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9072669148445129
Remove the redundancy in __oom_kill_task();redundancy;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9576603770256042
Remove the redundancy in __oom_kill_task();redundancy;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6769493818283081
Remove the redundancy in __oom_kill_task();redundancy;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5835000872612
Remove the redundancy in __oom_kill_task();redundancy;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7833809852600098
moves the kernel log message to a higher level;verbosity is not always emitted here;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.5616891980171204
moves the kernel log message to a higher level;verbosity is not always emitted here;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5401915907859802
moves the kernel log message to a higher level;verbosity is not always emitted here;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6352958083152771
moves the kernel log message to a higher level;verbosity is not always emitted here;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.5208273530006409
moves the kernel log message to a higher level;verbosity is not always emitted here;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5663496255874634
moves the kernel log message to a higher level;verbosity is not always emitted here;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7647050023078918
moves the kernel log message to a higher level;verbosity is not always emitted here;Moving the test down;will give the desired behaviour;Contradicts;0.6846626400947571
moves the kernel log message to a higher level;verbosity is not always emitted here;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6801976561546326
moves the kernel log message to a higher level;verbosity is not always emitted here;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.640008807182312
moves the kernel log message to a higher level;verbosity is not always emitted here;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5284857153892517
it can be merged into that function at the same time;__oom_kill_task() only has a single caller;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.5262826681137085
Extract this to a helper function;to remove all the confusion as to its semantics;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.5499686598777771
Extract this to a helper function;to remove all the confusion as to its semantics;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5474324226379395
Extract this to a helper function;to remove all the confusion as to its semantics;Kill it and directly access;directly access;Contradicts;0.5945866703987122
Extract this to a helper function;to remove all the confusion as to its semantics;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5250546932220459
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Contradicts;0.6279808878898621
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.6910078525543213
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.5099945664405823
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6365121006965637
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.8872670531272888
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9155205488204956
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5341222882270813
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6980997920036316
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5236085057258606
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;Contradicts;0.5357775092124939
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6256357431411743
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.7697205543518066
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5821285843849182
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6858149766921997
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5360453128814697
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5168262124061584
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5559353232383728
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.7545420527458191
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5555004477500916
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;Kill it and directly access;directly access;Contradicts;0.6355857849121094
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.855398416519165
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6882286667823792
It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.8862695097923279
It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7160392999649048
It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6538498401641846
It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6137361526489258
It should be enabled by default;It emits useful information such as each eligible threads memory usage that can determine why the system is oom;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.5524981021881104
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;avoid unnecessary scanning;help to avoid unnecessary scanning if system doesnt have a swap device;Contradicts;0.7475749850273132
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;save roots task;better to save;Contradicts;0.9393123388290405
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.8456115126609802
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Remove this dubious PF_EXITING check;dubious;Contradicts;0.7529404163360596
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.7305341958999634
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;Contradicts;0.5164853930473328
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Contradicts;0.6064465641975403
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.6526762843132019
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.8565876483917236
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Remove the count;Its better to remove the count;Contradicts;0.6354929208755493
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Contradicts;0.7953009605407715
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.7356045842170715
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.6557233929634094
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.7018894553184509
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;Contradicts;0.5044001340866089
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.7458204627037048
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.6773701310157776
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.5084564685821533
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.6648313403129578
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.5768272876739502
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;Contradicts;0.652754008769989
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8683618307113647
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.6785909533500671
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.9010602831840515
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.8858079314231873
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.9363425970077515
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;Contradicts;0.5786346197128296
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9369191527366638
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.8111814260482788
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6830415725708008
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.6258258819580078
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.7882480025291443
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.502434253692627
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;hide it behind the helpers;With pid namespaces this field is now dangerous to use explicitly;Contradicts;0.5035997033119202
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;Contradicts;0.809348464012146
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.8339319229125977
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;remove task_t, convert to struct task_struct;cleanup, remove;Contradicts;0.5900288820266724
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.7542906403541565
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.7903969883918762
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.9496417045593262
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.8015169501304626
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7609813809394836
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5501702427864075
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Convert oom_zonelist_trylock() to return bool instead of int;Only success and failure are tested;Contradicts;0.6054420471191406
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5016628503799438
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Stick to accounting for half;Significant improvement;Contradicts;0.7765110731124878
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;move the cpuset semaphore region outside the tasklist_lock region;The fix seems easy enough;Contradicts;0.5066699385643005
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.8701791763305664
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.5076128244400024
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.8589997291564941
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8767879009246826
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.7175946831703186
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;initialize it before;should;Contradicts;0.6797260046005249
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Have no license information of any form;GPL v2 only;Contradicts;0.8053207397460938
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.7334361672401428
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7617915868759155
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.6345896124839783
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;make OOM detection in the freezer path raceless;raceless;Contradicts;0.6483921408653259
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.9438066482543945
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.7047178149223328
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.5810768008232117
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.8000701069831848
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Remove the parameter @mem;removed since v2.6.26;Contradicts;0.7790692448616028
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;cap_safe_nice() only ever saw current, so now uses capable();only ever saw current, capable();Contradicts;0.5381624698638916
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.7381142973899841
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.8874881267547607
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.7216882109642029
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Fix typo in comment: kthead -> kthread;typo;Contradicts;0.5749830603599548
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;remove the prototype for the old function;the prototype still existed;Contradicts;0.5112116932868958
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8010659217834473
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.9410224556922913
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;This patch causes only memory information to be displayed for nodes that are allowed by currents cpuset when dumping the VM state;to prevent verbosity that can be harmful and cause other important messages to be scrolled from the kernel log and incur a significant time delay;Contradicts;0.6962451934814453
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.784594714641571
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;skip zombies when iterating tasklist;oom;Contradicts;0.6835501194000244
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8840374946594238
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;Contradicts;0.7102621793746948
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Contradicts;0.581775426864624
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.5448748469352722
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;Contradicts;0.5596222877502441
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;make it as simple and predictable as possible;so the results are better understood and we end up killing the task which will lead to the most memory freeing while still respecting the fine-tuning from userspace;Contradicts;0.5743143558502197
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.8593352437019348
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;Contradicts;0.5288594961166382
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.5699251294136047
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Contradicts;0.5111040472984314
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.5147891640663147
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7025583982467651
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;significantly reduces the amount of time that it is held;isnt a complete solution to tasklist_lock starvation;Contradicts;0.6476542353630066
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.8886104822158813
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.5077875852584839
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5333357453346252
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.6437335014343262
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5221990942955017
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;Contradicts;0.7174854278564453
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7322325706481934
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5003128051757812
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.6213875412940979
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6746490597724915
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7047106027603149
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7591428756713867
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.7724538445472717
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.822819709777832
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;Contradicts;0.6070678234100342
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.5618546009063721
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6778132319450378
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Contradicts;0.5528773069381714
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6076220273971558
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.6861355304718018
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.956520676612854
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Stick to accounting for half;Significant improvement;Contradicts;0.5873585939407349
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.8042759895324707
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;By giving root tasks a bonus that is proportional to their actual size;they remain comparable even when relatively small;Contradicts;0.6960355043411255
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.894173264503479
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.8645028471946716
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5383307337760925
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6823432445526123
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7617741227149963
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;make OOM detection in the freezer path raceless;raceless;Contradicts;0.6401737332344055
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5147212147712708
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.7057244181632996
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6686098575592041
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;Kill it and directly access;directly access;Contradicts;0.7228156328201294
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5041097402572632
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.5679627060890198
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;Contradicts;0.7201040983200073
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;force oom kill on sysrq+f;oom;Contradicts;0.6245083808898926
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.7513622045516968
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.5677894949913025
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.784682035446167
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.5151311755180359
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Contradicts;0.5846343040466309
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.566943347454071
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.8074762225151062
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7764927744865417
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.611735463142395
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.6701722145080566
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6798047423362732
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.8266969323158264
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9141089916229248
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5216653347015381
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6744412779808044
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.8732881546020508
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8159564137458801
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.6977152824401855
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.7176660299301147
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8013997673988342
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.5605957508087158
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6088926196098328
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.8211697936058044
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.507630467414856
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.560391902923584
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Kill it and directly access;directly access;Contradicts;0.9057732820510864
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5398673415184021
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5627967119216919
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8338590860366821
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Remove this dubious PF_EXITING check;dubious;Contradicts;0.5214861631393433
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6197891235351562
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.8386327028274536
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;SIGBUS is triggered;the flag is set;Contradicts;0.5080763101577759
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;Contradicts;0.6242026686668396
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.5095052123069763
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.7057449817657471
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5648607611656189
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;Contradicts;0.5385413765907288
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;Contradicts;0.6818455457687378
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.5496729612350464
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5155619978904724
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7936748266220093
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7358764410018921
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9931730628013611
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6986743211746216
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;Contradicts;0.6924217343330383
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.5994928479194641
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.732465922832489
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8773203492164612
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;Contradicts;0.5399370193481445
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5825916528701782
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5957756042480469
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.814817488193512
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;"
MADV_PAGEOUT is similar to MADV_DONTNEED 
MADV_COLD is similar to MADV_FREE 
";"
it hints the kernel that memory region is not currently needed and should be reclaimed immediately 
it hints the kernel that memory region is not currently needed and should be reclaimed when memory pressure rises";Contradicts;0.7537063360214233
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Have no license information of any form;GPL v2 only;Contradicts;0.6369198560714722
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5661783814430237
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.569928765296936
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6590859889984131
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Contradicts;0.7337732315063477
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;make OOM detection in the freezer path raceless;raceless;Contradicts;0.5612374544143677
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.8020579814910889
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5505979657173157
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;Kill it and directly access;directly access;Contradicts;0.8537766337394714
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.6079590916633606
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7624637484550476
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.629371166229248
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.6259344816207886
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6097223162651062
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6042980551719666
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.637947678565979
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.79544597864151
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9116172194480896
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5027762651443481
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5029054284095764
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;Contradicts;0.577064573764801
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.5715449452400208
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7485718727111816
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7238051891326904
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.6243976950645447
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.7801923751831055
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6103705763816833
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.5052322149276733
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7370384931564331
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5769009590148926
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6148610711097717
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6482117176055908
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.6855449080467224
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6811206936836243
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.5385584235191345
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5376499891281128
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.7825790643692017
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;Contradicts;0.6546444296836853
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5160319209098816
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5744806528091431
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.5554296970367432
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.9136754870414734
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9381822943687439
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5526226758956909
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6255315542221069
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5086284875869751
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;Contradicts;0.5262073278427124
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8522588014602661
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5243092179298401
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.8751764893531799
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5290343165397644
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.5184355974197388
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;initialize it before;should;Contradicts;0.5419965386390686
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;Have no license information of any form;GPL v2 only;Contradicts;0.6079195737838745
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5174575448036194
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;make OOM detection in the freezer path raceless;raceless;Contradicts;0.5472519397735596
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7421438097953796
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Remove this dubious PF_EXITING check;dubious;Contradicts;0.5345544815063477
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5131479501724243
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.8006394505500793
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.6261221766471863
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;Contradicts;0.9034539461135864
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.510397732257843
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.6273647546768188
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.7504866719245911
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Introduce is_init;to capture this case;Contradicts;0.6796871423721313
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.729616105556488
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;Contradicts;0.6604231595993042
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.5267333388328552
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.6270724534988403
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5879664421081543
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7116631865501404
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5206242799758911
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.6281635761260986
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7479337453842163
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5938259959220886
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9950359463691711
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.6135632395744324
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;remove pointless kthread_run() error check;pointless;Contradicts;0.6038109660148621
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6436013579368591
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;Contradicts;0.6174658536911011
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7721555233001709
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;Contradicts;0.5652014017105103
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Stick to accounting for half;Significant improvement;Contradicts;0.8500027060508728
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;give the functions a kthread_ prefix;to better document the use case;Contradicts;0.520205557346344
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8326421976089478
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Have no license information of any form;GPL v2 only;Contradicts;0.7801389098167419
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5471593141555786
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5667470693588257
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Add comments describing oom_locks scope;describing oom_locks scope;Contradicts;0.6128591299057007
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.807041585445404
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Contradicts;0.5745781660079956
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5936284065246582
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Remove the parameter @mem;removed since v2.6.26;Contradicts;0.5899875164031982
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6252188086509705
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8324776291847229
put those freeable pages in inactive file LRU;it would make sense to;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6741809844970703
put those freeable pages in inactive file LRU;it would make sense to;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6546435356140137
put those freeable pages in inactive file LRU;it would make sense to;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5201935172080994
put those freeable pages in inactive file LRU;it would make sense to;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5178775787353516
put those freeable pages in inactive file LRU;it would make sense to;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5748768448829651
put those freeable pages in inactive file LRU;it would make sense to;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6709400415420532
give a bonus to make them be reclaimed on swapless system;could;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.546107828617096
give a bonus to make them be reclaimed on swapless system;could;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5726428627967834
give a bonus to make them be reclaimed on swapless system;could;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7085015177726746
give a bonus to make them be reclaimed on swapless system;could;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.6999876499176025
give a bonus to make them be reclaimed on swapless system;could;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.7086105942726135
give a bonus to make them be reclaimed on swapless system;could;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5269631743431091
give a bonus to make them be reclaimed on swapless system;could;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6060467958450317
give a bonus to make them be reclaimed on swapless system;could;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8966146111488342
give a bonus to make them be reclaimed on swapless system;could;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7897549271583557
give a bonus to make them be reclaimed on swapless system;could;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6245090365409851
give a bonus to make them be reclaimed on swapless system;could;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5330978035926819
give a bonus to make them be reclaimed on swapless system;could;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5711052417755127
give a bonus to make them be reclaimed on swapless system;could;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7208751440048218
reclaiming them requires swap-out/in in the end;its bigger cost;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.637672483921051
reclaiming them requires swap-out/in in the end;its bigger cost;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.5235809087753296
reclaiming them requires swap-out/in in the end;its bigger cost;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6043625473976135
reclaiming them requires swap-out/in in the end;its bigger cost;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6953834295272827
reclaiming them requires swap-out/in in the end;its bigger cost;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.7952807545661926
reclaiming them requires swap-out/in in the end;its bigger cost;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6924245953559875
reclaiming them requires swap-out/in in the end;its bigger cost;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7051859498023987
reclaiming them requires swap-out/in in the end;its bigger cost;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6462896466255188
reclaiming them requires swap-out/in in the end;its bigger cost;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9097198843955994
reclaiming them requires swap-out/in in the end;its bigger cost;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5692569017410278
reclaiming them requires swap-out/in in the end;its bigger cost;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5895387530326843
reclaiming them requires swap-out/in in the end;its bigger cost;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7581396102905273
reclaiming them requires swap-out/in in the end;its bigger cost;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7191610336303711
reclaiming them requires swap-out/in in the end;its bigger cost;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.523135781288147
reclaiming them requires swap-out/in in the end;its bigger cost;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.6498319506645203
reclaiming them requires swap-out/in in the end;its bigger cost;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.8886087536811829
reclaiming them requires swap-out/in in the end;its bigger cost;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.8411583304405212
reclaiming them requires swap-out/in in the end;its bigger cost;Kill it and directly access;directly access;Contradicts;0.7670902013778687
reclaiming them requires swap-out/in in the end;its bigger cost;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5889552235603333
better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6093338131904602
better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6862001419067383
better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5511587262153625
better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7652425765991211
better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.7885334491729736
better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5095542669296265
better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;Have no license information of any form;GPL v2 only;Contradicts;0.5684519410133362
better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5357774496078491
better to position inactive anons LRU list;based on cost-model, anonymous cold pages would be better;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5672950744628906
avoid unnecessary scanning;help to avoid unnecessary scanning if system doesnt have a swap device;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.5926389098167419
avoid unnecessary scanning;help to avoid unnecessary scanning if system doesnt have a swap device;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.506005585193634
avoid unnecessary scanning;help to avoid unnecessary scanning if system doesnt have a swap device;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5208944082260132
avoid unnecessary scanning;help to avoid unnecessary scanning if system doesnt have a swap device;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5433588027954102
Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6049508452415466
Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;Contradicts;0.6954459547996521
Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6342683434486389
Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5661078095436096
Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6389695405960083
Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.506020724773407
Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5493158102035522
Lets start simpler way without adding complexity at this moment;without adding complexity at this moment;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7976027131080627
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.5426421761512756
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.554764449596405
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Contradicts;0.6620185375213623
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Contradicts;0.6785935163497925
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.7366551160812378
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Contradicts;0.6585107445716858
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5975889563560486
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.6381943821907043
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;Contradicts;0.7393409013748169
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.8391100764274597
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.897721529006958
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.5459535717964172
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Contradicts;0.5242154598236084
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.5539500117301941
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Contradicts;0.5287202000617981
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5242123603820801
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Introduce is_init;to capture this case;Contradicts;0.6861394047737122
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;suppress extraneous stack and memory dump;oom;Contradicts;0.5436068177223206
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.9895562529563904
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.82679283618927
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.5994618535041809
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.8014637231826782
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5722951292991638
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.7151268720626831
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";Contradicts;0.7152809500694275
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.6876044869422913
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.576439619064331
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6460649967193604
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9322550296783447
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5251218676567078
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6282200813293457
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.6906530857086182
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.5872323513031006
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6277382969856262
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.6539458632469177
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6989926695823669
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.6470690965652466
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Stick to accounting for half;Significant improvement;Contradicts;0.5877497792243958
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.6105243563652039
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.9425869584083557
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5808019042015076
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.8170644044876099
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Have no license information of any form;GPL v2 only;Contradicts;0.9942891597747803
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.6384442448616028
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;Contradicts;0.7315382361412048
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.8758665323257446
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;Contradicts;0.7584342956542969
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7378038167953491
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7281768918037415
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.5134555697441101
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;delete unlock_range();exit_mmap() does not need locked_vm updates;Contradicts;0.5821447372436523
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5171553492546082
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.7351802587509155
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5343296527862549
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;delete the corresponding comment;it will be checked in oom_unkillable_task();Contradicts;0.5075864195823669
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.6253663301467896
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8950793743133545
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;This patch causes only memory information to be displayed for nodes that are allowed by currents cpuset when dumping the VM state;to prevent verbosity that can be harmful and cause other important messages to be scrolled from the kernel log and incur a significant time delay;Contradicts;0.7929521203041077
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.7261003851890564
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;avoid attempting to kill init sharing same memory;avoid attempting to kill init;Contradicts;0.6316684484481812
printing this value;the only documentation of the value for the process being killed;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6370232701301575
printing this value;the only documentation of the value for the process being killed;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.8631051778793335
printing this value;the only documentation of the value for the process being killed;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.8255112767219543
printing this value;the only documentation of the value for the process being killed;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6150311827659607
The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.8688395023345947
The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.5805392265319824
The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.7088372111320496
The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.512163519859314
The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6581377983093262
The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6497637629508972
The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;Have no license information of any form;GPL v2 only;Contradicts;0.6666882038116455
The addition of the pgtables_bytes ;is a useful measure of the memory size of the process.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6489112973213196
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6076394319534302
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.58430016040802
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7344196438789368
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5371319651603699
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;hide it behind the helpers;With pid namespaces this field is now dangerous to use explicitly;Contradicts;0.5420650839805603
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5608734488487244
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6699012517929077
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.7168787717819214
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;Have no license information of any form;GPL v2 only;Contradicts;0.8687375783920288
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.933809220790863
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7246102690696716
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6644209623336792
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5750755667686462
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;This patch causes only memory information to be displayed for nodes that are allowed by currents cpuset when dumping the VM state;to prevent verbosity that can be harmful and cause other important messages to be scrolled from the kernel log and incur a significant time delay;Contradicts;0.5837782621383667
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.6566523313522339
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5003238916397095
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.8577791452407837
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Contradicts;0.7581280469894409
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;Contradicts;0.5242729783058167
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;Contradicts;0.7137004137039185
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;force oom kill on sysrq+f;oom;Contradicts;0.5131527781486511
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.7756727337837219
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.5778037905693054
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.8037271499633789
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8743599653244019
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6165202856063843
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;Contradicts;0.5232309699058533
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9601075053215027
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6284148693084717
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;Stick to accounting for half;Significant improvement;Contradicts;0.6605222225189209
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.5890116691589355
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;Have no license information of any form;GPL v2 only;Contradicts;0.580737829208374
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5526084303855896
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.8499101996421814
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6079687476158142
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5643856525421143
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.9162005186080933
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7751275897026062
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;Kill it and directly access;directly access;Contradicts;0.595763087272644
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.9159671664237976
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5189561247825623
remove redundant task_in_mem_cgroup() check;redundant;Remove this dubious PF_EXITING check;dubious;Contradicts;0.5627996325492859
remove redundant task_in_mem_cgroup() check;redundant;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6502745747566223
remove redundant task_in_mem_cgroup() check;redundant;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.5404998064041138
remove redundant task_in_mem_cgroup() check;redundant;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7202571630477905
remove redundant task_in_mem_cgroup() check;redundant;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7239086031913757
remove redundant task_in_mem_cgroup() check;redundant;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8369929790496826
remove redundant task_in_mem_cgroup() check;redundant;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5039272308349609
remove redundant task_in_mem_cgroup() check;redundant;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7264675498008728
remove redundant task_in_mem_cgroup() check;redundant;Add the necessary rcu_read_lock();necessary;Contradicts;0.6404399275779724
remove redundant task_in_mem_cgroup() check;redundant;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.7457298636436462
remove redundant task_in_mem_cgroup() check;redundant;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.8448880910873413
remove redundant task_in_mem_cgroup() check;redundant;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.5102699995040894
remove redundant task_in_mem_cgroup() check;redundant;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.5964359641075134
remove redundant task_in_mem_cgroup() check;redundant;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.589853048324585
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.5441202521324158
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.5197265148162842
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;Contradicts;0.5032070279121399
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;Contradicts;0.5905930995941162
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;Contradicts;0.6478842496871948
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.9248720407485962
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;Contradicts;0.5966827273368835
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5850902199745178
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Introduce is_init;to capture this case;Contradicts;0.6832260489463806
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";suppress extraneous stack and memory dump;oom;Contradicts;0.5193301439285278
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Contradicts;0.5709612369537354
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";fix constraint deadlock;constraint deadlock;Contradicts;0.5253522396087646
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.664734423160553
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";panic ASAP;want failover;Contradicts;0.503890335559845
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.613445520401001
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;Contradicts;0.5376274585723877
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Introduce is_sysrq_oom helper function;to improve readability;Contradicts;0.5453978180885315
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.6088578701019287
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7287979125976562
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7348110675811768
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";select_bad_process();it makes consistency more and makes speed up;Contradicts;0.5976929664611816
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9189197421073914
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.6188374757766724
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.7294099926948547
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.5610027313232422
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;Contradicts;0.721372127532959
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Update the comments for __oom_kill_task();to reflect the code changes;Contradicts;0.5592302680015564
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5385482311248779
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.5069791078567505
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;Contradicts;0.5178093910217285
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.9063016176223755
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;Contradicts;0.6423608660697937
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.8770576119422913
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Stick to accounting for half;Significant improvement;Contradicts;0.626974880695343
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.6491830945014954
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;Contradicts;0.6625116467475891
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5371596813201904
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Change oom_kill.c to use for_each_thread();rather than the racy while_each_thread() which can loop forever if we race with exit;Contradicts;0.5834729671478271
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.737195611000061
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.6369101405143738
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.9021994471549988
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Have no license information of any form;GPL v2 only;Contradicts;0.800979495048523
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.505619466304779
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.521877110004425
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;Contradicts;0.6672977209091187
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.807981550693512
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5238996744155884
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;Contradicts;0.6099717617034912
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6137501001358032
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.612162172794342
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.5528308749198914
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";fix vm_oom_kill_table[];ifdeffery;Contradicts;0.6301935911178589
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;Contradicts;0.5665339231491089
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";delete unlock_range();exit_mmap() does not need locked_vm updates;Contradicts;0.5807883739471436
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;Contradicts;0.5078766345977783
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.6137956380844116
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.5656089186668396
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Remove the parameter @mem;removed since v2.6.26;Contradicts;0.5769510269165039
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5350797772407532
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;Contradicts;0.620863676071167
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5353869199752808
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.501667320728302
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";skip zombies when iterating tasklist;oom;Contradicts;0.5033243298530579
fix uninitialized oc->constraint;uninitialized;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.5165058970451355
fix uninitialized oc->constraint;uninitialized;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7044820189476013
fix uninitialized oc->constraint;uninitialized;Introduce is_init;to capture this case;Contradicts;0.5027573108673096
fix uninitialized oc->constraint;uninitialized;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5161977410316467
fix uninitialized oc->constraint;uninitialized;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9463487863540649
fix uninitialized oc->constraint;uninitialized;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8377577066421509
fix uninitialized oc->constraint;uninitialized;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5345877408981323
fix uninitialized oc->constraint;uninitialized;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5684800744056702
fix uninitialized oc->constraint;uninitialized;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5423054099082947
fix uninitialized oc->constraint;uninitialized;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5837830305099487
fix uninitialized oc->constraint;uninitialized;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5494721531867981
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.7646780014038086
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.6344021558761597
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Contradicts;0.6104227900505066
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;Contradicts;0.6412683725357056
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.7875223159790039
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;Introduce is_init;to capture this case;Contradicts;0.6881768703460693
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5572723150253296
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;Introduce is_sysrq_oom helper function;to improve readability;Contradicts;0.6267999410629272
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9049578309059143
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.6132241487503052
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8511565923690796
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5609998106956482
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.7282887101173401
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5309616327285767
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;Fix it up via task_lock();instead;Contradicts;0.5972926020622253
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;Contradicts;0.5040544867515564
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6976562142372131
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5340224504470825
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6043926477432251
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;Contradicts;0.6151959300041199
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5323286652565002
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;delete unlock_range();exit_mmap() does not need locked_vm updates;Contradicts;0.574830174446106
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.5387011766433716
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.8080005645751953
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;Contradicts;0.6930056214332581
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.5296043753623962
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;prevent unnecessary oom kills or kernel panics;unnecessary oom kills or kernel panics;Contradicts;0.5551837086677551
This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7273048162460327
This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.8015474081039429
This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.9129094481468201
This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.520997166633606
This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7018408179283142
This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5561441779136658
This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6310363411903381
This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5376741290092468
This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.514997124671936
This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6285151839256287
Issue a SIGKILL to any thread sharing the same mm;Were safe;avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;Contradicts;0.7844305634498596
Issue a SIGKILL to any thread sharing the same mm;Were safe;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Contradicts;0.5361239910125732
Issue a SIGKILL to any thread sharing the same mm;Were safe;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.7137703895568848
Issue a SIGKILL to any thread sharing the same mm;Were safe;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.6508621573448181
Issue a SIGKILL to any thread sharing the same mm;Were safe;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.9684728980064392
Issue a SIGKILL to any thread sharing the same mm;Were safe;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.6692438125610352
Issue a SIGKILL to any thread sharing the same mm;Were safe;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.7629973888397217
Issue a SIGKILL to any thread sharing the same mm;Were safe;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9363452196121216
Issue a SIGKILL to any thread sharing the same mm;Were safe;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.822709858417511
Issue a SIGKILL to any thread sharing the same mm;Were safe;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.6211636066436768
Issue a SIGKILL to any thread sharing the same mm;Were safe;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;Contradicts;0.8256010413169861
Issue a SIGKILL to any thread sharing the same mm;Were safe;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.6580294966697693
Issue a SIGKILL to any thread sharing the same mm;Were safe;panic is preferable rather than kill some processes;there are environments where panic is preferable;Contradicts;0.6891578435897827
Issue a SIGKILL to any thread sharing the same mm;Were safe;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6784882545471191
Issue a SIGKILL to any thread sharing the same mm;Were safe;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.798011302947998
Issue a SIGKILL to any thread sharing the same mm;Were safe;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.628400444984436
Issue a SIGKILL to any thread sharing the same mm;Were safe;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.6926468014717102
Issue a SIGKILL to any thread sharing the same mm;Were safe;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;Contradicts;0.5041128396987915
Issue a SIGKILL to any thread sharing the same mm;Were safe;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5746490359306335
Issue a SIGKILL to any thread sharing the same mm;Were safe;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6443970203399658
Issue a SIGKILL to any thread sharing the same mm;Were safe;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.5582876205444336
Issue a SIGKILL to any thread sharing the same mm;Were safe;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5173624753952026
Issue a SIGKILL to any thread sharing the same mm;Were safe;avoid attempting to kill init sharing same memory;avoid attempting to kill init;Contradicts;0.8931500315666199
Preventing the livelock;caring more about preventing the livelock;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Contradicts;0.5452331304550171
Preventing the livelock;caring more about preventing the livelock;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.714432954788208
Preventing the livelock;caring more about preventing the livelock;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8699062466621399
Preventing the livelock;caring more about preventing the livelock;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6049690246582031
Preventing the livelock;caring more about preventing the livelock;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.9062715172767639
Preventing the livelock;caring more about preventing the livelock;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5281158685684204
Preventing the livelock;caring more about preventing the livelock;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5875016450881958
Preventing the livelock;caring more about preventing the livelock;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.7244206666946411
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.5041708946228027
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.9202899932861328
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;force oom kill on sysrq+f;oom;Contradicts;0.5795639753341675
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.9114421010017395
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5013424754142761
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Contradicts;0.5388835668563843
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.6635870933532715
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6437126994132996
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6933497786521912
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;Contradicts;0.5939152240753174
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9684464931488037
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5182629823684692
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5766295790672302
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.5861567854881287
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5138046145439148
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5274001955986023
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5891293287277222
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;Kill it and directly access;directly access;Contradicts;0.784113883972168
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5617201328277588
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5796881318092346
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.793938934803009
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Remove this dubious PF_EXITING check;dubious;Contradicts;0.5298181772232056
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Contradicts;0.664181113243103
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Contradicts;0.5039390921592712
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.7569063305854797
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Contradicts;0.8800963759422302
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.8725947737693787
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Remove the count;Its better to remove the count;Contradicts;0.722074568271637
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.6107714772224426
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.660258948802948
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;Contradicts;0.5105401277542114
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.5249993205070496
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5217592716217041
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.5419337153434753
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5196046233177185
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5897834300994873
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.5700352787971497
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8491135835647583
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5213683843612671
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.7066754102706909
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.544086217880249
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9809746742248535
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.8307934403419495
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;Contradicts;0.7373876571655273
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;Contradicts;0.5712020993232727
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.6060817837715149
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.8239971995353699
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6983681321144104
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Contradicts;0.7243613004684448
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6725142598152161
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Stick to accounting for half;Significant improvement;Contradicts;0.7604721784591675
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.68888258934021
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.9103249311447144
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Remove the unused arguments and update all callers.;unused.;Contradicts;0.5400334596633911
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Remove the unused arguments and update all callers.;unused;Contradicts;0.5400334596633911
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7669652700424194
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.8547351956367493
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Have no license information of any form;GPL v2 only;Contradicts;0.5933489799499512
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5991485118865967
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5079315900802612
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5909841656684875
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.7446996569633484
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7533476948738098
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;make OOM detection in the freezer path raceless;raceless;Contradicts;0.6713556051254272
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7661389112472534
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5917467474937439
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.742929220199585
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.6581388711929321
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5710852146148682
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;skip zombies when iterating tasklist;oom;Contradicts;0.5431424975395203
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.6367307305335999
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;Contradicts;0.6236847043037415
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.7591627836227417
Reduces confusion;Users currently dont know which tasks in the tasklist arent eligible for kill;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6012921929359436
Reduces confusion;Users currently dont know which tasks in the tasklist arent eligible for kill;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7458616495132446
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.5291666984558105
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.643977701663971
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.5210478901863098
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.9004099369049072
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6080340147018433
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9204038977622986
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5100611448287964
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.8121334910392761
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5067917704582214
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6110379695892334
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;Have no license information of any form;GPL v2 only;Contradicts;0.5122339129447937
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6392483711242676
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6267938017845154
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6086951494216919
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7175142168998718
fix NULL pointer dereference;NULL pointer dereference;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.5650827884674072
fix NULL pointer dereference;NULL pointer dereference;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5958688855171204
fix NULL pointer dereference;NULL pointer dereference;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5679733753204346
fix NULL pointer dereference;NULL pointer dereference;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7435535192489624
fix NULL pointer dereference;NULL pointer dereference;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7348403334617615
fix NULL pointer dereference;NULL pointer dereference;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5486371517181396
make it as simple and predictable as possible;so the results are better understood and we end up killing the task which will lead to the most memory freeing while still respecting the fine-tuning from userspace;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6942088603973389
make it as simple and predictable as possible;so the results are better understood and we end up killing the task which will lead to the most memory freeing while still respecting the fine-tuning from userspace;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.8074288964271545
make it as simple and predictable as possible;so the results are better understood and we end up killing the task which will lead to the most memory freeing while still respecting the fine-tuning from userspace;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5196682810783386
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.5665953755378723
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;Contradicts;0.5125978589057922
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.845022976398468
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;SIGBUS is triggered;the flag is set;Contradicts;0.6546885967254639
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8254726529121399
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5606307983398438
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6122141480445862
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6391156315803528
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5888516306877136
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.8744827508926392
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6345049142837524
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6877597570419312
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;Stick to accounting for half;Significant improvement;Contradicts;0.5824095606803894
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5396683216094971
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.8739814162254333
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5413659811019897
KDE or GNOME is chosen for oom kill on desktop systems;help specifically in cases where;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.8694111108779907
save roots task;better to save;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.5929645299911499
save roots task;better to save;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5683010816574097
save roots task;better to save;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.9204674959182739
save roots task;better to save;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.776301920413971
save roots task;better to save;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5400261282920837
save roots task;better to save;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.626822829246521
save roots task;better to save;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.6275902390480042
introduce a new user interface to tune it;Because of the change in the badness() heuristics baseline;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6214984059333801
introduce a new user interface to tune it;Because of the change in the badness() heuristics baseline;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7274242639541626
introduce a new user interface to tune it;Because of the change in the badness() heuristics baseline;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6249277591705322
introduce a new user interface to tune it;Because of the change in the badness() heuristics baseline;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5755481719970703
introduce a new user interface to tune it;Because of the change in the badness() heuristics baseline;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.520987868309021
introduce a new user interface to tune it;Because of the change in the badness() heuristics baseline;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5260805487632751
introduce a new user interface to tune it;Because of the change in the badness() heuristics baseline;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6519522666931152
Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.528849184513092
Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;Share the same oom_score_adj;As a result;Contradicts;0.6022757887840271
Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5383895039558411
Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.773402750492096
Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.8994767069816589
Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5289714336395264
Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7451733946800232
Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7017013430595398
Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5921452045440674
Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5739494562149048
Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5175164341926575
Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.8120142221450806
Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7215525507926941
Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;Kill it and directly access;directly access;Contradicts;0.7112041115760803
Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6802119016647339
Redefine the meaning of /proc/pid/oom_adj with a new scale;The ABI cannot be changed for backward compatibility;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6673049330711365
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.5541818737983704
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Share the same oom_score_adj;As a result;Contradicts;0.704066276550293
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Contradicts;0.5784716010093689
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.7759650945663452
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.539149284362793
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.679038941860199
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.5902624130249023
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.6188331246376038
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;Contradicts;0.7799621820449829
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Introduce is_init;to capture this case;Contradicts;0.5756164193153381
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.5223522782325745
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6074953675270081
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7247251272201538
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9855388402938843
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.6450268030166626
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.537543535232544
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.515976071357727
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.62757807970047
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6690300703048706
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7676665782928467
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Have no license information of any form;GPL v2 only;Contradicts;0.5735779404640198
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6760731935501099
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.587704062461853
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5689425468444824
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Kill it and directly access;directly access;Contradicts;0.6400083303451538
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5193763971328735
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5620424151420593
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5351361036300659
Remove this dubious PF_EXITING check;dubious;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.5248386263847351
Remove this dubious PF_EXITING check;dubious;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.5282915234565735
Remove this dubious PF_EXITING check;dubious;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Contradicts;0.8153830766677856
Remove this dubious PF_EXITING check;dubious;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5532717704772949
Remove this dubious PF_EXITING check;dubious;Introduce is_init;to capture this case;Contradicts;0.537560224533081
Remove this dubious PF_EXITING check;dubious;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9678029417991638
Remove this dubious PF_EXITING check;dubious;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5265142321586609
Remove this dubious PF_EXITING check;dubious;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;Contradicts;0.7132031321525574
Remove this dubious PF_EXITING check;dubious;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8045605421066284
Remove this dubious PF_EXITING check;dubious;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.6127514243125916
Remove this dubious PF_EXITING check;dubious;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7714842557907104
Remove this dubious PF_EXITING check;dubious;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5329400300979614
Remove this dubious PF_EXITING check;dubious;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6397092938423157
Remove this dubious PF_EXITING check;dubious;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7851830720901489
Remove this dubious PF_EXITING check;dubious;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6775057911872864
Remove this dubious PF_EXITING check;dubious;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.579713761806488
Remove this dubious PF_EXITING check;dubious;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6147298812866211
Remove this dubious PF_EXITING check;dubious;considered a reasonable constrain;the overall system health is more important than debugability of a particular application;Contradicts;0.7468937039375305
add the protection of multi threaded issue;protection of multi threaded issue;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6895530223846436
add the protection of multi threaded issue;protection of multi threaded issue;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5876460671424866
add the protection of multi threaded issue;protection of multi threaded issue;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.8572232127189636
add the protection of multi threaded issue;protection of multi threaded issue;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7599762082099915
add the protection of multi threaded issue;protection of multi threaded issue;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.5715824961662292
add the protection of multi threaded issue;protection of multi threaded issue;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5570576190948486
add the protection of multi threaded issue;protection of multi threaded issue;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6227614879608154
add the protection of multi threaded issue;protection of multi threaded issue;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.5442156195640564
add the protection of multi threaded issue;protection of multi threaded issue;Kill it and directly access;directly access;Contradicts;0.7150418162345886
add the protection of multi threaded issue;protection of multi threaded issue;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5334982872009277
giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;Contradicts;0.9701312780380249
giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Contradicts;0.8420583605766296
giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5335032939910889
giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.9638588428497314
giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5722613334655762
giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Contradicts;0.5764114260673523
giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.540404736995697
giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.632073700428009
giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5684332251548767
giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.5911255478858948
giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.577125608921051
giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.586818516254425
giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5654823184013367
Using SCHED_FIFO:1 with the lowest RT priority;This task wont interfere with any running RT task;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.7040187120437622
Using SCHED_FIFO:1 with the lowest RT priority;This task wont interfere with any running RT task;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8436502814292908
Using SCHED_FIFO:1 with the lowest RT priority;This task wont interfere with any running RT task;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8353116512298584
Using SCHED_FIFO:1 with the lowest RT priority;This task wont interfere with any running RT task;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.7461979389190674
Using SCHED_FIFO:1 with the lowest RT priority;This task wont interfere with any running RT task;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5034538507461548
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.5079643130302429
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.8231638073921204
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.5573463439941406
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6663934588432312
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;Remove the count;Its better to remove the count;Contradicts;0.5134943723678589
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;Contradicts;0.626952052116394
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;Introduce is_init;to capture this case;Contradicts;0.6039251089096069
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.6209574341773987
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.6617358922958374
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7475952506065369
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;select_bad_process() must select killable task;killable task;Contradicts;0.813704252243042
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9093525409698486
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5811890959739685
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7517141103744507
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6903634667396545
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5885800719261169
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.6944314241409302
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;Have no license information of any form;GPL v2 only;Contradicts;0.6568410396575928
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6734459400177002
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;improve that even further;there is a common pattern to do a range lookup first and then do something about that;Contradicts;0.9647380709648132
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5514981150627136
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.7781861424446106
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7213945388793945
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5968958139419556
deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6356723308563232
deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.676913857460022
deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.5350014567375183
deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5986831188201904
deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9395585656166077
deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.6383635997772217
deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5181306004524231
deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7091047763824463
deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5447825789451599
deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5724483132362366
deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6219726800918579
deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;Have no license information of any form;GPL v2 only;Contradicts;0.7956293821334839
deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5950672030448914
deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.6006541848182678
fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6770622134208679
fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.8695888519287109
fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.6321505904197693
fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9355951547622681
fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7269646525382996
fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9070180058479309
fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5606536865234375
fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5977789163589478
fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6322241425514221
fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();Fix it up via task_lock();instead;Contradicts;0.7613899111747742
fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.573842465877533
fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5360103249549866
fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6651526689529419
fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.6399635076522827
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.9196491241455078
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.743392288684845
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.5005500316619873
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.5125125050544739
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.610219419002533
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.5801780223846436
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.797813892364502
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.556790828704834
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;Contradicts;0.5757963061332703
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.535942554473877
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5439894795417786
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5665164589881897
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.6195729970932007
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.568692147731781
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7343560457229614
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6154162287712097
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5118972659111023
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;Contradicts;0.7373616695404053
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;Contradicts;0.5385299921035767
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;Contradicts;0.5063645243644714
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9666697978973389
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7479274272918701
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.6301577091217041
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7249714732170105
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5801420211791992
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5661689043045044
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.9888556599617004
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Contradicts;0.6645389795303345
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Fix the setting of PF_SUPERPRIV by __capable();it could corrupt the flags of the target process if that is not the current process and it is trying to change its own flags in a different way at the same time;Contradicts;0.527653694152832
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Kill it and directly access;directly access;Contradicts;0.96465665102005
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.816457211971283
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.618346631526947
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5086889266967773
do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.672745406627655
do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5854707360267639
do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.6931177973747253
do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.606389045715332
do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.8484551310539246
do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.735261082649231
do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5183103084564209
do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5801655650138855
do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;Kill it and directly access;directly access;Contradicts;0.517170786857605
do not attempt to reap a task more than twice;do not attempt to reap a task more than twice;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6149299144744873
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.8303772211074829
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.5997553467750549
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5162053108215332
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;Contradicts;0.633039116859436
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.549816906452179
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.5515480041503906
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Introduce is_init;to capture this case;Contradicts;0.540238618850708
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.501764178276062
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.6810458302497864
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;Contradicts;0.6966980695724487
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7271487712860107
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.5115420818328857
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6459352374076843
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;Contradicts;0.6387493014335632
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.980414867401123
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;Contradicts;0.5315277576446533
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;hold tasklist_lock;tsk->sighand is not guarded by RCU, just as what out_of_memory() does.;Contradicts;0.6571378707885742
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.8301973342895508
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6448769569396973
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;account the memory consumption of the (direct) children to the father;we do want to;Contradicts;0.5475614666938782
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Stick to accounting for half;Significant improvement;Contradicts;0.5836616158485413
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.5196988582611084
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6110185384750366
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.9637911915779114
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.644835889339447
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Contradicts;0.564658522605896
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;make OOM detection in the freezer path raceless;raceless;Contradicts;0.5420147180557251
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.7344719767570496
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6500751972198486
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Kill it and directly access;directly access;Contradicts;0.9239727258682251
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.9602887630462646
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.752415120601654
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;skip zombies when iterating tasklist;oom;Contradicts;0.5508045554161072
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.8293426036834717
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;Contradicts;0.6228170990943909
mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;force oom kill on sysrq+f;oom;Contradicts;0.5112414956092834
mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.8154172301292419
mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.5257880687713623
mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.837594747543335
mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7830028533935547
mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7416001558303833
mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6109034419059753
mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.8716886639595032
mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6873854398727417
mitigate the risk of OOM deadlock;considerably while we still try really hard to perform all reclaim attempts and stay predictable in the behavior.;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.5447046756744385
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;force oom kill on sysrq+f;oom;Contradicts;0.5327144861221313
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.7507494688034058
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7096593379974365
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.6122131943702698
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5252294540405273
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Introduce is_init;to capture this case;Contradicts;0.591985821723938
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5105500221252441
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.5376771092414856
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Introduce is_sysrq_oom helper function;to improve readability;Contradicts;0.5689923167228699
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;we must not skip this process;because its sub-thread originated the coredump;Contradicts;0.9313011169433594
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6715403199195862
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6898928284645081
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6501173377037048
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;select_bad_process() must select killable task;killable task;Contradicts;0.5534417033195496
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.928740382194519
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.527575671672821
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6059690117835999
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.59527188539505
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.6092197895050049
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8663981556892395
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.7536761164665222
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;convert it to atomic_long_t;to avoid races;Contradicts;0.5068153142929077
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.5368541479110718
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7517419457435608
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Have no license information of any form;GPL v2 only;Contradicts;0.7775372266769409
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5301575064659119
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6188932061195374
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.9512616991996765
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;Contradicts;0.6110326647758484
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;Contradicts;0.5454996824264526
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5152219533920288
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.500573992729187
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5089563131332397
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;introduce a dedicated system call to cover this use case;to cover this use case;Contradicts;0.5123860836029053
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5242276191711426
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Kill it and directly access;directly access;Contradicts;0.8402993083000183
replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7942423820495605
replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.5748862028121948
replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.660449206829071
replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5541409850120544
replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8275583386421204
replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.9584692120552063
replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6390777230262756
replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.537747859954834
replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;Have no license information of any form;GPL v2 only;Contradicts;0.6148234009742737
replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5733076930046082
replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5164253115653992
replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6489585041999817
replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;Contradicts;0.5578796863555908
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.6909119486808777
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;force oom kill on sysrq+f;oom;Contradicts;0.5475749969482422
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.8306900262832642
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.7800388336181641
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.7212228178977966
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5707993507385254
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.541854739189148
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5228712558746338
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9884097576141357
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.7085533738136292
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.800855278968811
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;Contradicts;0.5184592604637146
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6451300978660583
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8544019460678101
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.7670086026191711
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Contradicts;0.5117706060409546
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5819286704063416
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5200175046920776
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.6972782611846924
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.519551694393158
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;Kill it and directly access;directly access;Contradicts;0.6317715644836426
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7378474473953247
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;Contradicts;0.5471659898757935
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.6129916906356812
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5311810970306396
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Contradicts;0.7318252325057983
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.9511706829071045
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.8539674878120422
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.7661378979682922
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7442327737808228
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5993015170097351
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6463802456855774
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.569616436958313
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.9252411127090454
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5007367730140686
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;OOM killed task shouldnt escape PM suspend;OOM;Contradicts;0.6598448753356934
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.6203087568283081
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.6043961644172668
drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Contradicts;0.531522810459137
drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6290145516395569
drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5654554963111877
drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.5955998301506042
drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.6094567775726318
drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;Contradicts;0.7001488208770752
drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8697758316993713
drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9356251358985901
drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5869907736778259
drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5441757440567017
drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5170065760612488
drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.7551436424255371
drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6671987771987915
drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5553807616233826
Share the same oom_score_adj;As a result;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5327844619750977
Share the same oom_score_adj;As a result;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7545636892318726
Share the same oom_score_adj;As a result;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5579921007156372
Share the same oom_score_adj;As a result;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.8492757081985474
make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.5661969780921936
make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5942755937576294
make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.5329549908638
make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.5046627521514893
make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8577853441238403
make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5441907644271851
make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8907939195632935
make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6423602104187012
make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5265532732009888
make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.667319118976593
make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.504689633846283
make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.7947207093238831
make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5874481797218323
make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5683175325393677
make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;Kill it and directly access;directly access;Contradicts;0.5660483241081238
make sure that mmput_async is called only when memory was reaped;to ensure that mmput_async is only called when memory was reaped;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5984007120132446
make sure that the mmput_async is only called;when we do not back off and reap some memory;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5838497877120972
make sure that the mmput_async is only called;when we do not back off and reap some memory;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9187334775924683
make sure that the mmput_async is only called;when we do not back off and reap some memory;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6200847625732422
make sure that the mmput_async is only called;when we do not back off and reap some memory;Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;Contradicts;0.5140655040740967
make sure that the mmput_async is only called;when we do not back off and reap some memory;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6673343777656555
make sure that the mmput_async is only called;when we do not back off and reap some memory;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5319727063179016
make sure that the mmput_async is only called;when we do not back off and reap some memory;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5030643939971924
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.7227261066436768
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6602660417556763
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.550891637802124
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5309047102928162
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.6578278541564941
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5641233921051025
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8769727945327759
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5776039361953735
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9820636510848999
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5114685297012329
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.6730485558509827
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6670740842819214
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8078412413597107
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5781289339065552
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5678671002388
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.600365936756134
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5788412094116211
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.8196483850479126
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5506792664527893
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.6214274168014526
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.6032921671867371
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6422740817070007
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5229644775390625
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.8961778283119202
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;Kill it and directly access;directly access;Contradicts;0.6898066997528076
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8776810765266418
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;"This is identical to the global oom killer and is done even before checking for panic_on_oom: a pending SIGKILL here while panic_on_oom is selected is guaranteed to have come from userspace; the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory.";the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory;Contradicts;0.6747753024101257
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7425937056541443
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5524402260780334
remove unused argument from oom_scan_process_thread();unused argument;force oom kill on sysrq+f;oom;Contradicts;0.5051320195198059
remove unused argument from oom_scan_process_thread();unused argument;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.610297441482544
remove unused argument from oom_scan_process_thread();unused argument;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.554570734500885
remove unused argument from oom_scan_process_thread();unused argument;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.853939414024353
remove unused argument from oom_scan_process_thread();unused argument;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9289954900741577
remove unused argument from oom_scan_process_thread();unused argument;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5933722257614136
remove unused argument from oom_scan_process_thread();unused argument;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Contradicts;0.5300431847572327
remove unused argument from oom_scan_process_thread();unused argument;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6615352034568787
remove unused argument from oom_scan_process_thread();unused argument;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5340024828910828
remove unused argument from oom_scan_process_thread();unused argument;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5208501815795898
remove unused argument from oom_scan_process_thread();unused argument;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6742411851882935
remove unused argument from oom_scan_process_thread();unused argument;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.792375922203064
remove unused argument from oom_scan_process_thread();unused argument;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.6839572787284851
remove unused argument from oom_scan_process_thread();unused argument;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5271478891372681
remove unused argument from oom_scan_process_thread();unused argument;Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.5129317045211792
remove unused argument from oom_scan_process_thread();unused argument;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.5463006496429443
remove unused argument from oom_scan_process_thread();unused argument;Kill it and directly access;directly access;Contradicts;0.545428454875946
avoid pointless atomic_inc_not_zero usage;pointless;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;Contradicts;0.5104073286056519
avoid pointless atomic_inc_not_zero usage;pointless;Introduce is_init;to capture this case;Contradicts;0.6053888201713562
avoid pointless atomic_inc_not_zero usage;pointless;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.876075804233551
avoid pointless atomic_inc_not_zero usage;pointless;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5755262970924377
avoid pointless atomic_inc_not_zero usage;pointless;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6760510802268982
avoid pointless atomic_inc_not_zero usage;pointless;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9088588356971741
avoid pointless atomic_inc_not_zero usage;pointless;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.686836838722229
avoid pointless atomic_inc_not_zero usage;pointless;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.6531087160110474
avoid pointless atomic_inc_not_zero usage;pointless;Have no license information of any form;GPL v2 only;Contradicts;0.5405005812644958
avoid pointless atomic_inc_not_zero usage;pointless;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5395996570587158
avoid pointless atomic_inc_not_zero usage;pointless;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5372916460037231
avoid pointless atomic_inc_not_zero usage;pointless;Kill it and directly access;directly access;Contradicts;0.5078390836715698
avoid pointless atomic_inc_not_zero usage;pointless;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5148592591285706
avoid pointless atomic_inc_not_zero usage;pointless;"Users of mmap_sem which need it for write should be carefully reviewed to use _killable waiting as much as possible and reduce allocations requests done with the lock held to absolute minimum
";to reduce the risk even further;Contradicts;0.7100590467453003
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Contradicts;0.6964238882064819
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;Contradicts;0.5813654661178589
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.94746994972229
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Remove the count;Its better to remove the count;Contradicts;0.8328566551208496
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;Contradicts;0.5046330094337463
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.9431933760643005
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.7683367729187012
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.7572123408317566
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.5711251497268677
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.7697513699531555
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.6429533958435059
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.719779372215271
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.6151294112205505
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;Contradicts;0.5116421580314636
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.6332069635391235
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9132379293441772
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.666348934173584
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.7711434960365295
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6359351873397827
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7484703063964844
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.951137125492096
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5860964059829712
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.7195995450019836
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;Contradicts;0.8662110567092896
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;Contradicts;0.575320839881897
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.6120214462280273
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.5502035617828369
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7317241430282593
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.547326922416687
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.5772113800048828
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7093960642814636
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Fix it up via task_lock();instead;Contradicts;0.6649218797683716
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.7740225791931152
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Stick to accounting for half;Significant improvement;Contradicts;0.8521130084991455
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.6137053966522217
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.748601496219635
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7320769429206848
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Have no license information of any form;GPL v2 only;Contradicts;0.7495945692062378
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.6194359064102173
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5662568807601929
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.6899624466896057
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7991642951965332
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5688450336456299
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.5379372835159302
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.7732310891151428
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.7670913338661194
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;remove the prototype for the old function;the prototype still existed;Contradicts;0.7270742058753967
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Kill it and directly access;directly access;Contradicts;0.7245194315910339
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5593787431716919
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8017164468765259
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5580986142158508
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;skip zombies when iterating tasklist;oom;Contradicts;0.514288604259491
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6753458380699158
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;make the oom_reaper thread freezable;In order to close this race;Contradicts;0.6332015991210938
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;Contradicts;0.6632214188575745
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.8617316484451294
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.785443127155304
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;SIGBUS is triggered;the flag is set;Contradicts;0.5588447451591492
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6075855493545532
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5822286009788513
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5102534294128418
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;Contradicts;0.5891797542572021
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8167508840560913
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5691323280334473
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5581678152084351
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6509897112846375
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.8016552329063416
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5818197727203369
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;Have no license information of any form;GPL v2 only;Contradicts;0.6729055643081665
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.7025650143623352
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;make OOM detection in the freezer path raceless;raceless;Contradicts;0.5120015144348145
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;Kill it and directly access;directly access;Contradicts;0.6813748478889465
The rest of the users of struct cred are left for other patches;there are too many changes to make in one go and leave the change reviewable;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5097836852073669
force oom kill on sysrq+f;oom;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.9903081059455872
force oom kill on sysrq+f;oom;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.6272203326225281
force oom kill on sysrq+f;oom;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.6167725920677185
force oom kill on sysrq+f;oom;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5473225712776184
force oom kill on sysrq+f;oom;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9716376066207886
force oom kill on sysrq+f;oom;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5658572316169739
force oom kill on sysrq+f;oom;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8441298007965088
force oom kill on sysrq+f;oom;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6296319365501404
force oom kill on sysrq+f;oom;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.9105663299560547
force oom kill on sysrq+f;oom;panic is preferable rather than kill some processes;there are environments where panic is preferable;Contradicts;0.8378188610076904
force oom kill on sysrq+f;oom;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5526259541511536
force oom kill on sysrq+f;oom;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Contradicts;0.7908309698104858
force oom kill on sysrq+f;oom;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7623446583747864
force oom kill on sysrq+f;oom;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5812970399856567
force oom kill on sysrq+f;oom;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.7148774862289429
force oom kill on sysrq+f;oom;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;Contradicts;0.5197437405586243
force oom kill on sysrq+f;oom;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5238007307052612
force oom kill on sysrq+f;oom;prevent unnecessary oom kills or kernel panics;unnecessary oom kills or kernel panics;Contradicts;0.6310596466064453
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5395693778991699
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.7894975543022156
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.9958349466323853
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;SIGBUS is triggered;the flag is set;Contradicts;0.5185307860374451
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;Contradicts;0.7794138789176941
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.6050109267234802
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.6413170099258423
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9140267968177795
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5034478902816772
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6121180057525635
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7443369030952454
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5293264985084534
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6159095764160156
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7673611044883728
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5446219444274902
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;Contradicts;0.5157174468040466
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8622056245803833
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.8136602640151978
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5109316110610962
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;Contradicts;0.6801459789276123
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;This patch fixes the problem and should be backported into stable/LTS.;Fixes the problem, should be backported into stable/LTS.;Contradicts;0.5331392288208008
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;allow privileged processes to receive SIGIO on files theyre manipulating;privileged processes;Contradicts;0.5221213698387146
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.697425901889801
Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.5787927508354187
Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;we must not skip this process;because its sub-thread originated the coredump;Contradicts;0.8594553470611572
Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5214270353317261
Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9478787183761597
Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5936840772628784
Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.7016037702560425
Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;start isolating the tons of warnings;cannot be sent right now as this leads to tons of warnings;Contradicts;0.8898607492446899
Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5185410976409912
Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.823732852935791
Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5279209017753601
Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5278210639953613
Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5191182494163513
Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7054243683815002
Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.5305333733558655
Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.6332203149795532
silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6644187569618225
silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.5370574593544006
silently return the oom killer;its only giving access to memory reserves and is otherwise a no-op;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5297664403915405
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6939150094985962
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.5219193696975708
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.593895673751831
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6744842529296875
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.6870158910751343
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6198047995567322
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.52953040599823
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;Contradicts;0.5223960876464844
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.869367778301239
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5589432716369629
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.7593444585800171
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7584571242332458
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5750792622566223
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.9629665613174438
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.528243899345398
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.54969322681427
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5482161045074463
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5908879041671753
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5121718645095825
avoid looping when chosen thread detaches its mm;mm, oom;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8468344211578369
avoid looping when chosen thread detaches its mm;mm, oom;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8993935585021973
avoid looping when chosen thread detaches its mm;mm, oom;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.6317106485366821
avoid looping when chosen thread detaches its mm;mm, oom;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5878216624259949
avoid looping when chosen thread detaches its mm;mm, oom;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.679168701171875
avoid looping when chosen thread detaches its mm;mm, oom;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5390293002128601
avoid looping when chosen thread detaches its mm;mm, oom;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.5400962233543396
avoid looping when chosen thread detaches its mm;mm, oom;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7820836305618286
return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6378688216209412
return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.6185795664787292
return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7777484655380249
return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5591397285461426
return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6140072345733643
return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5148224234580994
return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8125495314598083
return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.6929923295974731
return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.6561574935913086
return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.509337306022644
return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5185734629631042
return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;Have no license information of any form;GPL v2 only;Contradicts;0.5273609161376953
return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6228276491165161
return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;Kill it and directly access;directly access;Contradicts;0.5454525351524353
return to the page allocator and retry the allocation;memory could have been freed in the interim and the oom condition may no longer exist;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7301976680755615
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7796117663383484
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;Remove the count;Its better to remove the count;Contradicts;0.7891577482223511
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.6276125907897949
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.6240331530570984
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7017263770103455
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5349928140640259
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9370241761207581
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5160490870475769
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6229957342147827
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.5821910500526428
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7444807887077332
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.555729866027832
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.7595142126083374
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;Have no license information of any form;GPL v2 only;Contradicts;0.7928256988525391
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5936400890350342
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5887573957443237
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.5419567227363586
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;Kill it and directly access;directly access;Contradicts;0.5432254076004028
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6326820850372314
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5771497488021851
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.7474393248558044
adds some tracepoints useful for debugging;useful for debugging;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.8696849346160889
adds some tracepoints useful for debugging;useful for debugging;Remove the count;Its better to remove the count;Contradicts;0.8932453989982605
adds some tracepoints useful for debugging;useful for debugging;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.5701579451560974
adds some tracepoints useful for debugging;useful for debugging;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5859850645065308
adds some tracepoints useful for debugging;useful for debugging;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7560935020446777
adds some tracepoints useful for debugging;useful for debugging;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5017947554588318
adds some tracepoints useful for debugging;useful for debugging;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5432300567626953
adds some tracepoints useful for debugging;useful for debugging;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.587342381477356
adds some tracepoints useful for debugging;useful for debugging;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5280524492263794
adds some tracepoints useful for debugging;useful for debugging;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.5537694096565247
adds some tracepoints useful for debugging;useful for debugging;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.5794355273246765
adds some tracepoints useful for debugging;useful for debugging;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.5391545295715332
adds some tracepoints useful for debugging;useful for debugging;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.5937201380729675
adds some tracepoints useful for debugging;useful for debugging;Have no license information of any form;GPL v2 only;Contradicts;0.7023866772651672
adds some tracepoints useful for debugging;useful for debugging;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.565214216709137
adds some tracepoints useful for debugging;useful for debugging;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5313495397567749
adds some tracepoints useful for debugging;useful for debugging;Kill it and directly access;directly access;Contradicts;0.7607860565185547
adds some tracepoints useful for debugging;useful for debugging;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5914603471755981
adds some tracepoints useful for debugging;useful for debugging;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.6638549566268921
adds some tracepoints useful for debugging;useful for debugging;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.7040631175041199
fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.7733739018440247
fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.6109107136726379
fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.5536962747573853
fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8639540076255798
fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9294591546058655
fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5393247604370117
fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.647682249546051
fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5479421019554138
The points variable should be of type long instead of int;to prevent the int overflow;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.5876561403274536
The points variable should be of type long instead of int;to prevent the int overflow;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5690229535102844
The points variable should be of type long instead of int;to prevent the int overflow;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6183850765228271
The points variable should be of type long instead of int;to prevent the int overflow;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5932655930519104
The points variable should be of type long instead of int;to prevent the int overflow;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5478817224502563
The points variable should be of type long instead of int;to prevent the int overflow;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.8205668926239014
The points variable should be of type long instead of int;to prevent the int overflow;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5883691310882568
Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.6144779920578003
Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.827915370464325
Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.525833249092102
Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5804532170295715
Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9759669899940491
Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.7052704691886902
Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;Update the comments for __oom_kill_task();to reflect the code changes;Contradicts;0.5922369956970215
Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6289339065551758
Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5045501589775085
Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.698418140411377
Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.6092883944511414
Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6228422522544861
Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.7065264582633972
Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7189014554023743
Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7879863381385803
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.8951513171195984
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;remove deprecated oom_adj;deprecated;Contradicts;0.7406647801399231
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.5162891149520874
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.5309668183326721
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5710368752479553
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Introduce is_init;to capture this case;Contradicts;0.7942338585853577
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5880130529403687
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5918311476707458
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.5554365515708923
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.8829692602157593
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Introduce is_sysrq_oom helper function;to improve readability;Contradicts;0.8215858936309814
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5756056308746338
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6212059259414673
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6776975393295288
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Contradicts;0.5989838242530823
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;Contradicts;0.6774080991744995
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8888220191001892
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;remove pointless kthread_run() error check;pointless;Contradicts;0.6013763546943665
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.8854277729988098
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.6317017078399658
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6581191420555115
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.5955057144165039
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7360905408859253
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5253098011016846
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Fix it up via task_lock();instead;Contradicts;0.5010088682174683
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.7059566974639893
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5939937829971313
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Stick to accounting for half;Significant improvement;Contradicts;0.7927441596984863
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.7889683842658997
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5118024945259094
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Have no license information of any form;GPL v2 only;Contradicts;0.8233957290649414
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.5035921335220337
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.5486918091773987
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6974696516990662
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;Contradicts;0.6941395998001099
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.7466435432434082
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;Contradicts;0.5836405158042908
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5528669953346252
A new compare_swap_oom_score_adj() function is introduced;To fix this, with the same semantics as the compare and swap CAS instruction, or CMPXCHG on x86;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6165356040000916
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.6512171626091003
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;SIGBUS is triggered;the flag is set;Contradicts;0.5650776028633118
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Pinning mms mm_count for longer time;not really harmful because this will not pin much memory;Contradicts;0.5894928574562073
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.5771805644035339
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.5147033929824829
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5135403871536255
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Introduce is_init;to capture this case;Contradicts;0.6416929364204407
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;Contradicts;0.6860982179641724
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Introduce is_sysrq_oom helper function;to improve readability;Contradicts;0.5227413773536682
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9420555233955383
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6910541653633118
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;adds vsz and rss information to the oom log;to help this analysis;Contradicts;0.5008863806724548
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;Contradicts;0.5355128645896912
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9374249577522278
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.6215412616729736
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;mm locking fix;oom-kill;Contradicts;0.5566478371620178
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;check all threads which could share the same ->mm;to make it more or less correct;Contradicts;0.7944661974906921
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;Contradicts;0.6317790150642395
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5180343985557556
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Stick to accounting for half;Significant improvement;Contradicts;0.7341346144676208
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;I added some more output;Users tend to be irritated by the choice of killed processes;Contradicts;0.8288033604621887
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Add the necessary rcu_read_lock();necessary;Contradicts;0.7292900681495667
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;integrate them and add some comment to struct alloc_context;reduce future confusion about the meaning of this variable;Contradicts;0.549071729183197
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Introduce two new options for madvise;To achieve the goal;Contradicts;0.5263384580612183
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;initialize it before;should;Contradicts;0.5043659210205078
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.7376571297645569
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.9654608964920044
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Add comments describing oom_locks scope;describing oom_locks scope;Contradicts;0.6578661203384399
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5131326913833618
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.8462247252464294
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.8245282173156738
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;Contradicts;0.6374555826187134
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Add a new flag PF_POSTCOREDUMP;so that tasks that have passed through coredump_task_exit can be recognized and ignored in zap_process;Contradicts;0.5116433501243591
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Kill it and directly access;directly access;Contradicts;0.6722832322120667
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7648303508758545
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;adds MM_SHMEMPAGES counter to mm_rss_stat;to account for shmem pages separately from MM_FILEPAGES;Contradicts;0.5710217356681824
Remove the count;Its better to remove the count;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.673507571220398
Remove the count;Its better to remove the count;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.5221343636512756
Remove the count;Its better to remove the count;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6429547071456909
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.7359648942947388
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.6722369194030762
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.7199608683586121
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;Contradicts;0.5351384282112122
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;we must not skip this process;because its sub-thread originated the coredump;Contradicts;0.8444843888282776
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.807958722114563
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7126749157905579
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6589897274971008
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9761455059051514
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5957333445549011
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.7429420351982117
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.5665035843849182
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Contradicts;0.6739919781684875
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7591970562934875
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;Contradicts;0.6191065907478333
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;Fix it up via task_lock();instead;Contradicts;0.6177533864974976
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;Stick to accounting for half;Significant improvement;Contradicts;0.6450079083442688
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5073907375335693
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.5606124401092529
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7283199429512024
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;initialize it before;should;Contradicts;0.7351700663566589
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;Have no license information of any form;GPL v2 only;Contradicts;0.6423326730728149
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.657584011554718
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.8995609283447266
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5652588605880737
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5847598910331726
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5942689776420593
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6337133049964905
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;Kill it and directly access;directly access;Contradicts;0.6407548189163208
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5008595585823059
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.841651976108551
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5591874718666077
Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.6475639343261719
Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.7804563045501709
Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.745728075504303
Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7793964147567749
Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Contradicts;0.6163466572761536
Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9305233955383301
Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5425858497619629
Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.5688924193382263
Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6564549207687378
Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5867959856987
Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5341497659683228
Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;Have no license information of any form;GPL v2 only;Contradicts;0.6958598494529724
Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6545002460479736
Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8110011219978333
The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5605404376983643
The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6802580952644348
The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7629819512367249
The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5690624117851257
The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5571187734603882
The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.7798328399658203
The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;cap_safe_nice() only ever saw current, so now uses capable();only ever saw current, capable();Contradicts;0.6143812537193298
The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.532307505607605
The range can be represented by the signed short type;This range can be represented by the signed short type with no functional change;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5065189599990845
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;allocate, detach its mm, and free the memory it represents;quickly;Contradicts;0.9028419852256775
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.8547713160514832
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;Contradicts;0.7740809917449951
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;Contradicts;0.6828441023826599
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.7621335983276367
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.5130075216293335
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Contradicts;0.5159782767295837
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.6273773908615112
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Contradicts;0.6013228893280029
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;Contradicts;0.5892424583435059
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.5332570672035217
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.7051929235458374
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.6490573287010193
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.9063417315483093
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.5238660573959351
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6872941255569458
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5191815495491028
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.8563849925994873
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9884184002876282
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.8336107730865479
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.8572350144386292
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.824122428894043
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;uid==0 makes processes only on the host more important;even without any capabilities;Contradicts;0.5821717977523804
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;start isolating the tons of warnings;cannot be sent right now as this leads to tons of warnings;Contradicts;0.5191280245780945
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.6534616947174072
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;Contradicts;0.5988835692405701
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.5693575739860535
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;remove task_t, convert to struct task_struct;cleanup, remove;Contradicts;0.5463831424713135
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.6421647667884827
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.629002571105957
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Contradicts;0.687940239906311
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7194991707801819
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;Contradicts;0.56734299659729
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;out_of_memory() locking fix;locking fix;Contradicts;0.5048478841781616
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5378534197807312
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.6625470519065857
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Stick to accounting for half;Significant improvement;Contradicts;0.9203295707702637
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5590218901634216
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;Contradicts;0.5007657408714294
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.6426060795783997
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8028705716133118
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Have no license information of any form;GPL v2 only;Contradicts;0.6934463977813721
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.8905782699584961
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.9206064343452454
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.8397101759910583
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6712058782577515
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5414403676986694
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5220597386360168
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.5379617810249329
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6280688047409058
allocate, detach its mm, and free the memory it represents;quickly;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.6433935165405273
allocate, detach its mm, and free the memory it represents;quickly;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6224119067192078
allocate, detach its mm, and free the memory it represents;quickly;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5469393134117126
allocate, detach its mm, and free the memory it represents;quickly;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.746782124042511
allocate, detach its mm, and free the memory it represents;quickly;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.945212185382843
allocate, detach its mm, and free the memory it represents;quickly;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6663524508476257
allocate, detach its mm, and free the memory it represents;quickly;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5723806619644165
allocate, detach its mm, and free the memory it represents;quickly;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6179019808769226
allocate, detach its mm, and free the memory it represents;quickly;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7600352168083191
allocate, detach its mm, and free the memory it represents;quickly;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.639944851398468
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.6589285731315613
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.6678674817085266
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.657692551612854
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Contradicts;0.6701487302780151
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.6966357231140137
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.9276539087295532
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8154862523078918
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7849195599555969
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7575545907020569
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;select_bad_process() must select killable task;killable task;Contradicts;0.5043202042579651
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9846663475036621
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5856366157531738
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5518184304237366
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.7781278491020203
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6114633083343506
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.890486478805542
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;Contradicts;0.5526255369186401
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.8557661175727844
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Stick to accounting for half;Significant improvement;Contradicts;0.8796415328979492
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8740755319595337
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Have no license information of any form;GPL v2 only;Contradicts;0.6871041655540466
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.7093583345413208
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5504494309425354
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.502869725227356
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7251726984977722
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;The oom killer does not want to defer in this case;there is no guarantee that thread will ever exit without intervention;Contradicts;0.5468683838844299
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;skip zombies when iterating tasklist;oom;Contradicts;0.5309227705001831
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7587316632270813
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5357070565223694
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.6041600704193115
remove deprecated oom_adj;deprecated;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5404608249664307
remove deprecated oom_adj;deprecated;Introduce is_init;to capture this case;Contradicts;0.6323593258857727
remove deprecated oom_adj;deprecated;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5058544278144836
remove deprecated oom_adj;deprecated;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8022767901420593
remove deprecated oom_adj;deprecated;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9342368245124817
remove deprecated oom_adj;deprecated;initialize it before;should;Contradicts;0.5195151567459106
remove deprecated oom_adj;deprecated;Have no license information of any form;GPL v2 only;Contradicts;0.5378304123878479
remove deprecated oom_adj;deprecated;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.8112828731536865
remove deprecated oom_adj;deprecated;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5134426355361938
remove deprecated oom_adj;deprecated;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.6182441115379333
reduce dependency on tasklist_lock;reduce dependency;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5965211391448975
reduce dependency on tasklist_lock;reduce dependency;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7483513951301575
reduce dependency on tasklist_lock;reduce dependency;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5121177434921265
reduce dependency on tasklist_lock;reduce dependency;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5535719394683838
reduce dependency on tasklist_lock;reduce dependency;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5521053075790405
reduce dependency on tasklist_lock;reduce dependency;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5125042200088501
try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.8327532410621643
try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.7127930521965027
try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.925212025642395
try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.8374157547950745
try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9486982226371765
try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.6461914777755737
try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.7079917192459106
try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7504686117172241
try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.6342298984527588
try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.715141236782074
try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6177896857261658
try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5476171970367432
try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.889046311378479
try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6660336256027222
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.5112464427947998
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5577727556228638
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.883795976638794
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7812334299087524
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5564530491828918
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Contradicts;0.5756410956382751
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9570054411888123
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.6266735196113586
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7522563934326172
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5185856223106384
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.5692733526229858
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;Have no license information of any form;GPL v2 only;Contradicts;0.6379775404930115
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6248630285263062
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5991418361663818
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;Remove the parameter @mem;removed since v2.6.26;Contradicts;0.5542876720428467
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7622607350349426
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5058979392051697
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;Use a single linked list;Save a word in task_struct;Contradicts;0.9543251991271973
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5728386044502258
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5227494239807129
significantly reduces the amount of time that it is held;isnt a complete solution to tasklist_lock starvation;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5561307072639465
significantly reduces the amount of time that it is held;isnt a complete solution to tasklist_lock starvation;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7216969132423401
significantly reduces the amount of time that it is held;isnt a complete solution to tasklist_lock starvation;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6773187518119812
significantly reduces the amount of time that it is held;isnt a complete solution to tasklist_lock starvation;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6587674617767334
significantly reduces the amount of time that it is held;isnt a complete solution to tasklist_lock starvation;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5956505537033081
introduce helper function to process threads during scan;to process threads during scan;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.5829880237579346
introduce helper function to process threads during scan;to process threads during scan;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5990315675735474
introduce helper function to process threads during scan;to process threads during scan;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5928353071212769
introduce helper function to process threads during scan;to process threads during scan;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Contradicts;0.6539856791496277
introduce helper function to process threads during scan;to process threads during scan;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7297499775886536
introduce helper function to process threads during scan;to process threads during scan;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6789302229881287
introduce helper function to process threads during scan;to process threads during scan;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.883162796497345
introduce helper function to process threads during scan;to process threads during scan;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5630680322647095
introduce helper function to process threads during scan;to process threads during scan;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6987146139144897
introduce helper function to process threads during scan;to process threads during scan;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5221483707427979
introduce helper function to process threads during scan;to process threads during scan;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.5193346738815308
introduce helper function to process threads during scan;to process threads during scan;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.5026684999465942
introduce helper function to process threads during scan;to process threads during scan;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5340607166290283
introduce helper function to process threads during scan;to process threads during scan;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.81728196144104
introduce helper function to process threads during scan;to process threads during scan;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7076830863952637
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.6623638868331909
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;Introduce is_init;to capture this case;Contradicts;0.5176486372947693
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Contradicts;0.6108044385910034
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.674645185470581
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5599671602249146
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.6404148936271667
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;Contradicts;0.5749304890632629
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.523560106754303
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7297549843788147
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7818049788475037
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;remove task_t, convert to struct task_struct;cleanup, remove;Contradicts;0.5671513676643372
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5972226858139038
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6771897673606873
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;Contradicts;0.5196588039398193
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.721515417098999
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.6579865217208862
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;Contradicts;0.5803120732307434
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;Add comments describing oom_locks scope;describing oom_locks scope;Contradicts;0.5564751029014587
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5194202661514282
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6340555548667908
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;fix vm_oom_kill_table[];ifdeffery;Contradicts;0.615742564201355
A new return type, enum oom_scan_t, is defined;to determine the future behavior of the iteration;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5485680103302002
fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9029240012168884
fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5119901895523071
fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6392091512680054
fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9091047048568726
fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.8050211668014526
fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5670648217201233
fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.5430726408958435
fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.5068533420562744
fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6314796805381775
fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5835790634155273
fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.5104355812072754
fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5905224680900574
fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;Kill it and directly access;directly access;Contradicts;0.5453916788101196
fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8442102074623108
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.8725528717041016
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;SIGBUS is triggered;the flag is set;Contradicts;0.6497757434844971
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.51008540391922
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.5211490392684937
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Contradicts;0.6025795340538025
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.7385971546173096
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Contradicts;0.5452070236206055
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Contradicts;0.8827782273292542
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.720000147819519
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.8811860084533691
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.7292632460594177
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.5760782957077026
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.6347959041595459
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.84554523229599
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5782028436660767
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.7526987195014954
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7099647521972656
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5983229875564575
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Contradicts;0.5768146514892578
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;Contradicts;0.6979023814201355
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;select_bad_process() must select killable task;killable task;Contradicts;0.8117136359214783
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9825337529182434
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5175560116767883
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.7254975438117981
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.8060263395309448
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Update the comments for __oom_kill_task();to reflect the code changes;Contradicts;0.6107958555221558
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.648761510848999
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.6604548692703247
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7204058766365051
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.9112305641174316
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Stick to accounting for half;Significant improvement;Contradicts;0.7955990433692932
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.6722843647003174
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;Contradicts;0.7382568717002869
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.8745473027229309
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.6518640518188477
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.5436840653419495
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6907961964607239
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.5992713570594788
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Have no license information of any form;GPL v2 only;Contradicts;0.5055721402168274
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5141240954399109
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.911827802658081
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.6166782379150391
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7101078033447266
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.6325741410255432
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.8501766324043274
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;fix vm_oom_kill_table[];ifdeffery;Contradicts;0.5432696342468262
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5139952898025513
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.6931688785552979
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6059575080871582
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Kill it and directly access;directly access;Contradicts;0.990230143070221
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5003606081008911
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7750480771064758
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;Contradicts;0.5116372108459473
Fix kernel-doc warnings such as;No description found for parameter id, Excess function parameter mem description in swap_cgroup_record;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5819856524467468
Fix kernel-doc warnings such as;No description found for parameter id, Excess function parameter mem description in swap_cgroup_record;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.684350311756134
Fix kernel-doc warnings such as;No description found for parameter id, Excess function parameter mem description in swap_cgroup_record;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5161824226379395
Fix this by always printing the nodemask;always printing the nodemask;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.6969436407089233
Fix this by always printing the nodemask;always printing the nodemask;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8962021470069885
Fix this by always printing the nodemask;always printing the nodemask;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8084036111831665
Fix this by always printing the nodemask;always printing the nodemask;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5961222648620605
Fix this by always printing the nodemask;always printing the nodemask;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.5122395753860474
Fix this by always printing the nodemask;always printing the nodemask;Have no license information of any form;GPL v2 only;Contradicts;0.9318891763687134
Fix this by always printing the nodemask;always printing the nodemask;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5129960179328918
Fix this by always printing the nodemask;always printing the nodemask;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.647034764289856
Fix this by always printing the nodemask;always printing the nodemask;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8792531490325928
Fix this by always printing the nodemask;always printing the nodemask;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5597519278526306
The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.550758421421051
The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5207027196884155
The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6845607161521912
The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.7213392853736877
The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.572543740272522
The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.6114174127578735
The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;Have no license information of any form;GPL v2 only;Contradicts;0.5855844616889954
The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.7989359498023987
The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;remove the prototype for the old function;the prototype still existed;Contradicts;0.5965059399604797
The mask is printed even for NUMA configurations ;To prevent ugly ifdefs;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5319675207138062
not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;SIGBUS is triggered;the flag is set;Contradicts;0.7131438255310059
not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Introduce is_init;to capture this case;Contradicts;0.5403655171394348
not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7490621209144592
not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.6919412612915039
not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5163939595222473
not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7482239007949829
not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6462866067886353
not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.6026049256324768
not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Kill it and directly access;directly access;Contradicts;0.6542326807975769
allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.7771390080451965
allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5315160155296326
allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5913876891136169
allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.868908703327179
allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.8707452416419983
allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6938889026641846
allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7401148080825806
allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;Have no license information of any form;GPL v2 only;Contradicts;0.6802745461463928
allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.9798327684402466
allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6275982856750488
allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5003210306167603
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Contradicts;0.5427297949790955
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.7568318843841553
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9199142456054688
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5032116174697876
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5191042423248291
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6099708080291748
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9050251841545105
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7120146751403809
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7641122341156006
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.6057829260826111
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;cleanup pagefault oom handler;mm, oom;Contradicts;0.5253046751022339
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7215266227722168
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6869783997535706
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.6371322274208069
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6873222589492798
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;Kill it and directly access;directly access;Contradicts;0.6594952344894409
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.5020172595977783
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;Contradicts;0.6288405656814575
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;Contradicts;0.5096378326416016
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Contradicts;0.5839381814002991
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5691318511962891
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.7725408673286438
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8945816159248352
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.772262454032898
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6055078506469727
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8382400274276733
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5211742520332336
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;Contradicts;0.6642857193946838
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.8689100742340088
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7993800640106201
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8160585761070251
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.56059330701828
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5539446473121643
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8430249094963074
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.8384998440742493
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6413793563842773
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5014554262161255
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.7582312226295471
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7276320457458496
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.5450359582901001
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5850288271903992
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6328520774841309
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8234907388687134
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;"This is identical to the global oom killer and is done even before checking for panic_on_oom: a pending SIGKILL here while panic_on_oom is selected is guaranteed to have come from userspace; the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory.";the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory;Contradicts;0.7505187392234802
Make sure that no kthread context (users of use_mm) can ever see corrupted data because of the oom reaper and hook into the page fault path;checking MMF_UNSTABLE mm flag;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5227041840553284
SIGBUS is triggered;the flag is set;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8081703782081604
SIGBUS is triggered;the flag is set;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5068825483322144
SIGBUS is triggered;the flag is set;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5512441992759705
SIGBUS is triggered;the flag is set;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7068694233894348
SIGBUS is triggered;the flag is set;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.549795389175415
SIGBUS is triggered;the flag is set;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7693604230880737
Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5180768370628357
Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.7185654640197754
Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9337302446365356
Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7679484486579895
Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.8834249973297119
Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6323966979980469
Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5046625733375549
Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;initialize it before;should;Contradicts;0.5203786492347717
Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.5506134629249573
Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5215505361557007
Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5337939858436584
Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.610850989818573
Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5934737324714661
Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5506815910339355
Lets get rid of the signal_struct counter;We do not need it anymore;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;Contradicts;0.9882718920707703
Lets get rid of the signal_struct counter;We do not need it anymore;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.502769410610199
Lets get rid of the signal_struct counter;We do not need it anymore;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5793668627738953
Lets get rid of the signal_struct counter;We do not need it anymore;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9197731614112854
Lets get rid of the signal_struct counter;We do not need it anymore;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6296526789665222
Lets get rid of the signal_struct counter;We do not need it anymore;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5535616874694824
Lets get rid of the signal_struct counter;We do not need it anymore;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.752579927444458
Lets get rid of the signal_struct counter;We do not need it anymore;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6198192238807678
Lets get rid of the signal_struct counter;We do not need it anymore;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.594601035118103
Lets get rid of the signal_struct counter;We do not need it anymore;Stick to accounting for half;Significant improvement;Contradicts;0.6699615716934204
Lets get rid of the signal_struct counter;We do not need it anymore;Have no license information of any form;GPL v2 only;Contradicts;0.5585491061210632
Lets get rid of the signal_struct counter;We do not need it anymore;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6568687558174133
Lets get rid of the signal_struct counter;We do not need it anymore;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6035532355308533
Lets get rid of the signal_struct counter;We do not need it anymore;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.9594812393188477
Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.6327882409095764
Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.9370751976966858
Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6788188219070435
Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5872774124145508
Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9803080558776855
Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7571718692779541
Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;initialize it before;should;Contradicts;0.5186936855316162
Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;Have no license information of any form;GPL v2 only;Contradicts;0.5947104692459106
Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5063329339027405
Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;renaming;doesnt bring any functional change;Contradicts;0.5362880229949951
Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.645839512348175
Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5198085308074951
Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5657662749290466
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Contradicts;0.6695975065231323
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.6265228390693665
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Introduce is_init;to capture this case;Contradicts;0.5646466016769409
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Contradicts;0.6041920185089111
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5758843421936035
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.9292899966239929
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;Contradicts;0.6146278381347656
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5118983387947083
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5439144968986511
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5435103178024292
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7282438278198242
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.935390055179596
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.7405874133110046
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.674822986125946
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.7025013566017151
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5257610082626343
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Update the comments for __oom_kill_task();to reflect the code changes;Contradicts;0.7084851861000061
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;remove task_t, convert to struct task_struct;cleanup, remove;Contradicts;0.6555936336517334
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.5588003396987915
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.5127232670783997
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Contradicts;0.7069990634918213
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.867387056350708
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.6639221906661987
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Stick to accounting for half;Significant improvement;Contradicts;0.5355348587036133
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;Contradicts;0.5469403862953186
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;Contradicts;0.5059986114501953
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.628734290599823
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;convert it to atomic_long_t;to avoid races;Contradicts;0.6313672065734863
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8938072323799133
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Have no license information of any form;GPL v2 only;Contradicts;0.7390981912612915
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.6743661165237427
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.9157922267913818
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.9854045510292053
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5232042074203491
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;fix vm_oom_kill_table[];ifdeffery;Contradicts;0.5839646458625793
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.6416255831718445
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5050685405731201
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Kill it and directly access;directly access;Contradicts;0.655464231967926
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.6453804969787598
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5261169672012329
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5459252595901489
Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.5085391998291016
Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6204642057418823
Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.8811838030815125
Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9272308945655823
Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7128757834434509
Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5872127413749695
Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;Stick to accounting for half;Significant improvement;Contradicts;0.543910026550293
Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5603393316268921
Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5333170890808105
Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5252545475959778
Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;Reduce the ballast;Doesnt provide any relevant information;Contradicts;0.5559138655662537
Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5554446578025818
Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5458763241767883
Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7743604183197021
do not attempt to reap a task twice;do not attempt to reap a task twice;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.584123969078064
do not attempt to reap a task twice;do not attempt to reap a task twice;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7607498168945312
do not attempt to reap a task twice;do not attempt to reap a task twice;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.8398168683052063
do not attempt to reap a task twice;do not attempt to reap a task twice;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7098506689071655
do not attempt to reap a task twice;do not attempt to reap a task twice;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5071256160736084
do not attempt to reap a task twice;do not attempt to reap a task twice;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6005922555923462
reduce find_lock_task_mm() usage;mm, oom_reaper;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7662755250930786
reduce find_lock_task_mm() usage;mm, oom_reaper;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.645807147026062
reduce find_lock_task_mm() usage;mm, oom_reaper;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5113298892974854
reduce find_lock_task_mm() usage;mm, oom_reaper;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8008835911750793
reduce find_lock_task_mm() usage;mm, oom_reaper;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5244621634483337
reduce find_lock_task_mm() usage;mm, oom_reaper;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5026322603225708
reduce find_lock_task_mm() usage;mm, oom_reaper;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6273326873779297
reduce find_lock_task_mm() usage;mm, oom_reaper;Add the necessary rcu_read_lock();necessary;Contradicts;0.5512950420379639
reduce find_lock_task_mm() usage;mm, oom_reaper;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5039183497428894
reduce find_lock_task_mm() usage;mm, oom_reaper;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6153948307037354
reduce find_lock_task_mm() usage;mm, oom_reaper;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5001811981201172
reduce find_lock_task_mm() usage;mm, oom_reaper;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5997586250305176
reduce find_lock_task_mm() usage;mm, oom_reaper;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.6148013472557068
reduce find_lock_task_mm() usage;mm, oom_reaper;Kill it and directly access;directly access;Contradicts;0.7711054086685181
__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5052996873855591
__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.6606261134147644
__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5157099962234497
__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9511963129043579
__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5044780373573303
__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;Contradicts;0.5376254916191101
__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Contradicts;0.508769154548645
__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6604300737380981
__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;Have no license information of any form;GPL v2 only;Contradicts;0.5567421913146973
__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5328401327133179
__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.9262938499450684
__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7508293390274048
__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.5039756298065186
__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5432441830635071
Pinning mms mm_count for longer time;not really harmful because this will not pin much memory;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.585616946220398
Pinning mms mm_count for longer time;not really harmful because this will not pin much memory;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7324498295783997
Pinning mms mm_count for longer time;not really harmful because this will not pin much memory;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.5539106130599976
Pinning mms mm_count for longer time;not really harmful because this will not pin much memory;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5389209389686584
Pinning mms mm_count for longer time;not really harmful because this will not pin much memory;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6689977645874023
Pinning mms mm_count for longer time;not really harmful because this will not pin much memory;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7244194149971008
Pinning mms mm_count for longer time;not really harmful because this will not pin much memory;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5756723880767822
contstrained_alloc() should get memory_less_node into count;memory_less_node into count;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.8574230670928955
contstrained_alloc() should get memory_less_node into count;memory_less_node into count;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5226054191589355
contstrained_alloc() should get memory_less_node into count;memory_less_node into count;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.865246057510376
contstrained_alloc() should get memory_less_node into count;memory_less_node into count;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.8609543442726135
contstrained_alloc() should get memory_less_node into count;memory_less_node into count;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6007897853851318
contstrained_alloc() should get memory_less_node into count;memory_less_node into count;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6851568222045898
contstrained_alloc() should get memory_less_node into count;memory_less_node into count;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5585188865661621
contstrained_alloc() should get memory_less_node into count;memory_less_node into count;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7472317218780518
contstrained_alloc() should get memory_less_node into count;memory_less_node into count;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5758309960365295
contstrained_alloc() should get memory_less_node into count;memory_less_node into count;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5482997894287109
contstrained_alloc() should get memory_less_node into count;memory_less_node into count;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5081230401992798
fix it;fix;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7988623380661011
fix it;fix;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6422252655029297
fix it;fix;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5355122685432434
fix it;fix;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5620843172073364
Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.9919571876525879
Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5284912586212158
Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5139471888542175
Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5951128005981445
Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8002191781997681
Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.8815904259681702
Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6496953964233398
Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6319749355316162
Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5790877938270569
Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.6913632154464722
Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6441054940223694
Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.6352129578590393
Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.8595566749572754
Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.540523111820221
This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.879103422164917
This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6622500419616699
This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.918355405330658
This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5407441258430481
This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.5633687376976013
This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.5863485336303711
This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5599266886711121
This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6516577005386353
This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.7818620204925537
This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6012685894966125
This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Kill it and directly access;directly access;Contradicts;0.7070865035057068
This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8222130537033081
This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.5436522960662842
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.5429074764251709
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7664762139320374
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7545856833457947
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9566550850868225
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5467479825019836
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.7681849598884583
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.801139235496521
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5820996165275574
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;Have no license information of any form;GPL v2 only;Contradicts;0.5666971206665039
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6135310530662537
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6193994283676147
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5934773087501526
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5642111897468567
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6699581742286682
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5936477780342102
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;This fix has considerable negative impact on process_mrelease performance;will likely need later optimization;Contradicts;0.6922182440757751
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6481974720954895
reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.503558337688446
reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8285534381866455
reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6364544630050659
reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5769562721252441
reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9665529727935791
reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.6796018481254578
reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7635550498962402
reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.7297554016113281
reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5554019808769226
reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5107031464576721
reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5011143088340759
reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6719883680343628
reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;Kill it and directly access;directly access;Contradicts;0.5748873353004456
Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5596240758895874
Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5458516478538513
Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7896595597267151
Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.900128960609436
Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.6407207250595093
Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.6551230549812317
Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7544496059417725
Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5659502148628235
Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Have no license information of any form;GPL v2 only;Contradicts;0.5773752927780151
Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5877372622489929
Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.8655503988265991
Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.7517569065093994
Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.8471556305885315
Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;Kill it and directly access;directly access;Contradicts;0.5894993543624878
cleanup messages;oom;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5478296875953674
cleanup messages;oom;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9621453881263733
cleanup messages;oom;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5850788354873657
Clean up the OOM killer messages;to be more consistent;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.8109414577484131
Clean up the OOM killer messages;to be more consistent;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8049418926239014
Clean up the OOM killer messages;to be more consistent;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.548965334892273
Clean up the OOM killer messages;to be more consistent;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.919236421585083
Clean up the OOM killer messages;to be more consistent;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.6516540050506592
Clean up the OOM killer messages;to be more consistent;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6490508913993835
Clean up the OOM killer messages;to be more consistent;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.6347160935401917
Clean up the OOM killer messages;to be more consistent;Have no license information of any form;GPL v2 only;Contradicts;0.553360104560852
Clean up the OOM killer messages;to be more consistent;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5745877027511597
Clean up the OOM killer messages;to be more consistent;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.537818968296051
Having this test here;"prevents any OOM_DISABLE child of the ""selected"" process from being killed.";CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.712424099445343
Having this test here;"prevents any OOM_DISABLE child of the ""selected"" process from being killed.";The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6818066239356995
Having this test here;"prevents any OOM_DISABLE child of the ""selected"" process from being killed.";Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.6292150616645813
Having this test here;"prevents any OOM_DISABLE child of the ""selected"" process from being killed.";It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5174421668052673
Having this test here;"prevents any OOM_DISABLE child of the ""selected"" process from being killed.";Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.548581600189209
Having this test here;"prevents any OOM_DISABLE child of the ""selected"" process from being killed.";push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.533811092376709
Having this test here;"prevents any OOM_DISABLE child of the ""selected"" process from being killed.";We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6653997898101807
No logic changes, but imho easier to read.;easier to read;kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Contradicts;0.5407907366752625
No logic changes, but imho easier to read.;easier to read;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.8050049543380737
No logic changes, but imho easier to read.;easier to read;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5846187472343445
No logic changes, but imho easier to read.;easier to read;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5795760154724121
No logic changes, but imho easier to read.;easier to read;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5802738666534424
No logic changes, but imho easier to read.;easier to read;modify implementation of per-mm counter;reducing patch size in future patch;Contradicts;0.6284811496734619
No logic changes, but imho easier to read.;easier to read;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.5257431268692017
No logic changes, but imho easier to read.;easier to read;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.5512372255325317
No logic changes, but imho easier to read.;easier to read;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5550640225410461
No logic changes, but imho easier to read.;easier to read;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5218209028244019
No logic changes, but imho easier to read.;easier to read;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.7905956506729126
No logic changes, but imho easier to read.;easier to read;This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;Contradicts;0.8428087830543518
No logic changes, but imho easier to read.;easier to read;Have no license information of any form;GPL v2 only;Contradicts;0.6143154501914978
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.5299261212348938
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Introduce is_init;to capture this case;Contradicts;0.5990453958511353
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.537182629108429
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.6197957992553711
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.6093174815177917
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;Contradicts;0.569444477558136
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.955142080783844
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5302442908287048
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;Contradicts;0.5041422247886658
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8061781525611877
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.7530766129493713
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.5499008893966675
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8196380138397217
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.6915113925933838
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.5020421147346497
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5063008666038513
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6852680444717407
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.7459281086921692
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5826604962348938
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5086144208908081
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.8911424279212952
Introduce a new state, TASK_DEAD;to avoid a confusion;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.8817698359489441
Introduce a new state, TASK_DEAD;to avoid a confusion;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6854056715965271
Introduce a new state, TASK_DEAD;to avoid a confusion;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7298202514648438
Introduce a new state, TASK_DEAD;to avoid a confusion;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.5615840554237366
Introduce a new state, TASK_DEAD;to avoid a confusion;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5503127574920654
Introduce a new state, TASK_DEAD;to avoid a confusion;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.5051999688148499
Introduce a new state, TASK_DEAD;to avoid a confusion;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5897783041000366
Introduce a new state, TASK_DEAD;to avoid a confusion;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7867224812507629
Introduce a new state, TASK_DEAD;to avoid a confusion;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5069937109947205
Introduce a new state, TASK_DEAD;to avoid a confusion;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5129187703132629
Introduce a new state, TASK_DEAD;to avoid a confusion;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.5013778209686279
Introduce a new state, TASK_DEAD;to avoid a confusion;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.505479097366333
Introduce a new state, TASK_DEAD;to avoid a confusion;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6123571395874023
removes dependency on Erics other patches for now;checks pid and thus;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5207271575927734
removes dependency on Erics other patches for now;checks pid and thus;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5918041467666626
removes dependency on Erics other patches for now;checks pid and thus;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6769363880157471
removes dependency on Erics other patches for now;checks pid and thus;Have no license information of any form;GPL v2 only;Contradicts;0.5099189877510071
removes dependency on Erics other patches for now;checks pid and thus;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.5694491863250732
removes dependency on Erics other patches for now;checks pid and thus;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5151785612106323
removes dependency on Erics other patches for now;checks pid and thus;Kill it and directly access;directly access;Contradicts;0.8187747597694397
removes dependency on Erics other patches for now;checks pid and thus;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6152856945991516
removes dependency on Erics other patches for now;checks pid and thus;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5742127299308777
Introduce is_init;to capture this case;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.6960594654083252
Introduce is_init;to capture this case;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.8134655952453613
Introduce is_init;to capture this case;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5793164968490601
Introduce is_init;to capture this case;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5042360424995422
Introduce is_init;to capture this case;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Contradicts;0.715067982673645
Introduce is_init;to capture this case;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.729865550994873
Introduce is_init;to capture this case;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6169585585594177
Introduce is_init;to capture this case;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.6525390148162842
Introduce is_init;to capture this case;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6003980040550232
Introduce is_init;to capture this case;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.5553635954856873
Introduce is_init;to capture this case;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5956947207450867
Introduce is_init;to capture this case;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5126960277557373
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.5171726942062378
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5953196287155151
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.57365882396698
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6038276553153992
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.8149325847625732
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.8034846782684326
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6972779631614685
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.8307834267616272
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9585501551628113
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.7673035860061646
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.6563404202461243
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5968449711799622
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.5856949687004089
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7924522757530212
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Stick to accounting for half;Significant improvement;Contradicts;0.7834409475326538
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5125625729560852
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.868461012840271
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;initialize it before;should;Contradicts;0.5084360241889954
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Have no license information of any form;GPL v2 only;Contradicts;0.6174597144126892
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.7188242673873901
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5534290671348572
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.5094708800315857
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.6310452222824097
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;make OOM detection in the freezer path raceless;raceless;Contradicts;0.5480337142944336
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.625522255897522
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.7374072074890137
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5861943960189819
suppress extraneous stack and memory dump;oom;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8287001252174377
suppress extraneous stack and memory dump;oom;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5132563710212708
suppress extraneous stack and memory dump;oom;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8892505168914795
suppress extraneous stack and memory dump;oom;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;Contradicts;0.7221400141716003
suppress extraneous stack and memory dump;oom;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5093091726303101
suppress extraneous stack and memory dump;oom;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5647788047790527
suppress extraneous stack and memory dump;oom;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.5534514784812927
suppress extraneous stack and memory dump;oom;Kill it and directly access;directly access;Contradicts;0.6903682351112366
Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;panic ASAP;want failover;Contradicts;0.690300703048706
Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;we must not skip this process;because its sub-thread originated the coredump;Contradicts;0.7522196769714355
Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6977270841598511
Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.5401802062988281
Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5672035217285156
Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;Contradicts;0.7388560175895691
Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.5243582129478455
Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5453153848648071
Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Kill it and directly access;directly access;Contradicts;0.5489791035652161
Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6751129627227783
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.5440676212310791
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.6696494817733765
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7458621859550476
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9679521322250366
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5011283755302429
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;Contradicts;0.6343704462051392
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.5488482117652893
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.7092506885528564
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;panic is preferable rather than kill some processes;there are environments where panic is preferable;Contradicts;0.7129846811294556
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6333171129226685
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.758013904094696
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Have no license information of any form;GPL v2 only;Contradicts;0.5981682538986206
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5431057810783386
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6684659123420715
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;Contradicts;0.5835347175598145
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7489448189735413
OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.5117890238761902
OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9073941111564636
OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7393638491630554
OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5735278129577637
OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.5319957733154297
OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.714189887046814
OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5381245017051697
OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5075581073760986
OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.6430069804191589
OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;Kill it and directly access;directly access;Contradicts;0.5092028379440308
OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5132478475570679
DMA allocations can be targeted at the zone level;locking was done in nodes or globally;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.709435760974884
DMA allocations can be targeted at the zone level;locking was done in nodes or globally;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7230018973350525
DMA allocations can be targeted at the zone level;locking was done in nodes or globally;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5640192627906799
DMA allocations can be targeted at the zone level;locking was done in nodes or globally;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.7960281372070312
DMA allocations can be targeted at the zone level;locking was done in nodes or globally;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5877211093902588
DMA allocations can be targeted at the zone level;locking was done in nodes or globally;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6212034225463867
DMA allocations can be targeted at the zone level;locking was done in nodes or globally;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5080480575561523
DMA allocations can be targeted at the zone level;locking was done in nodes or globally;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7402044534683228
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.6255751252174377
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.9272918105125427
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.6939378380775452
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.8995264768600464
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.915763795375824
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8110390901565552
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.9428384304046631
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.75552898645401
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8253986239433289
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.9407508969306946
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.5868710875511169
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5079379081726074
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7025083899497986
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.5355972647666931
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7355982065200806
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;Fix it up via task_lock();instead;Contradicts;0.6495684385299683
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.695792555809021
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.8768029808998108
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5110787749290466
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.932293713092804
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.8505862951278687
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;Have no license information of any form;GPL v2 only;Contradicts;0.6428095698356628
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.5762602686882019
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6056510806083679
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5906575322151184
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.5315343141555786
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.641173779964447
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;Remove the parameter @mem;removed since v2.6.26;Contradicts;0.5277880430221558
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.9099040031433105
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6811374425888062
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;Kill it and directly access;directly access;Contradicts;0.9573900699615479
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7584184408187866
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5396554470062256
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.5762951374053955
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.6776481866836548
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;Contradicts;0.6990836262702942
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.5527132749557495
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5589532852172852
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5118221044540405
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5041114091873169
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8943716883659363
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;panic is preferable rather than kill some processes;there are environments where panic is preferable;Contradicts;0.7138369679450989
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.8745405673980713
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5849298238754272
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.8169260621070862
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;Have no license information of any form;GPL v2 only;Contradicts;0.805126428604126
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6008036732673645
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6100593209266663
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;Reduce the ballast;Doesnt provide any relevant information;Contradicts;0.5085322260856628
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6351813077926636
Define the OOM killers CONSTRAINT definitions in include/linux/oom.h  ;The OOM killers CONSTRAINT definitions are more appropriate in an enum;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7266503572463989
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7815544605255127
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.6198974847793579
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6942803859710693
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6550292372703552
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;Contradicts;0.5067497491836548
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9769178628921509
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.6058198809623718
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6154743432998657
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.6892068386077881
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.53651362657547
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6615133285522461
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5629997849464417
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.6003602743148804
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8222929835319519
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;Have no license information of any form;GPL v2 only;Contradicts;0.6087092161178589
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7001075148582458
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8898430466651917
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5697179436683655
fix constraint deadlock;constraint deadlock;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9190106391906738
fix constraint deadlock;constraint deadlock;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6602224707603455
fix constraint deadlock;constraint deadlock;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5696110129356384
fix constraint deadlock;constraint deadlock;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5527823567390442
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.8869337439537048
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.8078925013542175
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8679370284080505
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5832708477973938
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7259930968284607
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.965901792049408
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.6320182085037231
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.5849888324737549
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7278238534927368
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.800744891166687
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Contradicts;0.7214032411575317
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8567996025085449
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.542170524597168
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.571533739566803
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;Have no license information of any form;GPL v2 only;Contradicts;0.7179189324378967
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5409863591194153
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6072019338607788
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6164137125015259
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.7552908062934875
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.584888219833374
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;Reduce the ballast;Doesnt provide any relevant information;Contradicts;0.5591618418693542
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5714137554168701
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5900374054908752
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.608733594417572
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5474749803543091
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.624703049659729
We now take callback_mutex after iterating through the zonelist;we dont need it yet;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.8927540183067322
We now take callback_mutex after iterating through the zonelist;we dont need it yet;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.7382414937019348
We now take callback_mutex after iterating through the zonelist;we dont need it yet;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9001967906951904
We now take callback_mutex after iterating through the zonelist;we dont need it yet;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.502805233001709
We now take callback_mutex after iterating through the zonelist;we dont need it yet;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5646160840988159
We now take callback_mutex after iterating through the zonelist;we dont need it yet;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7275102734565735
We now take callback_mutex after iterating through the zonelist;we dont need it yet;Have no license information of any form;GPL v2 only;Contradicts;0.7276636362075806
We now take callback_mutex after iterating through the zonelist;we dont need it yet;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6737104654312134
We now take callback_mutex after iterating through the zonelist;we dont need it yet;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7856796979904175
We now take callback_mutex after iterating through the zonelist;we dont need it yet;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8446526527404785
panic ASAP;want failover;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9828407764434814
panic ASAP;want failover;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5005937218666077
panic ASAP;want failover;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;Contradicts;0.9327003359794617
panic ASAP;want failover;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6861703395843506
panic ASAP;want failover;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6672902703285217
panic ASAP;want failover;Stick to accounting for half;Significant improvement;Contradicts;0.892031192779541
panic ASAP;want failover;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.8408469557762146
panic ASAP;want failover;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;Contradicts;0.7081548571586609
panic ASAP;want failover;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.8816385865211487
panic ASAP;want failover;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6312135457992554
panic ASAP;want failover;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6507152318954468
panic ASAP;want failover;solve in a more reasonable way;more reasonable way;Contradicts;0.8104510307312012
fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.6250808835029602
fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8498812317848206
fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.6826434135437012
fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8934899568557739
fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.5911049246788025
fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;Have no license information of any form;GPL v2 only;Contradicts;0.7530847191810608
fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5501209497451782
fix OOM killing processes wrongly thought MPOL_BIND;wrongly thought MPOL_BIND;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5820237994194031
kill those individual threads;When finding other threads that share an mm with that task;prevent oom from killing a process with children/sibling unkillable;fix oom issue;Contradicts;0.7484282851219177
kill those individual threads;When finding other threads that share an mm with that task;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7108407020568848
kill those individual threads;When finding other threads that share an mm with that task;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5296911597251892
kill those individual threads;When finding other threads that share an mm with that task;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.5105162262916565
kill those individual threads;When finding other threads that share an mm with that task;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;Contradicts;0.5211840271949768
kill those individual threads;When finding other threads that share an mm with that task;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.9527525305747986
kill those individual threads;When finding other threads that share an mm with that task;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5960904359817505
kill those individual threads;When finding other threads that share an mm with that task;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5562899112701416
kill those individual threads;When finding other threads that share an mm with that task;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.7898288369178772
kill those individual threads;When finding other threads that share an mm with that task;solve in a more reasonable way;more reasonable way;Contradicts;0.5308693647384644
kill those individual threads;When finding other threads that share an mm with that task;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.7302109003067017
prevent oom from killing a process with children/sibling unkillable;fix oom issue;"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.5857377648353577
prevent oom from killing a process with children/sibling unkillable;fix oom issue;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6597001552581787
prevent oom from killing a process with children/sibling unkillable;fix oom issue;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.6984719634056091
prevent oom from killing a process with children/sibling unkillable;fix oom issue;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7346668243408203
prevent oom from killing a process with children/sibling unkillable;fix oom issue;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5689678192138672
prevent oom from killing a process with children/sibling unkillable;fix oom issue;select_bad_process() must select killable task;killable task;Contradicts;0.8536006808280945
prevent oom from killing a process with children/sibling unkillable;fix oom issue;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7060832977294922
prevent oom from killing a process with children/sibling unkillable;fix oom issue;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7170738577842712
prevent oom from killing a process with children/sibling unkillable;fix oom issue;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.5402138829231262
prevent oom from killing a process with children/sibling unkillable;fix oom issue;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.553669810295105
prevent oom from killing a process with children/sibling unkillable;fix oom issue;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Contradicts;0.6870342493057251
prevent oom from killing a process with children/sibling unkillable;fix oom issue;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;Contradicts;0.5916024446487427
prevent oom from killing a process with children/sibling unkillable;fix oom issue;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.5953255295753479
prevent oom from killing a process with children/sibling unkillable;fix oom issue;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;Contradicts;0.5737313032150269
prevent oom from killing a process with children/sibling unkillable;fix oom issue;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5046617388725281
prevent oom from killing a process with children/sibling unkillable;fix oom issue;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.9714672565460205
prevent oom from killing a process with children/sibling unkillable;fix oom issue;Kill it and directly access;directly access;Contradicts;0.9047002792358398
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;Contradicts;0.5060659050941467
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9565737843513489
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.7565039992332458
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5185908675193787
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;Contradicts;0.6444469094276428
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6536495685577393
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.6171483397483826
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.56348717212677
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.5174711346626282
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5690169930458069
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.548409640789032
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.7382956743240356
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.6018960475921631
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Stick to accounting for half;Significant improvement;Contradicts;0.5796459913253784
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.551118791103363
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8129935264587402
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.5148571133613586
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Have no license information of any form;GPL v2 only;Contradicts;0.659701943397522
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5238081216812134
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.9214563965797424
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.6359392404556274
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.6000310182571411
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5029065608978271
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;Contradicts;0.7690912485122681
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.5306647419929504
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8585758209228516
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.6332258582115173
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6727114915847778
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.760953426361084
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.861687958240509
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.8658026456832886
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.7361992001533508
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.7572029232978821
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.8734068274497986
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5048575401306152
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.585005521774292
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.5763925313949585
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;I added some more output;Users tend to be irritated by the choice of killed processes;Contradicts;0.5795767903327942
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.7705784440040588
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;no longer get stuck on any lock;a sleeping task may hold;Contradicts;0.5999427437782288
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.9701785445213318
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Remove the unused arguments and update all callers.;unused.;Contradicts;0.6131115555763245
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Remove the unused arguments and update all callers.;unused;Contradicts;0.6131115555763245
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5911248922348022
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.9158303737640381
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Have no license information of any form;GPL v2 only;Contradicts;0.9127612113952637
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5427186489105225
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.5330992937088013
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5416391491889954
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5423405170440674
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;make OOM detection in the freezer path raceless;raceless;Contradicts;0.5215598344802856
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.5551207065582275
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;Contradicts;0.6646168828010559
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;Contradicts;0.8460327982902527
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;delete unlock_range();exit_mmap() does not need locked_vm updates;Contradicts;0.7223269939422607
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.5573313236236572
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;This patch fixes the problem and should be backported into stable/LTS.;Fixes the problem, should be backported into stable/LTS.;Contradicts;0.5449039936065674
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Remove the parameter @mem;removed since v2.6.26;Contradicts;0.7706533074378967
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.7838626503944397
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;delete the corresponding comment;it will be checked in oom_unkillable_task();Contradicts;0.5016524195671082
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;remove the prototype for the old function;the prototype still existed;Contradicts;0.8052206635475159
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Kill it and directly access;directly access;Contradicts;0.9861618280410767
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.8308418393135071
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;skip zombies when iterating tasklist;oom;Contradicts;0.6745251417160034
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.5277023911476135
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;avoid attempting to kill init sharing same memory;avoid attempting to kill init;Contradicts;0.5668454766273499
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.5953785181045532
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;Contradicts;0.535453736782074
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9115613698959351
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5568385124206543
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5650267601013184
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6050233840942383
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;Contradicts;0.5879271030426025
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.956749677658081
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6659902334213257
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.6500864624977112
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;Contradicts;0.7629875540733337
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;Contradicts;0.7006065845489502
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8594996333122253
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;Contradicts;0.5044126510620117
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5192963480949402
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.6554628610610962
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5309893488883972
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8876420855522156
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;Have no license information of any form;GPL v2 only;Contradicts;0.6754688024520874
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.947385311126709
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.8118586540222168
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.7843563556671143
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6494469046592712
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.7552486062049866
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5116705894470215
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7236315011978149
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5201984643936157
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;This change ;will allow such a usecase without worrying about complete memory reserves depletion.;Contradicts;0.7872958183288574
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.7053983807563782
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Introduce is_sysrq_oom helper function;to improve readability;Contradicts;0.582783579826355
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5945507884025574
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.527912437915802
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7708932757377625
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6230599880218506
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;Contradicts;0.5687220692634583
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;select_bad_process() must select killable task;killable task;Contradicts;0.581290602684021
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.80782550573349
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.7216550707817078
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;remove task_t, convert to struct task_struct;cleanup, remove;Contradicts;0.5675756931304932
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;Contradicts;0.5778692364692688
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8380677103996277
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.7160366773605347
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;Contradicts;0.7295548319816589
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Provide more precise dump info while memcg oom happening;more precise dump info;Contradicts;0.5658419728279114
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.5403664112091064
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7221091389656067
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.5362681746482849
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Introduce two new options for madvise;To achieve the goal;Contradicts;0.5195688009262085
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;initialize it before;should;Contradicts;0.5164366960525513
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Have no license information of any form;GPL v2 only;Contradicts;0.7639350295066833
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.8357728719711304
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.8179498314857483
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Add comments describing oom_locks scope;describing oom_locks scope;Contradicts;0.5716485381126404
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Rename page_counter_limit() to page_counter_set_max();The idea behind this renaming is to have the direct matching between memory cgroup knobs (low, high, max) and page_counters API;Contradicts;0.5864126086235046
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7218153476715088
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.679725170135498
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;make OOM detection in the freezer path raceless;raceless;Contradicts;0.6964382529258728
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6595484614372253
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.7459700703620911
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;LSMs should use the new has_capability_noaudit() interface;The denials will not be recorded;Contradicts;0.7409502863883972
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Remove the parameter @mem;removed since v2.6.26;Contradicts;0.6437720060348511
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.8771451115608215
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Add a new flag PF_POSTCOREDUMP;so that tasks that have passed through coredump_task_exit can be recognized and ignored in zap_process;Contradicts;0.5968448519706726
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6131003499031067
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Kill it and directly access;directly access;Contradicts;0.5388524532318115
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5197668075561523
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8067148923873901
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5534281134605408
CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5254183411598206
This change ;will allow such a usecase without worrying about complete memory reserves depletion.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7281740307807922
adding some tracepoints ;might help with debugging of similar issues;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.5402010679244995
adding some tracepoints ;might help with debugging of similar issues;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5199782848358154
adding some tracepoints ;might help with debugging of similar issues;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6702670454978943
adding some tracepoints ;might help with debugging of similar issues;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.9259649515151978
adding some tracepoints ;might help with debugging of similar issues;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5372316837310791
problem mentioned above can be found;How it works in practice;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8329289555549622
problem mentioned above can be found;How it works in practice;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5433933138847351
problem mentioned above can be found;How it works in practice;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5280259847640991
problem mentioned above can be found;How it works in practice;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5560271739959717
problem mentioned above can be found;How it works in practice;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.9081377983093262
problem mentioned above can be found;How it works in practice;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5457764863967896
problem mentioned above can be found;How it works in practice;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.8697656393051147
problem mentioned above can be found;How it works in practice;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.9934995174407959
problem mentioned above can be found;How it works in practice;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8516973853111267
Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.8148239850997925
Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Contradicts;0.6069492101669312
Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9504000544548035
Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5733970403671265
Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5005590915679932
Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6425514817237854
Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6781777143478394
Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.6857959628105164
Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;Have no license information of any form;GPL v2 only;Contradicts;0.6258501410484314
Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6589806079864502
Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5620871186256409
Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8264437317848206
Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5542672276496887
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Contradicts;0.6621941924095154
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;Contradicts;0.6136534810066223
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7652854919433594
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5886737704277039
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8118497729301453
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.8159127831459045
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7618778944015503
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7416938543319702
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5007575154304504
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.6559256315231323
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5343251824378967
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;Have no license information of any form;GPL v2 only;Contradicts;0.5954364538192749
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5490803718566895
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6019304990768433
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.7491694092750549
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;Kill it and directly access;directly access;Contradicts;0.8309840559959412
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6014389991760254
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;skip zombies when iterating tasklist;oom;Contradicts;0.5105273127555847
Prepare for new header dependencies before moving code to <linux/sched/coredump.h>;Prepare for new header dependencies;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7650669813156128
Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;Contradicts;0.8446692228317261
Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7694944143295288
Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5818692445755005
Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;Contradicts;0.5406328439712524
Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5778311491012573
Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7199832797050476
Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.5915875434875488
Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6730199456214905
Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5119633674621582
Create a trivial placeholder <linux/sched/coredump.h> file that just maps to <linux/sched.h>;to make this patch obviously correct and bisectable;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6856482625007629
Include the new header in the files that are going to need it;files that are going to need it;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6172950863838196
Include the new header in the files that are going to need it;files that are going to need it;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7235277891159058
Include the new header in the files that are going to need it;files that are going to need it;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8094729781150818
Include the new header in the files that are going to need it;files that are going to need it;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5502704381942749
Include the new header in the files that are going to need it;files that are going to need it;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6650797724723816
Include the new header in the files that are going to need it;files that are going to need it;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.6277185678482056
Include the new header in the files that are going to need it;files that are going to need it;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5129048824310303
Include the new header in the files that are going to need it;files that are going to need it;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5550417304039001
Include the new header in the files that are going to need it;files that are going to need it;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6981776356697083
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;Contradicts;0.5447337627410889
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7570772171020508
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8297281265258789
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.8334482908248901
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7665197253227234
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6371564269065857
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5007693767547607
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.5539446473121643
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5314533114433289
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5435172319412231
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;Have no license information of any form;GPL v2 only;Contradicts;0.5865670442581177
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5061582326889038
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6078563928604126
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5801995992660522
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6060141324996948
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;Kill it and directly access;directly access;Contradicts;0.7907009720802307
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;skip zombies when iterating tasklist;oom;Contradicts;0.5129268765449524
Prepare for new header dependencies before moving code to <linux/sched/mm.h>;Prepare for new header dependencies;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.789510190486908
Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5133962631225586
Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6271927952766418
Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7391393780708313
Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.5335842967033386
Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5774089694023132
Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.615979790687561
Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.5424882769584656
Create a trivial placeholder <linux/sched/mm.h> file;to make this patch obviously correct and bisectable;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5125324726104736
Include the new header in the files that are going to need it;that are going to need it;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6172950863838196
Include the new header in the files that are going to need it;that are going to need it;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7235277891159058
Include the new header in the files that are going to need it;that are going to need it;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8094729781150818
Include the new header in the files that are going to need it;that are going to need it;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5502704381942749
Include the new header in the files that are going to need it;that are going to need it;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6650797724723816
Include the new header in the files that are going to need it;that are going to need it;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.6277185678482056
Include the new header in the files that are going to need it;that are going to need it;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5129048824310303
Include the new header in the files that are going to need it;that are going to need it;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5550417304039001
Include the new header in the files that are going to need it;that are going to need it;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6981776356697083
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9097524285316467
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5633872747421265
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.6557562351226807
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;Contradicts;0.5286552309989929
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.6558552384376526
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.5602189898490906
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;Have no license information of any form;GPL v2 only;Contradicts;0.6640155911445618
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5500253438949585
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5490533113479614
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.9688856601715088
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7667474150657654
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.8031849265098572
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.539561927318573
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5451721549034119
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5053682923316956
detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7612608671188354
detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8858020305633545
detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.5450398921966553
detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8225985169410706
detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;Have no license information of any form;GPL v2 only;Contradicts;0.5248168110847473
detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6494055986404419
detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6115972399711609
detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7321281433105469
detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.6042510271072388
detail == NULL would give the same functionality as .check_swap_entries==true;give the same functionality as .check_swap_entries==true;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.67051762342453
removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.6911544799804688
removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5849937796592712
removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5041346549987793
removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;Contradicts;0.5512121915817261
removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9462817311286926
removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7733404040336609
removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5012070536613464
removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5347235798835754
removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6659610271453857
Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9350807070732117
Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;It is configurable;so that large systems, such as those with several thousand tasks, do not incur a performance penalty associated with dumping data they may not desire;Contradicts;0.6441469192504883
Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5787209868431091
Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.5215204358100891
Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.7925639152526855
Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5031330585479736
Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.6505547165870667
Introduce is_sysrq_oom helper function;to improve readability;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7527368664741516
Introduce is_sysrq_oom helper function;to improve readability;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5455070734024048
Introduce is_sysrq_oom helper function;to improve readability;percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Contradicts;0.5780863165855408
Introduce is_sysrq_oom helper function;to improve readability;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8216260671615601
Introduce is_sysrq_oom helper function;to improve readability;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6880279183387756
Introduce is_sysrq_oom helper function;to improve readability;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6048992276191711
Introduce is_sysrq_oom helper function;to improve readability;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.6610627174377441
Introduce is_sysrq_oom helper function;to improve readability;Have no license information of any form;GPL v2 only;Contradicts;0.6498826742172241
Introduce is_sysrq_oom helper function;to improve readability;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5579812526702881
Introduce is_sysrq_oom helper function;to improve readability;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6180303692817688
Introduce is_sysrq_oom helper function;to improve readability;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5429892539978027
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.7925377488136292
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.5571462512016296
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5199862718582153
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9718299508094788
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.7513887286186218
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5694910287857056
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Contradicts;0.565858006477356
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5774467587471008
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7675489783287048
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5370495319366455
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.7919554114341736
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6815948486328125
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.8356180191040039
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.5196126699447632
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5134170651435852
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5114109516143799
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.623429000377655
we must not skip this process;because its sub-thread originated the coredump;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.944820761680603
we must not skip this process;because its sub-thread originated the coredump;Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Contradicts;0.6170499920845032
we must not skip this process;because its sub-thread originated the coredump;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5851643085479736
we must not skip this process;because its sub-thread originated the coredump;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.5416869521141052
we must not skip this process;because its sub-thread originated the coredump;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5615707039833069
we must not skip this process;because its sub-thread originated the coredump;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.8108484148979187
we must not skip this process;because its sub-thread originated the coredump;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.89601731300354
we must not skip this process;because its sub-thread originated the coredump;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5755685567855835
we must not skip this process;because its sub-thread originated the coredump;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5268073678016663
we must not skip this process;because its sub-thread originated the coredump;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;Contradicts;0.886573076248169
we must not skip this process;because its sub-thread originated the coredump;Kill it and directly access;directly access;Contradicts;0.7481783032417297
remove the wrong check along with pr_info();wrong check along with pr_info();We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9059136509895325
remove the wrong check along with pr_info();wrong check along with pr_info();Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6223737597465515
remove the wrong check along with pr_info();wrong check along with pr_info();The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.918196439743042
remove the wrong check along with pr_info();wrong check along with pr_info();Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.6316272020339966
remove the wrong check along with pr_info();wrong check along with pr_info();"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5580855011940002
remove the wrong check along with pr_info();wrong check along with pr_info();push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6182725429534912
remove the wrong check along with pr_info();wrong check along with pr_info();Have no license information of any form;GPL v2 only;Contradicts;0.667094886302948
remove the wrong check along with pr_info();wrong check along with pr_info();The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6016523241996765
We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8352407813072205
We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5632044672966003
We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.7400585412979126
We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;OOM killed task shouldnt escape PM suspend;OOM;Contradicts;0.5967308878898621
We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5904890298843384
We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.7621490955352783
We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.755118191242218
We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.5854853391647339
We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;Contradicts;0.7491574883460999
We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Kill it and directly access;directly access;Contradicts;0.9012643694877625
We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6719356179237366
We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.7715447545051575
"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6581469178199768
"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6633530259132385
"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;Contradicts;0.5380710363388062
"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.743772029876709
"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;Contradicts;0.6948955059051514
"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.5530907511711121
"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5257760882377625
"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5051155686378479
"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.8820570111274719
"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.6085529923439026
"suppress unnecessary ""sharing same memory"" message";"unnecessary ""sharing same memory""";Kill it and directly access;directly access;Contradicts;0.7728838324546814
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.6375120282173157
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7202592492103577
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9221621751785278
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.5315762162208557
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6210038065910339
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5165018439292908
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.862424373626709
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;Have no license information of any form;GPL v2 only;Contradicts;0.7632419466972351
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.7424754500389099
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6388537287712097
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;Contradicts;0.5356004238128662
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6882302165031433
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;Reduce the ballast;Doesnt provide any relevant information;Contradicts;0.7213019132614136
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7396992444992065
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6727578043937683
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.6134089827537537
fix potentially killing unrelated process;potentially killing unrelated process;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.503163754940033
fix potentially killing unrelated process;potentially killing unrelated process;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6162441968917847
fix potentially killing unrelated process;potentially killing unrelated process;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.5717182755470276
get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.6443899869918823
get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.5995708107948303
get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9526646733283997
get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6834423542022705
get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5806905627250671
get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;Have no license information of any form;GPL v2 only;Contradicts;0.7850499153137207
get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5493379831314087
get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6612225770950317
get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.5104448795318604
get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.541053056716919
get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6817710995674133
get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.7118127942085266
get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.707996666431427
get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7668245434761047
get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5972896218299866
remove unnecessary variable;unnecessary;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.6924741864204407
"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7412350177764893
"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.648743212223053
"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9883641004562378
"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.57196444272995
"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.6060319542884827
"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.6527429819107056
"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;Have no license information of any form;GPL v2 only;Contradicts;0.7242520451545715
"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6287181973457336
"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6587647199630737
"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5379413962364197
"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6524139642715454
"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;Kill it and directly access;directly access;Contradicts;0.773177444934845
"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5101741552352905
"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;"Users of mmap_sem which need it for write should be carefully reviewed to use _killable waiting as much as possible and reduce allocations requests done with the lock held to absolute minimum
";to reduce the risk even further;Contradicts;0.6673292517662048
Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.7187822461128235
Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6416235566139221
Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8683457374572754
Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.7189515233039856
Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8259269595146179
Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5359484553337097
Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.8629601001739502
Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5342656970024109
Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7048996686935425
Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;Kill it and directly access;directly access;Contradicts;0.844849705696106
Avoid panicking the system for sysrq+f when no processes are killed;no processes are killed;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8273972272872925
Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.7730115652084351
Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8236358165740967
Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.6919196248054504
Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6249280571937561
Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5064581632614136
Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;Contradicts;0.6028134822845459
Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6846191883087158
Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.629727840423584
Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.7477512955665588
Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;Have no license information of any form;GPL v2 only;Contradicts;0.6280312538146973
Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.5078888535499573
Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7115319967269897
Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.528382420539856
Organize these elements into a new struct, struct oom_control;specifies the context for an oom condition;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8245479464530945
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.8405327200889587
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.598223090171814
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.585742712020874
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.5574734807014465
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.5271859169006348
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5965442657470703
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.6116045117378235
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.7009574770927429
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8678638339042664
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.8624712228775024
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Stick to accounting for half;Significant improvement;Contradicts;0.9425826072692871
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.6563487648963928
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.5225244760513306
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5959814786911011
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;initialize it before;should;Contradicts;0.504989504814148
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.8665188550949097
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7858034372329712
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5383673310279846
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.7270199656486511
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5675851106643677
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5077517032623291
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5185525417327881
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;Contradicts;0.5938405394554138
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.8009272813796997
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;avoid attempting to kill init sharing same memory;avoid attempting to kill init;Contradicts;0.5590583682060242
Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9638263583183289
Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5415698885917664
Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5437315702438354
Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();Fix it up via task_lock();instead;Contradicts;0.8605303168296814
Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5647294521331787
Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();Add the necessary rcu_read_lock();necessary;Contradicts;0.9784886837005615
Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;Contradicts;0.7281656861305237
Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.523051381111145
Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();mark_tsk_oom_victim is now called under task_lock;I think this should be OK because __thaw_task shouldnt interfere with any locking down wake_up_process;Contradicts;0.5197551250457764
Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5126016139984131
Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7185840010643005
Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.6390843391418457
This could have been replaced with waitqueue_active();it only saves a few instructions in one of the coldest paths in the kernel;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.5130345225334167
This could have been replaced with waitqueue_active();it only saves a few instructions in one of the coldest paths in the kernel;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8524020314216614
This could have been replaced with waitqueue_active();it only saves a few instructions in one of the coldest paths in the kernel;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5992368459701538
This could have been replaced with waitqueue_active();it only saves a few instructions in one of the coldest paths in the kernel;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5171988606452942
Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.6055095195770264
Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;modify implementation of per-mm counter;reducing patch size in future patch;Contradicts;0.5431656837463379
Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5910095572471619
Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6681007742881775
Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5373525023460388
Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;fix-up schedule_timeout() usage;fix-up;Contradicts;0.5171540975570679
Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.7124598622322083
Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Have no license information of any form;GPL v2 only;Contradicts;0.5320563316345215
Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5005276203155518
Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6841362118721008
Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5503501296043396
Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5744403600692749
Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6902811527252197
CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8380813002586365
CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6369338631629944
CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;Contradicts;0.5534133315086365
CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.7395058870315552
CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6321280598640442
CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5269540548324585
CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5435859560966492
CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.671638548374176
CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Contradicts;0.5143372416496277
CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";make OOM detection in the freezer path raceless;raceless;Contradicts;0.5207264423370361
CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5974493026733398
CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Kill it and directly access;directly access;Contradicts;0.7843607664108276
percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;modify implementation of per-mm counter;reducing patch size in future patch;Contradicts;0.8198022246360779
percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6812331676483154
percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;The counter is updated so early to reduce the race window;to reduce the race window;Contradicts;0.504036545753479
percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;I added some more output;Users tend to be irritated by the choice of killed processes;Contradicts;0.6113402247428894
percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.647103488445282
percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;initialize it before;should;Contradicts;0.6182125210762024
percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.7458363175392151
percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.6975069642066956
percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;Kill it and directly access;directly access;Contradicts;0.7558230757713318
percpu.h modifications were reverted;so that it could be applied as a separate patch and serve as bisection point;skip zombies when iterating tasklist;oom;Contradicts;0.5300114154815674
Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.594458281993866
Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.778718888759613
Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.6923388242721558
Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6146659255027771
Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.5517061352729797
Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.5233080983161926
Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;Have no license information of any form;GPL v2 only;Contradicts;0.6455623507499695
Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.502167284488678
Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7603644728660583
Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5449160933494568
Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;Kill it and directly access;directly access;Contradicts;0.5906794667243958
modify implementation of per-mm counter;reducing patch size in future patch;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6438230872154236
modify implementation of per-mm counter;reducing patch size in future patch;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.6721094846725464
modify implementation of per-mm counter;reducing patch size in future patch;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5627399682998657
fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9415245652198792
fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7295958399772644
fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5851820111274719
fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.6379196047782898
fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.8140803575515747
fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5097049474716187
fix for this bug;fix;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.6028432250022888
fix for this bug;fix;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5917866826057434
fix for this bug;fix;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5024980902671814
fix for this bug;fix;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5807367563247681
fixes the arg for mem_cgroup_print_oom_info();fixes;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9839550256729126
fixes the arg for mem_cgroup_print_oom_info();fixes;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.597672700881958
fixes the arg for mem_cgroup_print_oom_info();fixes;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5967114567756653
fixes the arg for mem_cgroup_print_oom_info();fixes;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6451006531715393
fixes the arg for mem_cgroup_print_oom_info();fixes;Have no license information of any form;GPL v2 only;Contradicts;0.9349274039268494
fixes the arg for mem_cgroup_print_oom_info();fixes;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.696510374546051
fixes the arg for mem_cgroup_print_oom_info();fixes;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.610711932182312
fixes the arg for mem_cgroup_print_oom_info();fixes;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6737076640129089
Print information of mem_cgroup;The task being killed, not current, belongs to mem_cgroup;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7518500685691833
Print information of mem_cgroup;The task being killed, not current, belongs to mem_cgroup;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5915526151657104
Print information of mem_cgroup;The task being killed, not current, belongs to mem_cgroup;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.66866534948349
Print information of mem_cgroup;The task being killed, not current, belongs to mem_cgroup;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5309504270553589
Print information of mem_cgroup;The task being killed, not current, belongs to mem_cgroup;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5203574299812317
Print information of mem_cgroup;The task being killed, not current, belongs to mem_cgroup;Have no license information of any form;GPL v2 only;Contradicts;0.9873342514038086
Print information of mem_cgroup;The task being killed, not current, belongs to mem_cgroup;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6952540874481201
fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9358870983123779
fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6696227788925171
fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.5896705389022827
fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6573729515075684
fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.6140785217285156
fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5186372399330139
fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.8995510935783386
fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7192345857620239
Fix node-oriented allocation handling in oom-kill.c;bugfix;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9400403499603271
Fix node-oriented allocation handling in oom-kill.c;bugfix;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.5277032256126404
Fix node-oriented allocation handling in oom-kill.c;bugfix;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6620518565177917
Fix node-oriented allocation handling in oom-kill.c;bugfix;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5747019052505493
Fix node-oriented allocation handling in oom-kill.c;bugfix;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5163553357124329
Fix node-oriented allocation handling in oom-kill.c;bugfix;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.520797073841095
Fix node-oriented allocation handling in oom-kill.c;bugfix;Stick to accounting for half;Significant improvement;Contradicts;0.6894800066947937
Fix node-oriented allocation handling in oom-kill.c;bugfix;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.7892975807189941
Fix node-oriented allocation handling in oom-kill.c;bugfix;Have no license information of any form;GPL v2 only;Contradicts;0.6512241363525391
Fix node-oriented allocation handling in oom-kill.c;bugfix;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.598476767539978
Fix node-oriented allocation handling in oom-kill.c;bugfix;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.6084970235824585
Fix node-oriented allocation handling in oom-kill.c;bugfix;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Contradicts;0.5384132862091064
Fix node-oriented allocation handling in oom-kill.c;bugfix;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5268499255180359
Fix node-oriented allocation handling in oom-kill.c;bugfix;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5307623744010925
Fix node-oriented allocation handling in oom-kill.c;bugfix;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5210453271865845
Fix node-oriented allocation handling in oom-kill.c;bugfix;Information for all other nodes is irrelevant to the oom condition;we dont care if theres an abundance of memory elsewhere if we cant access it;Contradicts;0.5809558629989624
Fix node-oriented allocation handling in oom-kill.c;bugfix;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8286051750183105
Fix node-oriented allocation handling in oom-kill.c;bugfix;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.665253758430481
adds vsz and rss information to the oom log;to help this analysis;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8564067482948303
adds vsz and rss information to the oom log;to help this analysis;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.6596691608428955
adds vsz and rss information to the oom log;to help this analysis;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.7610771656036377
adds vsz and rss information to the oom log;to help this analysis;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7030984163284302
adds vsz and rss information to the oom log;to help this analysis;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.5034192800521851
adds vsz and rss information to the oom log;to help this analysis;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5684930086135864
adds vsz and rss information to the oom log;to help this analysis;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5524619221687317
adds vsz and rss information to the oom log;to help this analysis;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.6642661094665527
adds vsz and rss information to the oom log;to help this analysis;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5998645424842834
adds vsz and rss information to the oom log;to help this analysis;Have no license information of any form;GPL v2 only;Contradicts;0.9803382158279419
adds vsz and rss information to the oom log;to help this analysis;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5917354822158813
adds vsz and rss information to the oom log;to help this analysis;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5648428201675415
adds vsz and rss information to the oom log;to help this analysis;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5451391339302063
adds vsz and rss information to the oom log;to help this analysis;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7657294869422913
adds vsz and rss information to the oom log;to help this analysis;This patch causes only memory information to be displayed for nodes that are allowed by currents cpuset when dumping the VM state;to prevent verbosity that can be harmful and cause other important messages to be scrolled from the kernel log and incur a significant time delay;Contradicts;0.6861062049865723
adds vsz and rss information to the oom log;to help this analysis;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.6763244271278381
adds vsz and rss information to the oom log;to help this analysis;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.6893685460090637
This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.7350997924804688
This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5760301351547241
This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.9627922773361206
This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5241245031356812
This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5746698975563049
This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;This patch causes only memory information to be displayed for nodes that are allowed by currents cpuset when dumping the VM state;to prevent verbosity that can be harmful and cause other important messages to be scrolled from the kernel log and incur a significant time delay;Contradicts;0.612407922744751
select_bad_process();it makes consistency more and makes speed up;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9067061543464661
select_bad_process();it makes consistency more and makes speed up;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.7336713075637817
select_bad_process();it makes consistency more and makes speed up;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5876230597496033
select_bad_process();it makes consistency more and makes speed up;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5613333582878113
select_bad_process();it makes consistency more and makes speed up;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5660702586174011
select_bad_process() must select killable task;killable task;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9276869297027588
select_bad_process() must select killable task;killable task;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.7004261016845703
select_bad_process() must select killable task;killable task;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6613414883613586
select_bad_process() must select killable task;killable task;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.5675052404403687
select_bad_process() must select killable task;killable task;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5443803071975708
select_bad_process() must select killable task;killable task;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5904033780097961
select_bad_process() must select killable task;killable task;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5575042366981506
select_bad_process() must select killable task;killable task;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6453640460968018
select_bad_process() must select killable task;killable task;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5672810673713684
select_bad_process() must select killable task;killable task;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5805436372756958
select_bad_process() must select killable task;killable task;delete unlock_range();exit_mmap() does not need locked_vm updates;Contradicts;0.5312126278877258
select_bad_process() must select killable task;killable task;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.6278336644172668
select_bad_process() must select killable task;killable task;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.7630574107170105
select_bad_process() must select killable task;killable task;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5004377961158752
select_bad_process() must select killable task;killable task;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.8100643157958984
it should be per-process value;OOM-killer kill a process, not thread;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.5775690078735352
it should be per-process value;OOM-killer kill a process, not thread;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6575937867164612
it should be per-process value;OOM-killer kill a process, not thread;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.6417587995529175
it should be per-process value;OOM-killer kill a process, not thread;Stick to accounting for half;Significant improvement;Contradicts;0.7148098349571228
it should be per-process value;OOM-killer kill a process, not thread;Kill it and directly access;directly access;Contradicts;0.659247875213623
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9333836436271667
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5600613355636597
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.6117614507675171
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.5268362164497375
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6995568871498108
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;Contradicts;0.5139927864074707
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;Fix it up via task_lock();instead;Contradicts;0.6807932257652283
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.8359347581863403
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;Stick to accounting for half;Significant improvement;Contradicts;0.5341793894767761
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5115596055984497
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6610013842582703
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;Have no license information of any form;GPL v2 only;Contradicts;0.7981259822845459
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.7004416584968567
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.7476921081542969
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;fix vm_oom_kill_table[];ifdeffery;Contradicts;0.5117248296737671
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;Contradicts;0.5189441442489624
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.7821800708770752
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;Contradicts;0.6419563293457031
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6526757478713989
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.9186636209487915
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8645408749580383
use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.8840505480766296
use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5825333595275879
use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7470934391021729
use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5049738883972168
use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;Have no license information of any form;GPL v2 only;Contradicts;0.5206150412559509
use this helper in place of tsk_is_oom_victim;Any context which operates on a remote mm struct should use this helper;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6272788047790527
The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;Contradicts;0.5437310934066772
The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.6518814563751221
The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;Contradicts;0.5811601877212524
The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.55312180519104
The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.6629809141159058
The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;fix typo in comment;typo in comment;Contradicts;0.5350099205970764
The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.5579935908317566
The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;Contradicts;0.5565386414527893
The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;fix typos in comments;typos in comments;Contradicts;0.6738031506538391
The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Kill it and directly access;directly access;Contradicts;0.5674434304237366
The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;skip zombies when iterating tasklist;oom;Contradicts;0.526203453540802
The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;prevent unnecessary oom kills or kernel panics;unnecessary oom kills or kernel panics;Contradicts;0.6594403982162476
The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;detect threads that are in the exit path, specifically those with PF_EXITING set;to prevent needlessly killing additional tasks;Contradicts;0.5346475839614868
gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.5114759206771851
gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5332731008529663
gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.8211571574211121
gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5976386666297913
gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.7233337163925171
gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.6825406551361084
gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.5009152889251709
gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6863700747489929
gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;Kill it and directly access;directly access;Contradicts;0.8505244851112366
gather each vma to prevent leaking TLB entry;prevent leaking TLB entry;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7396999597549438
The behavior of oom reaper become similar to munmapping before do_exit;should be safe for all archs;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6797335743904114
The behavior of oom reaper become similar to munmapping before do_exit;should be safe for all archs;Have no license information of any form;GPL v2 only;Contradicts;0.5709981322288513
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.9783880114555359
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.642852783203125
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5983247756958008
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;remove task_t, convert to struct task_struct;cleanup, remove;Contradicts;0.5797477960586548
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6651097536087036
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.5998102426528931
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6022614240646362
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.5083504319190979
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5155885219573975
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;Contradicts;0.6722127795219421
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;convert it to atomic_long_t;to avoid races;Contradicts;0.5389073491096497
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.5952852964401245
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.7905800938606262
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;Have no license information of any form;GPL v2 only;Contradicts;0.7406441569328308
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5048727989196777
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6239674091339111
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;Contradicts;0.5923216938972473
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5399423837661743
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5376081466674805
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.530661404132843
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5968667268753052
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6693482995033264
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;remove the prototype for the old function;the prototype still existed;Contradicts;0.5010536909103394
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;Kill it and directly access;directly access;Contradicts;0.5468332767486572
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.561382532119751
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5851330757141113
Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.6276041865348816
Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.5699581503868103
Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.573058545589447
Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;Contradicts;0.5184091925621033
Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7467125654220581
Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Stick to accounting for half;Significant improvement;Contradicts;0.6986024975776672
Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Add the necessary rcu_read_lock();necessary;Contradicts;0.7313892245292664
Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.6683836579322815
Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6698964238166809
Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Have no license information of any form;GPL v2 only;Contradicts;0.7795489430427551
Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6221953630447388
Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.8178162574768066
Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5615314841270447
Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7163238525390625
Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5669918060302734
Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Kill it and directly access;directly access;Contradicts;0.770496129989624
remove pointless kthread_run() error check;pointless;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.7305218577384949
remove pointless kthread_run() error check;pointless;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6164606809616089
remove pointless kthread_run() error check;pointless;Add the necessary rcu_read_lock();necessary;Contradicts;0.5024813413619995
remove pointless kthread_run() error check;pointless;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5452970862388611
remove pointless kthread_run() error check;pointless;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7288963198661804
remove pointless kthread_run() error check;pointless;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.5080428719520569
remove pointless kthread_run() error check;pointless;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5257040858268738
remove pointless kthread_run() error check;pointless;Kill it and directly access;directly access;Contradicts;0.5756281018257141
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.8528702259063721
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.7039766907691956
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";hold tasklist_lock;tsk->sighand is not guarded by RCU, just as what out_of_memory() does.;Contradicts;0.5816308259963989
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;Contradicts;0.5221169590950012
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.5996851921081543
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5445842146873474
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.8375283479690552
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";remove task_t, convert to struct task_struct;cleanup, remove;Contradicts;0.5995951890945435
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.7316250801086426
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6639407873153687
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6961439251899719
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.6197112202644348
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Fix it up via task_lock();instead;Contradicts;0.7462902069091797
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.883669376373291
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Stick to accounting for half;Significant improvement;Contradicts;0.93816739320755
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";move the cpuset semaphore region outside the tasklist_lock region;The fix seems easy enough;Contradicts;0.5334519743919373
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.8130691051483154
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5332955121994019
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.6384314894676208
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";convert it to atomic_long_t;to avoid races;Contradicts;0.5605257153511047
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Provide more precise dump info while memcg oom happening;more precise dump info;Contradicts;0.5144099593162537
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.9434459209442139
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.889208972454071
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Show some helpful information;to indicate why this happens;Contradicts;0.7293389439582825
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7386329770088196
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.581883430480957
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";initialize it before;should;Contradicts;0.6984069347381592
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Have no license information of any form;GPL v2 only;Contradicts;0.8498400449752808
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.779524028301239
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5491201877593994
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5019171833992004
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;Contradicts;0.8601011633872986
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;Contradicts;0.6040595173835754
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.6214728355407715
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";solve in a more reasonable way;more reasonable way;Contradicts;0.7638686895370483
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Rename page_counter_limit() to page_counter_set_max();The idea behind this renaming is to have the direct matching between memory cgroup knobs (low, high, max) and page_counters API;Contradicts;0.5724145770072937
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6284593343734741
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5542548298835754
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";make OOM detection in the freezer path raceless;raceless;Contradicts;0.5479156374931335
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Reduce the ballast;Doesnt provide any relevant information;Contradicts;0.5811814665794373
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";delete unlock_range();exit_mmap() does not need locked_vm updates;Contradicts;0.6582459211349487
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.7429275512695312
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.7564942836761475
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.7148231863975525
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.9137211441993713
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;Contradicts;0.5325080156326294
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.647214949131012
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6626231074333191
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";remove the prototype for the old function;the prototype still existed;Contradicts;0.5427050590515137
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Kill it and directly access;directly access;Contradicts;0.9563543796539307
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.6183179616928101
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7002013921737671
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";skip zombies when iterating tasklist;oom;Contradicts;0.560921311378479
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6178224086761475
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.8273293972015381
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.7730283737182617
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";avoid attempting to kill init sharing same memory;avoid attempting to kill init;Contradicts;0.5215787887573242
add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.514291524887085
add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6360921263694763
add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7658119797706604
add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5772979259490967
add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7351268529891968
add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;Have no license information of any form;GPL v2 only;Contradicts;0.8442190289497375
add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6104397177696228
add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8268238306045532
add wrappers for ->nr_ptes with the same interface as for nr_pmd and nr_pud;same interface as for nr_pmd and nr_pud;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.7406730055809021
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.9098841547966003
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;hold tasklist_lock;tsk->sighand is not guarded by RCU, just as what out_of_memory() does.;Contradicts;0.7355880737304688
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;Contradicts;0.6191005110740662
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.913314938545227
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5716100931167603
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.5213159322738647
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.5979611277580261
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.8674189448356628
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.8476529121398926
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.5528806447982788
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.8619633316993713
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.9229739308357239
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8723249435424805
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;remove unnecessary exit_state check;unnecessary;Contradicts;0.9047065377235413
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;Contradicts;0.5095291137695312
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5224792957305908
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;out_of_memory() locking fix;locking fix;Contradicts;0.5984340310096741
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.760879397392273
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Stick to accounting for half;Significant improvement;Contradicts;0.7831552028656006
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.8773390650749207
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Contradicts;0.5948137640953064
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;Contradicts;0.6767022013664246
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.7037819027900696
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Add the necessary rcu_read_lock();necessary;Contradicts;0.5238018035888672
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;convert it to atomic_long_t;to avoid races;Contradicts;0.5276021361351013
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;the OOM victim can not get stuck on locks the looping task may hold;this way;Contradicts;0.5220234394073486
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.6386827230453491
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7071983218193054
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.5830586552619934
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;initialize it before;should;Contradicts;0.6475414037704468
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Have no license information of any form;GPL v2 only;Contradicts;0.7735397815704346
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.746452271938324
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.8512213826179504
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.9073082208633423
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;call tlb_finish_mmu;there is no real reason to skip tlb_finish_mmu on early skip either;Contradicts;0.6558924913406372
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.529013991355896
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6601005792617798
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;improve that even further;there is a common pattern to do a range lookup first and then do something about that;Contradicts;0.642022967338562
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.767974853515625
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5874852538108826
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Contradicts;0.6858595013618469
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5462345480918884
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;make OOM detection in the freezer path raceless;raceless;Contradicts;0.6356472969055176
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.886412501335144
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.7017836570739746
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;mark_tsk_oom_victim is now called under task_lock;I think this should be OK because __thaw_task shouldnt interfere with any locking down wake_up_process;Contradicts;0.6085374355316162
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Reduce the ballast;Doesnt provide any relevant information;Contradicts;0.54378741979599
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;Contradicts;0.5226625204086304
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.5887850522994995
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;fix vm_oom_kill_table[];ifdeffery;Contradicts;0.563581645488739
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;Contradicts;0.9312220215797424
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.7983209490776062
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.5701442956924438
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;LSMs should use the new has_capability_noaudit() interface;The denials will not be recorded;Contradicts;0.6276431083679199
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Remove the parameter @mem;removed since v2.6.26;Contradicts;0.7945926785469055
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.6605261564254761
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;Contradicts;0.553647518157959
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6602962017059326
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.8078007698059082
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Kill it and directly access;directly access;Contradicts;0.9202320575714111
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.8860102891921997
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.828272819519043
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.6018733978271484
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5506245493888855
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;make the oom_reaper thread freezable;In order to close this race;Contradicts;0.6148651242256165
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;wake_oom_reaper used a more robust queuing;The situation would improve considerably;Contradicts;0.5692961812019348
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.7745959758758545
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;Contradicts;0.6309405565261841
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;Update the comments for __oom_kill_task();to reflect the code changes;Contradicts;0.5002533793449402
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5166324377059937
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;OOM killed task shouldnt escape PM suspend;OOM;Contradicts;0.5804096460342407
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8292664289474487
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5408551096916199
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.6465579271316528
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5672639012336731
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;Have no license information of any form;GPL v2 only;Contradicts;0.6039287447929382
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.7836011052131653
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.6586962342262268
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5049057006835938
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5034139752388
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.6943904161453247
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.7485290765762329
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;Contradicts;0.7618991732597351
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.680001437664032
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5050747394561768
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8533841967582703
exit_mmap will wait for oom_reap_task() to finish in down_write;before taking down mm structures that would make the oom_reap_task fail with use after free;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5079101920127869
Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.6893470287322998
Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6512271761894226
Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6798552870750427
Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5528631210327148
Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8070719242095947
Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Have no license information of any form;GPL v2 only;Contradicts;0.7009749412536621
Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6336385011672974
Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.731619119644165
Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;A kernel thread has been chosen;we need a reliable way of invocation so workqueue context is not appropriate because all the workers might be busy;Contradicts;0.5121195316314697
hold tasklist_lock;tsk->sighand is not guarded by RCU, just as what out_of_memory() does.;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.5338619947433472
hold tasklist_lock;tsk->sighand is not guarded by RCU, just as what out_of_memory() does.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.714342474937439
hold tasklist_lock;tsk->sighand is not guarded by RCU, just as what out_of_memory() does.;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.7035433053970337
Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.5192543268203735
Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5378913283348083
Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;Fix it up via task_lock();instead;Contradicts;0.5041940808296204
Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.5537382960319519
Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;Have no license information of any form;GPL v2 only;Contradicts;0.7431409955024719
Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5638914108276367
Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5223352909088135
Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5164784789085388
Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5244532823562622
Fix kernel-doc notation in oom_kill.c;kernel-doc notation needs to be fixed;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7445081472396851
add sysctl to enable task memory dump;enable task memory dump;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5896585583686829
add sysctl to enable task memory dump;enable task memory dump;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7101050019264221
add sysctl to enable task memory dump;enable task memory dump;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5884342193603516
add sysctl to enable task memory dump;enable task memory dump;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8097538948059082
Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5630233287811279
Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5984561443328857
Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.5471875667572021
Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.556115448474884
Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;Contradicts;0.719484269618988
Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;Contradicts;0.5001938343048096
Adds a new sysctl, oom_dump_tasks;enables the kernel to produce a dump of all system tasks;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.652408242225647
It is configurable;so that large systems, such as those with several thousand tasks, do not incur a performance penalty associated with dumping data they may not desire;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.6543150544166565
It is configurable;so that large systems, such as those with several thousand tasks, do not incur a performance penalty associated with dumping data they may not desire;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.6250237226486206
The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.72495037317276
The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5104621052742004
The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.641965925693512
The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7478246092796326
The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.7705469727516174
The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.536888599395752
The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6441973447799683
The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6195909976959229
The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5289809703826904
The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;Kill it and directly access;directly access;Contradicts;0.531939685344696
The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7473155856132507
The tasklist shall be filtered to exclude tasks that are not a member of the same cgroup.;to exclude tasks that are not a member of the same cgroup.;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.6533980369567871
Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6914932727813721
Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5102251768112183
Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.5083655118942261
Trust CAP_SYS_ADMIN;uid comparisons are unnecessary;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.5875198245048523
allow for CAP_SYS_RESOURCE as well;"CAP_SYS_RESOURCE means ""give me extra resources""";Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6561716794967651
allow for CAP_SYS_RESOURCE as well;"CAP_SYS_RESOURCE means ""give me extra resources""";push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6315868496894836
allow for CAP_SYS_RESOURCE as well;"CAP_SYS_RESOURCE means ""give me extra resources""";Stick to accounting for half;Significant improvement;Contradicts;0.6253977417945862
allow for CAP_SYS_RESOURCE as well;"CAP_SYS_RESOURCE means ""give me extra resources""";use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.8468199968338013
allow for CAP_SYS_RESOURCE as well;"CAP_SYS_RESOURCE means ""give me extra resources""";Have no license information of any form;GPL v2 only;Contradicts;0.6286501884460449
allow for CAP_SYS_RESOURCE as well;"CAP_SYS_RESOURCE means ""give me extra resources""";We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5626118779182434
allow for CAP_SYS_RESOURCE as well;"CAP_SYS_RESOURCE means ""give me extra resources""";The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5704503059387207
allow for CAP_SYS_RESOURCE as well;"CAP_SYS_RESOURCE means ""give me extra resources""";Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.6449547410011292
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.610601007938385
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.5408321022987366
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.7279808521270752
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7201339602470398
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.514333188533783
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.9458023905754089
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;renaming;doesnt bring any functional change;Contradicts;0.8156086802482605
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.815811276435852
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;delete unlock_range();exit_mmap() does not need locked_vm updates;Contradicts;0.9550231099128723
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.5468348264694214
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;LSMs should use the new has_capability_noaudit() interface;The denials will not be recorded;Contradicts;0.5106955170631409
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.7195748686790466
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.7903581857681274
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;delete the corresponding comment;it will be checked in oom_unkillable_task();Contradicts;0.5376424789428711
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Kill it and directly access;directly access;Contradicts;0.566013514995575
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7040777206420898
uid==0 makes processes only on the host more important;even without any capabilities;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.582138180732727
uid==0 makes processes only on the host more important;even without any capabilities;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5921363234519958
uid==0 makes processes only on the host more important;even without any capabilities;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.6923187971115112
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;Contradicts;0.6095103621482849
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.6233958601951599
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.5735738277435303
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8762239813804626
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.8999482989311218
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.8454625010490417
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;Stick to accounting for half;Significant improvement;Contradicts;0.633474588394165
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.5465121865272522
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5737799406051636
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.6998915076255798
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.8564866185188293
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.6066142916679382
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6239014267921448
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;Have no license information of any form;GPL v2 only;Contradicts;0.9137638211250305
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5102512836456299
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.6557601690292358
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.8579533696174622
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.8342708349227905
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6232447028160095
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.5623764991760254
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5438451170921326
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;Remove the parameter @mem;removed since v2.6.26;Contradicts;0.685836911201477
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;cap_safe_nice() only ever saw current, so now uses capable();only ever saw current, capable();Contradicts;0.7748452425003052
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5554240345954895
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6329606175422668
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;remove the prototype for the old function;the prototype still existed;Contradicts;0.7437432408332825
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;Kill it and directly access;directly access;Contradicts;0.6255261898040771
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5561625957489014
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;skip zombies when iterating tasklist;oom;Contradicts;0.601612389087677
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.59401535987854
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;Add a missing newline;missing;Contradicts;0.5360884070396423
Move the task_struct members specific to rt scheduling together;specific to rt scheduling;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.5433961749076843
Move the task_struct members specific to rt scheduling together;specific to rt scheduling;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5780795812606812
Move the task_struct members specific to rt scheduling together;specific to rt scheduling;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6565788984298706
Move the task_struct members specific to rt scheduling together;specific to rt scheduling;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5392090082168579
Move the task_struct members specific to rt scheduling together;specific to rt scheduling;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.5465744733810425
Move the task_struct members specific to rt scheduling together;specific to rt scheduling;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5366456508636475
Move the task_struct members specific to rt scheduling together;specific to rt scheduling;Have no license information of any form;GPL v2 only;Contradicts;0.6640838384628296
Move the task_struct members specific to rt scheduling together;specific to rt scheduling;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5825070738792419
Move the task_struct members specific to rt scheduling together;specific to rt scheduling;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6207613348960876
Move the task_struct members specific to rt scheduling together;specific to rt scheduling;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7777890563011169
Move the task_struct members specific to rt scheduling together;specific to rt scheduling;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5186818838119507
Move the task_struct members specific to rt scheduling together;specific to rt scheduling;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5217791199684143
Use helpers to obtain task pid in printks;to obtain task pid in printks;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6384342312812805
Use helpers to obtain task pid in printks;to obtain task pid in printks;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.5134844779968262
Use helpers to obtain task pid in printks;to obtain task pid in printks;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.8007149696350098
Use helpers to obtain task pid in printks;to obtain task pid in printks;Have no license information of any form;GPL v2 only;Contradicts;0.6940857768058777
Use helpers to obtain task pid in printks;to obtain task pid in printks;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6006933450698853
Use helpers to obtain task pid in printks;to obtain task pid in printks;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.608441948890686
Use helpers to obtain task pid in printks;to obtain task pid in printks;Kill it and directly access;directly access;Contradicts;0.5752491354942322
Use helpers to obtain task pid in printks;to obtain task pid in printks;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.564428985118866
Use helpers to obtain task pid in printks;to obtain task pid in printks;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6188939809799194
Use helpers to obtain task pid in printks;to obtain task pid in printks;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.8459240198135376
start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5306844711303711
start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8817124962806702
start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.8779756426811218
start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7006956338882446
start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;Have no license information of any form;GPL v2 only;Contradicts;0.65966796875
start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.5876716375350952
start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6222339868545532
start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5168495774269104
start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5770856142044067
start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;Kill it and directly access;directly access;Contradicts;0.5227627158164978
start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8336198329925537
start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.551359236240387
start using the helpers (task_pid_nr/task_pid_vnr/task_pid_nr_ns) in the kernel;The task_struct->pid member is going to be deprecated;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.6382141709327698
start with the pid, printed to dmesg ;safely use task_pid_nr() in this case;panic is preferable rather than kill some processes;there are environments where panic is preferable;Contradicts;0.5097365379333496
start with the pid, printed to dmesg ;safely use task_pid_nr() in this case;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5745362043380737
start with the pid, printed to dmesg ;safely use task_pid_nr() in this case;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.737127423286438
start with the pid, printed to dmesg ;safely use task_pid_nr() in this case;Have no license information of any form;GPL v2 only;Contradicts;0.5990512371063232
start with the pid, printed to dmesg ;safely use task_pid_nr() in this case;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5479515194892883
start with the pid, printed to dmesg ;safely use task_pid_nr() in this case;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.616783618927002
start with the pid, printed to dmesg ;safely use task_pid_nr() in this case;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5772702097892761
hide it behind the helpers;With pid namespaces this field is now dangerous to use explicitly;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5248941779136658
hide it behind the helpers;With pid namespaces this field is now dangerous to use explicitly;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5581744313240051
hide it behind the helpers;With pid namespaces this field is now dangerous to use explicitly;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.7419416904449463
hide it behind the helpers;With pid namespaces this field is now dangerous to use explicitly;Kill it and directly access;directly access;Contradicts;0.5847366452217102
hide it behind the helpers;With pid namespaces this field is now dangerous to use explicitly;The oom killer does not want to defer in this case;there is no guarantee that thread will ever exit without intervention;Contradicts;0.7307841181755066
start isolating the tons of warnings;cannot be sent right now as this leads to tons of warnings;It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Contradicts;0.5980114340782166
start isolating the tons of warnings;cannot be sent right now as this leads to tons of warnings;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5765072107315063
start isolating the tons of warnings;cannot be sent right now as this leads to tons of warnings;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5214409828186035
p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6682213544845581
p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6876901388168335
p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5171175003051758
p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;Have no license information of any form;GPL v2 only;Contradicts;0.8168197870254517
p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5045274496078491
p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.775569498538971
p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6033647060394287
p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5368791818618774
p->tgid == pid has to be changed to has_group_leader_pid();Oleg pointed out that in case of posix cpu timers this is the same, and thread_group_leader() is more preferable.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7992454767227173
kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5288401246070862
kill only the cgroup if the cgroups init has a bug;rather than force a kernel panic;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.59870845079422
It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Stick to accounting for half;Significant improvement;Contradicts;0.6122865080833435
It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5802368521690369
It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5372488498687744
It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6886841058731079
It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5289592146873474
It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5480718016624451
It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.902287483215332
It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.630527913570404
update comments to reflect current code;reflect current code;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.7669598460197449
update comments to reflect current code;reflect current code;remove unnecessary exit_state check;unnecessary;Contradicts;0.5288050174713135
update comments to reflect current code;reflect current code;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5346273183822632
update comments to reflect current code;reflect current code;remove a stale code;quick fixup;Contradicts;0.7817121744155884
update comments to reflect current code;reflect current code;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5429107546806335
update comments to reflect current code;reflect current code;delete the corresponding comment;it will be checked in oom_unkillable_task();Contradicts;0.5342803001403809
update comments to reflect current code;reflect current code;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.6547873616218567
Update the comments for __oom_kill_task();to reflect the code changes;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5518845319747925
Update the comments for __oom_kill_task();to reflect the code changes;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.653880774974823
Update the comments for __oom_kill_task();to reflect the code changes;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5116941332817078
Update the comments for __oom_kill_task();to reflect the code changes;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5134506821632385
Update the comments for __oom_kill_task();to reflect the code changes;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5332762598991394
Update the comments for __oom_kill_task();to reflect the code changes;delete the corresponding comment;it will be checked in oom_unkillable_task();Contradicts;0.815309464931488
Update the comments for __oom_kill_task();to reflect the code changes;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.5159125328063965
Moving the test down;will give the desired behaviour;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8169830441474915
Moving the test down;will give the desired behaviour;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.9501559138298035
This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.9363641142845154
This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.9382614493370056
This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.6335048079490662
This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5919274091720581
This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.9728145599365234
This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5760741233825684
This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5553708076477051
This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5879161953926086
This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.7598164081573486
This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.5603137016296387
This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.9074370861053467
This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.514288067817688
it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5722048878669739
it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5416200757026672
it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.8409841060638428
it should actually be allowed to access reserved memory;current is exiting and it should not OOM kill something else;considered a reasonable constrain;the overall system health is more important than debugability of a particular application;Contradicts;0.5507022738456726
Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;Patches 3 and 4 should go in ditto;trivial printk -> pr_info conversion;Contradicts;0.5490204691886902
Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5127943754196167
Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.6572113037109375
Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5252839922904968
Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.7547205686569214
Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.9790346622467041
Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.9892059564590454
Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.8847330808639526
Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;make OOM detection in the freezer path raceless;raceless;Contradicts;0.5799601674079895
Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;Kill it and directly access;directly access;Contradicts;0.8483377695083618
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5955657362937927
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8205381631851196
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;Stick to accounting for half;Significant improvement;Contradicts;0.5793761610984802
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5156888365745544
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5084131956100464
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7347205281257629
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;Have no license information of any form;GPL v2 only;Contradicts;0.5983895063400269
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.7470964789390564
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.720291256904602
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.599168062210083
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5351977944374084
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.523712694644928
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.8504924178123474
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;Reduce the ballast;Doesnt provide any relevant information;Contradicts;0.6154605150222778
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6839314699172974
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;Kill it and directly access;directly access;Contradicts;0.9443918466567993
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7551764249801636
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5641332268714905
Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5808077454566956
Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6161681413650513
Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.5236291885375977
Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8270419836044312
Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Have no license information of any form;GPL v2 only;Contradicts;0.5273808240890503
Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5877251625061035
Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Kill it and directly access;directly access;Contradicts;0.6545414924621582
Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;"Users of mmap_sem which need it for write should be carefully reviewed to use _killable waiting as much as possible and reduce allocations requests done with the lock held to absolute minimum
";to reduce the risk even further;Contradicts;0.8801484107971191
remove task_t, convert to struct task_struct;cleanup, remove;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5060783624649048
remove task_t, convert to struct task_struct;cleanup, remove;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.7079873085021973
remove task_t, convert to struct task_struct;cleanup, remove;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7449345588684082
cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5405687689781189
cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Have no license information of any form;GPL v2 only;Contradicts;0.6050650477409363
cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.7903576493263245
cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8624908328056335
fixes a few typos;in the comments in mm/oom_kill.c;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5670311450958252
panic is preferable rather than kill some processes;there are environments where panic is preferable;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6057698130607605
panic is preferable rather than kill some processes;there are environments where panic is preferable;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5830212831497192
panic is preferable rather than kill some processes;there are environments where panic is preferable;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5380865335464478
panic is preferable rather than kill some processes;there are environments where panic is preferable;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Contradicts;0.5840492844581604
panic is preferable rather than kill some processes;there are environments where panic is preferable;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5500314831733704
panic is preferable rather than kill some processes;there are environments where panic is preferable;Remove the unused arguments and update all callers.;unused.;Contradicts;0.6114537119865417
panic is preferable rather than kill some processes;there are environments where panic is preferable;Remove the unused arguments and update all callers.;unused;Contradicts;0.6114537119865417
panic is preferable rather than kill some processes;there are environments where panic is preferable;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7250349521636963
panic is preferable rather than kill some processes;there are environments where panic is preferable;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.839577853679657
panic is preferable rather than kill some processes;there are environments where panic is preferable;Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;Contradicts;0.6260330080986023
panic is preferable rather than kill some processes;there are environments where panic is preferable;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.7475539445877075
panic is preferable rather than kill some processes;there are environments where panic is preferable;fix vm_oom_kill_table[];ifdeffery;Contradicts;0.565211296081543
panic is preferable rather than kill some processes;there are environments where panic is preferable;ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;Contradicts;0.571768581867218
panic is preferable rather than kill some processes;there are environments where panic is preferable;Kill it and directly access;directly access;Contradicts;0.5067582726478577
panic is preferable rather than kill some processes;there are environments where panic is preferable;"This is identical to the global oom killer and is done even before checking for panic_on_oom: a pending SIGKILL here while panic_on_oom is selected is guaranteed to have come from userspace; the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory.";the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory;Contradicts;0.6773255467414856
panic is preferable rather than kill some processes;there are environments where panic is preferable;prevent unnecessary oom kills or kernel panics;unnecessary oom kills or kernel panics;Contradicts;0.5162464380264282
panic is preferable rather than kill some processes;there are environments where panic is preferable;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.5009199976921082
panic is preferable rather than kill some processes;there are environments where panic is preferable;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5892136096954346
panic is preferable rather than kill some processes;there are environments where panic is preferable;"Users of mmap_sem which need it for write should be carefully reviewed to use _killable waiting as much as possible and reduce allocations requests done with the lock held to absolute minimum
";to reduce the risk even further;Contradicts;0.8403056263923645
fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.8000869750976562
fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.605262815952301
fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5087162852287292
fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;Have no license information of any form;GPL v2 only;Contradicts;0.7400048971176147
fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.6497576832771301
fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6122633814811707
fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6792756915092468
fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.6722546219825745
fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5714259743690491
fix mm_struct reference counting bugs in mm/oom_kill.c;reference counting bugs;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8450508117675781
Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.5147132873535156
Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.586137056350708
Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;Fix it up via task_lock();instead;Contradicts;0.5430020093917847
Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5023162961006165
Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;Have no license information of any form;GPL v2 only;Contradicts;0.6251468658447266
Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5236912369728088
Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;fix vm_oom_kill_table[];ifdeffery;Contradicts;0.5315428376197815
Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.7271890044212341
Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;Kill it and directly access;directly access;Contradicts;0.5623658895492554
Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7707687616348267
Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6869246959686279
Fix oom_kill_task() so it doesnt call mmput();holding tasklist_lock;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5292867422103882
mm locking fix;oom-kill;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5695281624794006
Patches 3 and 4 should go in ditto;trivial printk -> pr_info conversion;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5295060873031616
Give the oom victim access to the memory reserves;That shouldnt be necessary;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6201165914535522
Give the oom victim access to the memory reserves;That shouldnt be necessary;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.6471394300460815
Give the oom victim access to the memory reserves;That shouldnt be necessary;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Contradicts;0.8651572465896606
Give the oom victim access to the memory reserves;That shouldnt be necessary;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5473694801330566
Give the oom victim access to the memory reserves;That shouldnt be necessary;This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;Contradicts;0.9408663511276245
checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.6166080832481384
checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.7715407609939575
checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6175445914268494
checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5525345206260681
checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5121503472328186
checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5275275707244873
checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.531722366809845
checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6114903688430786
checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Contradicts;0.5354483723640442
checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.9345135688781738
checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6624926924705505
checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;Kill it and directly access;directly access;Contradicts;0.6180397272109985
checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6923937201499939
checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.7361370921134949
Setting the flag for current is not necessary;check and set is not racy;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.7714449167251587
Setting the flag for current is not necessary;check and set is not racy;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.5324423909187317
Setting the flag for current is not necessary;check and set is not racy;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.5497590899467468
Setting the flag for current is not necessary;check and set is not racy;This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;Contradicts;0.742797315120697
Setting the flag for current is not necessary;check and set is not racy;Provide more precise dump info while memcg oom happening;more precise dump info;Contradicts;0.5156064033508301
Setting the flag for current is not necessary;check and set is not racy;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5719289183616638
Setting the flag for current is not necessary;check and set is not racy;renaming;doesnt bring any functional change;Contradicts;0.5516674518585205
Setting the flag for current is not necessary;check and set is not racy;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6104786396026611
Setting the flag for current is not necessary;check and set is not racy;Introduce a struct zoneref to store a zone pointer and a zone index;Store a zone pointer and a zone index;Contradicts;0.5237554311752319
Setting the flag for current is not necessary;check and set is not racy;ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;Contradicts;0.520789384841919
Setting the flag for current is not necessary;check and set is not racy;skip zombies when iterating tasklist;oom;Contradicts;0.507963240146637
Setting the flag for current is not necessary;check and set is not racy;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5083103775978088
It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.6743791699409485
It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5811747908592224
kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7323431968688965
kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.6063095927238464
kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5254589319229126
kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.8148778080940247
kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5381908416748047
kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.9321715235710144
kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5058798789978027
kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.8853147625923157
kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5183458924293518
Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Contradicts;0.6048888564109802
Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8447339534759521
Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5350149273872375
Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5784616470336914
Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5876880288124084
Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.501032829284668
Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.7452084422111511
Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5327642560005188
Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.78321772813797
Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.53861403465271
Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6106684803962708
Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Kill it and directly access;directly access;Contradicts;0.5160773396492004
Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.9257122278213501
check all threads which could share the same ->mm;to make it more or less correct;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6288939118385315
check all threads which could share the same ->mm;to make it more or less correct;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.9057413935661316
check all threads which could share the same ->mm;to make it more or less correct;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5073435306549072
check all threads which could share the same ->mm;to make it more or less correct;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6908567547798157
check all threads which could share the same ->mm;to make it more or less correct;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5122438073158264
check all threads which could share the same ->mm;to make it more or less correct;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8906056880950928
fatal_signal_pending() can be true;because of SIGNAL_GROUP_COREDUMP so out_of_memory() and mem_cgroup_out_of_memory() shouldnt blindly trust it;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.6837698221206665
fatal_signal_pending() can be true;because of SIGNAL_GROUP_COREDUMP so out_of_memory() and mem_cgroup_out_of_memory() shouldnt blindly trust it;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5867528915405273
fatal_signal_pending() can be true;because of SIGNAL_GROUP_COREDUMP so out_of_memory() and mem_cgroup_out_of_memory() shouldnt blindly trust it;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5055028200149536
Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.7713767290115356
Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.5519346594810486
Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7433024048805237
Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;Have no license information of any form;GPL v2 only;Contradicts;0.699467658996582
Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7204397320747375
Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5031778216362
Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.622855544090271
Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;Contradicts;0.6180773973464966
Rename the leftover helper to mem_cgroup_is_descendant() to match cgroup_is_descendant();To make the API change clear;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.6355665922164917
simplify the API back to the single check;to simplify the API back;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5925992727279663
simplify the API back to the single check;to simplify the API back;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7573206424713135
OOM killed task shouldnt escape PM suspend;OOM;Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;Contradicts;0.6332420706748962
OOM killed task shouldnt escape PM suspend;OOM;I added some more output;Users tend to be irritated by the choice of killed processes;Contradicts;0.5990748405456543
OOM killed task shouldnt escape PM suspend;OOM;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.5277824401855469
OOM killed task shouldnt escape PM suspend;OOM;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.7422463893890381
OOM killed task shouldnt escape PM suspend;OOM;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;Contradicts;0.7801758646965027
OOM killed task shouldnt escape PM suspend;OOM;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5794808864593506
Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.8637358546257019
Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5243837833404541
Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6531530618667603
Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6079166531562805
Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;improve that even further;there is a common pattern to do a range lookup first and then do something about that;Contradicts;0.5994060635566711
Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;make OOM detection in the freezer path raceless;raceless;Contradicts;0.5427003502845764
Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7080536484718323
Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Reduce the ballast;Doesnt provide any relevant information;Contradicts;0.6019519567489624
Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.6270395517349243
Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.6374988555908203
Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Kill it and directly access;directly access;Contradicts;0.6742771863937378
Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7104372382164001
Reduce the race window by checking all tasks after OOM killer has been disabled;checking all tasks after OOM killer has been disabled;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7576218843460083
Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5206043720245361
Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.5034977197647095
Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;no longer get stuck on any lock;a sleeping task may hold;Contradicts;0.5084598064422607
Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8150544166564941
Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.638578474521637
Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.8495392799377441
Full synchronization of OOM and freezer is too heavy weight;for this highly unlikely case;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5980979204177856
The counter is updated so early to reduce the race window;to reduce the race window;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.5108579397201538
The counter is updated so early to reduce the race window;to reduce the race window;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5950416326522827
The counter is updated so early to reduce the race window;to reduce the race window;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5790839791297913
The counter is updated so early to reduce the race window;to reduce the race window;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5249963402748108
push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.5525299310684204
push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7675958871841431
push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.6351165771484375
push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6040092706680298
push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5577185153961182
push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;Contradicts;0.5522034764289856
push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.961441159248352
push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8948301672935486
push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;make the oom_reaper thread freezable;In order to close this race;Contradicts;0.5862768888473511
remove unnecessary exit_state check;unnecessary;Add the necessary rcu_read_lock();necessary;Contradicts;0.5106279850006104
remove unnecessary exit_state check;unnecessary;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.7580173015594482
remove unnecessary exit_state check;unnecessary;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6014225482940674
Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Contradicts;0.6773898601531982
Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5188030004501343
Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.801693856716156
Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6711064577102661
Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.505500853061676
Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5892608165740967
Clear TIF_MEMDIE after exit_mm()s mmput();so that an oom killed process is no longer considered for oom kill, but only until exit_mm() has returned;Kill it and directly access;directly access;Contradicts;0.5872620940208435
Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.5799390077590942
Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5440680980682373
Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.6245113611221313
Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7251679301261902
Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Have no license information of any form;GPL v2 only;Contradicts;0.6758503913879395
Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7471275925636292
Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;fix vm_oom_kill_table[];ifdeffery;Contradicts;0.5062434673309326
Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.5098912119865417
Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.560656726360321
Rename try_set_zonelist_oom() to oom_zonelist_trylock() and rename clear_zonelist_oom() to oom_zonelist_unlock();to imply there is proper locking semantics;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7472575306892395
Convert oom_zonelist_trylock() to return bool instead of int;Only success and failure are tested;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.6023077964782715
Convert oom_zonelist_trylock() to return bool instead of int;Only success and failure are tested;Have no license information of any form;GPL v2 only;Contradicts;0.6417443156242371
Convert oom_zonelist_trylock() to return bool instead of int;Only success and failure are tested;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7458382844924927
Convert oom_zonelist_trylock() to return bool instead of int;Only success and failure are tested;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.515985369682312
Convert oom_zonelist_trylock() to return bool instead of int;Only success and failure are tested;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6056395769119263
Fix it up via task_lock();instead;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6081147789955139
Fix it up via task_lock();instead;Kill it and directly access;directly access;Contradicts;0.5060932040214539
out_of_memory() locking fix;locking fix;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6397291421890259
out_of_memory() locking fix;locking fix;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5400663614273071
Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Have no license information of any form;GPL v2 only;Contradicts;0.5076168775558472
Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5618059635162354
Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.5554885268211365
Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5624971985816956
signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.589367687702179
signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6043281555175781
signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Change __task_will_free_mem to test signal->core_state instead of the flag SIGNAL_GROUP_COREDUMP;In preparation for removing the flag SIGNAL_GROUP_COREDUMP;Contradicts;0.5165998935699463
signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Kill it and directly access;directly access;Contradicts;0.7307273745536804
signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6668172478675842
signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.7922723293304443
The solution is similar to what we do when running out of hugepages;similar to what we do when running out of hugepages;This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Contradicts;0.5741819739341736
The solution is similar to what we do when running out of hugepages;similar to what we do when running out of hugepages;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7697442770004272
The solution is similar to what we do when running out of hugepages;similar to what we do when running out of hugepages;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.5663871765136719
The solution is similar to what we do when running out of hugepages;similar to what we do when running out of hugepages;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5711546540260315
reconstruct a list of nodes;performance considerations do not matter much;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6143436431884766
kill the current process;this is a constrained allocation and we should (kill the current process);I added some more output;Users tend to be irritated by the choice of killed processes;Contradicts;0.6971049308776855
kill the current process;this is a constrained allocation and we should (kill the current process);Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7456372976303101
kill the current process;this is a constrained allocation and we should (kill the current process);its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.6742164492607117
account the memory consumption of the (direct) children to the father;we do want to;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.6482958197593689
account the memory consumption of the (direct) children to the father;we do want to;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5871486663818359
account the memory consumption of the (direct) children to the father;we do want to;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5582386255264282
account the memory consumption of the (direct) children to the father;we do want to;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5834285020828247
This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;Contradicts;0.8657600283622742
This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7396525740623474
This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.5612038969993591
This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5065333247184753
This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5006803274154663
This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;Contradicts;0.5541977882385254
This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;This patch fixes the problem and should be backported into stable/LTS.;Fixes the problem, should be backported into stable/LTS.;Contradicts;0.5701194405555725
This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5676083564758301
This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5713101625442505
This maintains the property that fathers with too many children will still very likely be picked;whereas a single misbehaving child has the chance to be picked by the OOM killer;This patch fixes the issue by introducing a new MMF_OOM_KILLED mm flag which is set in oom_kill_process atomically and oom reaper is disabled if the flag was already set.;Fixes the issue by introducing a new MMF_OOM_KILLED mm flag and disabling the oom reaper if the flag was already set.;Contradicts;0.5678927898406982
If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;Stick to accounting for half;Significant improvement;Contradicts;0.5311281681060791
If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8458179831504822
If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5334742665290833
If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6182491779327393
If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7631000280380249
If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.7445845007896423
If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;Contradicts;0.5729683041572571
If one child eats more mem than the rest of the family, it will be picked;Otherwise its still the father and thus the whole family that gets selected;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.630638837814331
accounting for a fourth would be better than for half of it;we could debate;Stick to accounting for half;Significant improvement;Contradicts;0.9914054870605469
accounting for a fourth would be better than for half of it;we could debate;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7983367443084717
accounting for a fourth would be better than for half of it;we could debate;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5113550424575806
accounting for a fourth would be better than for half of it;we could debate;Kill it and directly access;directly access;Contradicts;0.6104653477668762
accounting for a fourth would be better than for half of it;we could debate;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6733935475349426
Stick to accounting for half;Significant improvement;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.7277951836585999
I added some more output;Users tend to be irritated by the choice of killed processes;remove the prototype for the old function;the prototype still existed;Contradicts;0.6422294974327087
I added some more output;Users tend to be irritated by the choice of killed processes;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5063566565513611
Only account for half of childrens vm size in oom score calculation;This should still give the parent enough point in case of fork bombs;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5890641212463379
Only account for half of childrens vm size in oom score calculation;This should still give the parent enough point in case of fork bombs;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.5024842619895935
Only account for half of childrens vm size in oom score calculation;This should still give the parent enough point in case of fork bombs;Have no license information of any form;GPL v2 only;Contradicts;0.7029095888137817
Only account for half of childrens vm size in oom score calculation;This should still give the parent enough point in case of fork bombs;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.7131689190864563
Only account for half of childrens vm size in oom score calculation;This should still give the parent enough point in case of fork bombs;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5895708203315735
Only account for half of childrens vm size in oom score calculation;This should still give the parent enough point in case of fork bombs;Kill it and directly access;directly access;Contradicts;0.5376302599906921
Only account for half of childrens vm size in oom score calculation;This should still give the parent enough point in case of fork bombs;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6053045988082886
move the cpuset semaphore region outside the tasklist_lock region;The fix seems easy enough;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5059950351715088
move the cpuset semaphore region outside the tasklist_lock region;The fix seems easy enough;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5415655970573425
move the cpuset semaphore region outside the tasklist_lock region;The fix seems easy enough;Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;Contradicts;0.6721149682998657
move the cpuset semaphore region outside the tasklist_lock region;The fix seems easy enough;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5754902362823486
move the cpuset semaphore region outside the tasklist_lock region;The fix seems easy enough;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8235582113265991
The locking needs to be changed;The oom code where the locking needs to be changed does not have access to the cpuset locks, which are internal to kernel/cpuset.c only;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.5837277770042419
The locking needs to be changed;The oom code where the locking needs to be changed does not have access to the cpuset locks, which are internal to kernel/cpuset.c only;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.6335334181785583
The locking needs to be changed;The oom code where the locking needs to be changed does not have access to the cpuset locks, which are internal to kernel/cpuset.c only;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.6458547115325928
Provide a couple more cpuset interface routines, available to the rest of the kernel;Take and drop the lock needed here (cpusets callback_sem);use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.5973823070526123
Provide a couple more cpuset interface routines, available to the rest of the kernel;Take and drop the lock needed here (cpusets callback_sem);Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5936080813407898
Provide a couple more cpuset interface routines, available to the rest of the kernel;Take and drop the lock needed here (cpusets callback_sem);We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6317731142044067
Provide a couple more cpuset interface routines, available to the rest of the kernel;Take and drop the lock needed here (cpusets callback_sem);The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8421618342399597
Provide a couple more cpuset interface routines, available to the rest of the kernel;Take and drop the lock needed here (cpusets callback_sem);Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5464449524879456
Theres no need to call schedule_timeout_interruptible();task must die ASAP;oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Contradicts;0.5604125261306763
Theres no need to call schedule_timeout_interruptible();task must die ASAP;Add the necessary rcu_read_lock();necessary;Contradicts;0.6643128395080566
Theres no need to call schedule_timeout_interruptible();task must die ASAP;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.7305505871772766
Theres no need to call schedule_timeout_interruptible();task must die ASAP;Have no license information of any form;GPL v2 only;Contradicts;0.5215539932250977
Theres no need to call schedule_timeout_interruptible();task must die ASAP;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.6246518492698669
Theres no need to call schedule_timeout_interruptible();task must die ASAP;introduce a dedicated system call to cover this use case;to cover this use case;Contradicts;0.7159638404846191
Theres no need to call schedule_timeout_interruptible();task must die ASAP;Kill it and directly access;directly access;Contradicts;0.7988343238830566
Theres no need to call schedule_timeout_interruptible();task must die ASAP;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5502303242683411
replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;Have no license information of any form;GPL v2 only;Contradicts;0.892270028591156
replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5704082250595093
replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.620158314704895
replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7308333516120911
replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;cap_safe_nice() only ever saw current, so now uses capable();only ever saw current, capable();Contradicts;0.5097276568412781
replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8118535876274109
replaced __nocast uses for gfp flags with gfp_t;it gives exactly the same warnings as far as sparse is concerned, doesnt change generated code (from gcc point of view we replaced unsigned int with typedef) and documents whats going on far better.;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5215226411819458
fix-up schedule_timeout() usage;fix-up;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.5513904690742493
fix-up schedule_timeout() usage;fix-up;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5247470736503601
fix-up schedule_timeout() usage;fix-up;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5655336976051331
fix-up schedule_timeout() usage;fix-up;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5693501234054565
fix-up schedule_timeout() usage;fix-up;Kill it and directly access;directly access;Contradicts;0.6201377511024475
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.6698786616325378
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.50553959608078
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6496789455413818
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Have no license information of any form;GPL v2 only;Contradicts;0.9623907804489136
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5119917988777161
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5053324103355408
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6083032488822937
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.5903425216674805
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5382394194602966
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7291343212127686
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.5795361399650574
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.6831978559494019
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.8486196994781494
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6432446837425232
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7024502158164978
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6549318432807922
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;Contradicts;0.6496902108192444
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.6968838572502136
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;avoid attempting to kill init sharing same memory;avoid attempting to kill init;Contradicts;0.5748445987701416
By giving root tasks a bonus that is proportional to their actual size;they remain comparable even when relatively small;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.5253317356109619
By giving root tasks a bonus that is proportional to their actual size;they remain comparable even when relatively small;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6060261726379395
The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.8590310215950012
The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.6390157341957092
The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;Have no license information of any form;GPL v2 only;Contradicts;0.7468919157981873
The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5939203500747681
The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.8480185270309448
The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.6707490682601929
The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5493355393409729
The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6396383047103882
The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5070335268974304
The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7288347482681274
The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;The oom killer does not want to defer in this case;there is no guarantee that thread will ever exit without intervention;Contradicts;0.9442152976989746
prefer thread group leaders for display purposes;for display purposes;kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Contradicts;0.8625452518463135
prefer thread group leaders for display purposes;for display purposes;Kill it and directly access;directly access;Contradicts;0.7328338027000427
kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.6414614319801331
kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.9363251328468323
it now iterates threads instead;leads to ambiguity;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7192018628120422
it now iterates threads instead;leads to ambiguity;Kill it and directly access;directly access;Contradicts;0.7263768315315247
it now iterates threads instead;leads to ambiguity;Use a single linked list;Save a word in task_struct;Contradicts;0.5290002226829529
it now iterates threads instead;leads to ambiguity;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.8325568437576294
simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.8661542534828186
simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6778280138969421
simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.554858386516571
simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5364030003547668
simplify a bit one of its callers, oom_kill_process();allows to simplify a bit;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5612802505493164
oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.6685500741004944
oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7689779996871948
oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Have no license information of any form;GPL v2 only;Contradicts;0.7681190371513367
oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.6141361594200134
oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.7467575073242188
oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.7668012380599976
oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5214998722076416
oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.604353666305542
oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.565045177936554
oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;Contradicts;0.7423809766769409
oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.5887146592140198
oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.5531461834907532
oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();LSMs should use the new has_capability_noaudit() interface;The denials will not be recorded;Contradicts;0.6453238129615784
oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.6593360900878906
oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5294775366783142
oom_kill: has_intersects_mems_allowed() needs rcu_read_lock();rcu_read_lock() is needed for has_intersects_mems_allowed();Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5104065537452698
Add the necessary rcu_read_lock();necessary;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.5949037671089172
Add the necessary rcu_read_lock();necessary;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5532113909721375
Add the necessary rcu_read_lock();necessary;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6010932326316833
Add the necessary rcu_read_lock();necessary;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.5682348012924194
Add the necessary rcu_read_lock();necessary;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7521486878395081
"we need ""bool ret"" and ""break""";we can not simply return from the loop;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7928029298782349
"we need ""bool ret"" and ""break""";we can not simply return from the loop;Have no license information of any form;GPL v2 only;Contradicts;0.5091163516044617
"we need ""bool ret"" and ""break""";we can not simply return from the loop;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.623002827167511
"we need ""bool ret"" and ""break""";we can not simply return from the loop;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.9662759900093079
"we need ""bool ret"" and ""break""";we can not simply return from the loop;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.649662971496582
Change oom_kill.c to use for_each_thread();rather than the racy while_each_thread() which can loop forever if we race with exit;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5111644864082336
This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.5920255780220032
This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;Have no license information of any form;GPL v2 only;Contradicts;0.6294586062431335
This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.7065771222114563
This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;This is really unlikely to make any observable difference;some microbenchmarks could benefit from one less branch that needs to be evaluated even though it almost never is true;Contradicts;0.7779878973960876
convert it to atomic_long_t;to avoid races;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5612635016441345
changes the way tasks behave after detecting a memcg OOM;makes sure nobody loops or sleeps with locks held;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.5725010633468628
changes the way tasks behave after detecting a memcg OOM;makes sure nobody loops or sleeps with locks held;initialize it before;should;Contradicts;0.5443657040596008
changes the way tasks behave after detecting a memcg OOM;makes sure nobody loops or sleeps with locks held;Have no license information of any form;GPL v2 only;Contradicts;0.5702774524688721
changes the way tasks behave after detecting a memcg OOM;makes sure nobody loops or sleeps with locks held;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6641212105751038
the OOM victim can not get stuck on locks the looping task may hold;this way;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.7616190910339355
the OOM victim can not get stuck on locks the looping task may hold;this way;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.8129701614379883
the OOM victim can not get stuck on locks the looping task may hold;this way;make OOM detection in the freezer path raceless;raceless;Contradicts;0.6391871571540833
the OOM victim can not get stuck on locks the looping task may hold;this way;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.7231805324554443
the OOM victim can not get stuck on locks the looping task may hold;this way;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.5022029876708984
no longer get stuck on any lock;a sleeping task may hold;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5512015223503113
Provide more precise dump info while memcg oom happening;more precise dump info;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.5852569937705994
Provide more precise dump info while memcg oom happening;more precise dump info;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5833776593208313
Provide more precise dump info while memcg oom happening;more precise dump info;Have no license information of any form;GPL v2 only;Contradicts;0.9643287658691406
Provide more precise dump info while memcg oom happening;more precise dump info;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.7041671872138977
Provide more precise dump info while memcg oom happening;more precise dump info;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5952427983283997
None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5634943842887878
None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;Contradicts;0.6505390405654907
None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6700687408447266
None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;Contradicts;0.5639568567276001
remove redundant sleep in pagefault oom handler;redundant sleep;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.5345351099967957
remove redundant sleep in pagefault oom handler;redundant sleep;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7758209705352783
remove redundant sleep in pagefault oom handler;redundant sleep;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5552211999893188
cleanup pagefault oom handler;mm, oom;initialize it before;should;Contradicts;0.5093863606452942
use N_MEMORY instead;handle with the nodes which have memory,;Have no license information of any form;GPL v2 only;Contradicts;0.773921012878418
use N_MEMORY instead;handle with the nodes which have memory,;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.615772008895874
Remove the unused arguments and update all callers.;unused.;initialize it before;should;Contradicts;0.5761751532554626
Remove the unused arguments and update all callers.;unused.;Have no license information of any form;GPL v2 only;Contradicts;0.5670273900032043
Remove the unused arguments and update all callers.;unused.;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.6624510884284973
Remove the unused arguments and update all callers.;unused.;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.8236684799194336
Remove the unused arguments and update all callers.;unused.;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.6622216105461121
Remove the unused arguments and update all callers.;unused.;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6639673709869385
Remove the unused arguments and update all callers.;unused.;Kill it and directly access;directly access;Contradicts;0.8214089870452881
Remove the unused arguments and update all callers.;unused.;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.7269022464752197
Remove the unused arguments and update all callers.;unused.;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.8144640922546387
Remove unused start/end arguments from tlb_finish_mmu();unused;Have no license information of any form;GPL v2 only;Contradicts;0.6914559006690979
Remove unused start/end arguments from tlb_finish_mmu();unused;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.5275495648384094
Remove unused start/end arguments from tlb_finish_mmu();unused;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6565945744514465
Remove unused start/end arguments from tlb_finish_mmu();unused;Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.6237158179283142
Remove unused start/end arguments from tlb_finish_mmu();unused;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6912755370140076
Remove the unused arguments and update all callers.;unused;initialize it before;should;Contradicts;0.5761751532554626
Remove the unused arguments and update all callers.;unused;Have no license information of any form;GPL v2 only;Contradicts;0.5670273900032043
Remove the unused arguments and update all callers.;unused;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.6624510884284973
Remove the unused arguments and update all callers.;unused;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.8236684799194336
Remove the unused arguments and update all callers.;unused;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.6622216105461121
Remove the unused arguments and update all callers.;unused;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6639673709869385
Remove the unused arguments and update all callers.;unused;Kill it and directly access;directly access;Contradicts;0.8214089870452881
Remove the unused arguments and update all callers.;unused;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.7269022464752197
Remove the unused arguments and update all callers.;unused;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.8144640922546387
Show some helpful information;to indicate why this happens;Have no license information of any form;GPL v2 only;Contradicts;0.5998902320861816
Show some helpful information;to indicate why this happens;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.7313597202301025
Show some helpful information;to indicate why this happens;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7354815006256104
make the calculation of oom badness more accurate;more accurate;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5256893634796143
give the functions a kthread_ prefix;to better document the use case;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5807777047157288
give the functions a kthread_ prefix;to better document the use case;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5295483469963074
integrate them and add some comment to struct alloc_context;reduce future confusion about the meaning of this variable;delete the corresponding comment;it will be checked in oom_unkillable_task();Contradicts;0.7278497815132141
integrate them and add some comment to struct alloc_context;reduce future confusion about the meaning of this variable;Kill it and directly access;directly access;Contradicts;0.6173585653305054
integrate them and add some comment to struct alloc_context;reduce future confusion about the meaning of this variable;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.868998110294342
integrate them and add some comment to struct alloc_context;reduce future confusion about the meaning of this variable;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.6059597730636597
The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;initialize it before;should;Contradicts;0.5486068725585938
The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;Have no license information of any form;GPL v2 only;Contradicts;0.5583140850067139
The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.7646331787109375
The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.9037548303604126
The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Contradicts;0.7533637881278992
The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.6538087129592896
The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6012656688690186
The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.5554859638214111
The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;name it appropriately;zone_scan_mutex is actually a spinlock;Contradicts;0.5505275130271912
The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;Remove the parameter @mem;removed since v2.6.26;Contradicts;0.5258193612098694
The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;introduce a dedicated system call to cover this use case;to cover this use case;Contradicts;0.5394524931907654
The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;Kill it and directly access;directly access;Contradicts;0.8973857760429382
The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5681116580963135
The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.7229575514793396
Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Have no license information of any form;GPL v2 only;Contradicts;0.5687980651855469
Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6463018655776978
Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.5501276850700378
Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6138355135917664
dump stack of victim when reaping failed;reaping failed;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5531250238418579
fix pgtables units mismatch in Killed process message;pgtables units mismatch in Killed process message;Have no license information of any form;GPL v2 only;Contradicts;0.6052336692810059
fix pgtables units mismatch in Killed process message;pgtables units mismatch in Killed process message;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.5755288004875183
fix pgtables units mismatch in Killed process message;pgtables units mismatch in Killed process message;skip zombies when iterating tasklist;oom;Contradicts;0.5160834193229675
fix pgtables units mismatch in Killed process message;pgtables units mismatch in Killed process message;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5459012389183044
Introduce two new options for madvise;To achieve the goal;Have no license information of any form;GPL v2 only;Contradicts;0.7560105323791504
Introduce two new options for madvise;To achieve the goal;remove a stale code;quick fixup;Contradicts;0.675845742225647
Introduce two new options for madvise;To achieve the goal;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6441007256507874
Introduce two new options for madvise;To achieve the goal;remove the prototype for the old function;the prototype still existed;Contradicts;0.7445802092552185
Introduce two new options for madvise;To achieve the goal;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6906798481941223
Introduce two new options for madvise;To achieve the goal;Use a single linked list;Save a word in task_struct;Contradicts;0.5408622026443481
"
MADV_PAGEOUT is similar to MADV_DONTNEED 
MADV_COLD is similar to MADV_FREE 
";"
it hints the kernel that memory region is not currently needed and should be reclaimed immediately 
it hints the kernel that memory region is not currently needed and should be reclaimed when memory pressure rises";Have no license information of any form;GPL v2 only;Contradicts;0.8597894310951233
"
MADV_PAGEOUT is similar to MADV_DONTNEED 
MADV_COLD is similar to MADV_FREE 
";"
it hints the kernel that memory region is not currently needed and should be reclaimed immediately 
it hints the kernel that memory region is not currently needed and should be reclaimed when memory pressure rises";There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.6165996789932251
"
MADV_PAGEOUT is similar to MADV_DONTNEED 
MADV_COLD is similar to MADV_FREE 
";"
it hints the kernel that memory region is not currently needed and should be reclaimed immediately 
it hints the kernel that memory region is not currently needed and should be reclaimed when memory pressure rises";Remove the parameter @mem;removed since v2.6.26;Contradicts;0.6225162148475647
"
MADV_PAGEOUT is similar to MADV_DONTNEED 
MADV_COLD is similar to MADV_FREE 
";"
it hints the kernel that memory region is not currently needed and should be reclaimed immediately 
it hints the kernel that memory region is not currently needed and should be reclaimed when memory pressure rises";The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.7728106379508972
"
MADV_PAGEOUT is similar to MADV_DONTNEED 
MADV_COLD is similar to MADV_FREE 
";"
it hints the kernel that memory region is not currently needed and should be reclaimed immediately 
it hints the kernel that memory region is not currently needed and should be reclaimed when memory pressure rises";Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6928316354751587
"
MADV_PAGEOUT is similar to MADV_DONTNEED 
MADV_COLD is similar to MADV_FREE 
";"
it hints the kernel that memory region is not currently needed and should be reclaimed immediately 
it hints the kernel that memory region is not currently needed and should be reclaimed when memory pressure rises";Kill it and directly access;directly access;Contradicts;0.7130507230758667
Add SPDX license identifier for missed files;SPDX license identifier for missed files;Have no license information of any form;GPL v2 only;Contradicts;0.9951748847961426
Add SPDX license identifier for missed files;SPDX license identifier for missed files;The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Contradicts;0.577992856502533
Add SPDX license identifier for missed files;SPDX license identifier for missed files;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Contradicts;0.6399301886558533
Add SPDX license identifier for missed files;SPDX license identifier for missed files;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5668523907661438
Add SPDX license identifier for missed files;SPDX license identifier for missed files;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5636674165725708
Add SPDX license identifier for missed files;SPDX license identifier for missed files;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7573792934417725
Add SPDX license identifier for missed files;SPDX license identifier for missed files;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.528717041015625
Have no license information of any form;GPL v2 only;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.5749443173408508
Have no license information of any form;GPL v2 only;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5143738389015198
Have no license information of any form;GPL v2 only;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.5210867524147034
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.8816021680831909
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.5408903360366821
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.5988070964813232
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.8695103526115417
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7734586596488953
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.5454232096672058
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;Contradicts;0.5038816332817078
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;Remove the parameter @mem;removed since v2.6.26;Contradicts;0.6806040406227112
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;Two of the instances of __capable() actually only act on current, and so have been changed to calls to capable();only act on current;Contradicts;0.5579596161842346
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;cap_safe_nice() only ever saw current, so now uses capable();only ever saw current, capable();Contradicts;0.6382057070732117
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.6399965882301331
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.8123584389686584
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;remove the prototype for the old function;the prototype still existed;Contradicts;0.6468814611434937
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5230274796485901
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5875586867332458
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.9125581979751587
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5197116732597351
The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.5236850380897522
The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.5457996129989624
The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Contradicts;0.51259446144104
The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;LSMs should use the new has_capability_noaudit() interface;The denials will not be recorded;Contradicts;0.7124930620193481
The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5574773550033569
The MMU_NOTIFY_UNMAP is always the safe default;users of mmu notifier should assume that every for the range is going away when that event happens;skip zombies when iterating tasklist;oom;Contradicts;0.5285601019859314
Check if setting global init process to some memory cgroup is technically possible;Possible;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.5038319230079651
Check if setting global init process to some memory cgroup is technically possible;Possible;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.6109524369239807
Check if setting global init process to some memory cgroup is technically possible;Possible;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.8655750155448914
Check if setting global init process to some memory cgroup is technically possible;Possible;Kill it and directly access;directly access;Contradicts;0.5518481731414795
Check if setting global init process to some memory cgroup is technically possible;Possible;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5514537692070007
Get/put across the for_each_thread() on the selected task;The easiest fix is;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.5484209060668945
Get/put across the for_each_thread() on the selected task;The easiest fix is;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5281599164009094
Get/put across the for_each_thread() on the selected task;The easiest fix is;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5241835117340088
Get/put across the for_each_thread() on the selected task;The easiest fix is;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5103231072425842
Fix this bug;"using an approach used by commit 855b018325737f76 (""oom, oom_reaper: disable oom_reaper for oom_kill_allocating_task"")";lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.7597829699516296
Fix this bug;"using an approach used by commit 855b018325737f76 (""oom, oom_reaper: disable oom_reaper for oom_kill_allocating_task"")";Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6627119183540344
We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6338937282562256
We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.8909856081008911
We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.9835196137428284
We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Contradicts;0.5918724536895752
We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;Contradicts;0.5463459491729736
We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.6812155246734619
We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.6421812772750854
We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Remove the parameter @mem;removed since v2.6.26;Contradicts;0.8032146096229553
We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.5665648579597473
We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.8684118390083313
We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.7283949255943298
We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5088934302330017
We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.7264646291732788
We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5838228464126587
We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.6545549631118774
An admin can easily get the full oom context at a single line;makes parsing much easier;fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();Contradicts;0.572418212890625
An admin can easily get the full oom context at a single line;makes parsing much easier;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6337102055549622
An admin can easily get the full oom context at a single line;makes parsing much easier;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.5774319171905518
An admin can easily get the full oom context at a single line;makes parsing much easier;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5405638217926025
An admin can easily get the full oom context at a single line;makes parsing much easier;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.7220926880836487
An admin can easily get the full oom context at a single line;makes parsing much easier;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5753737092018127
fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.6092368364334106
fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.6959314942359924
fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Contradicts;0.5178483128547668
fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.6750118136405945
fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.6810092329978943
fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.540427565574646
fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5775777697563171
fix missing tlb_finish_mmu() in __oom_reap_task_mm();missing tlb_finish_mmu() in __oom_reap_task_mm();Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6834834814071655
Split oom_kill_process();With an intention to re-use the second half;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.8965762853622437
Split oom_kill_process();With an intention to re-use the second half;Use a single linked list;Save a word in task_struct;Contradicts;0.5314440131187439
We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7040598392486572
We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.8687471151351929
We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;"This is identical to the global oom killer and is done even before checking for panic_on_oom: a pending SIGKILL here while panic_on_oom is selected is guaranteed to have come from userspace; the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory.";the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory;Contradicts;0.6136968731880188
We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5035992860794067
We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.7864779233932495
Move trace_finish_task_reaping() inside the locked region;Increases mmap_sem hold time a little;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8067190051078796
Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.661819338798523
Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.7743232250213623
Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.735478401184082
Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.6155425906181335
Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5832074284553528
Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.8604175448417664
Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.7267062664031982
Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;delete the corresponding comment;it will be checked in oom_unkillable_task();Contradicts;0.8771485090255737
Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;remove the prototype for the old function;the prototype still existed;Contradicts;0.5039423108100891
Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;Kill it and directly access;directly access;Contradicts;0.889455258846283
Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.6570083498954773
Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8891100883483887
Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;This patch fixes the issue by introducing a new MMF_OOM_KILLED mm flag which is set in oom_kill_process atomically and oom reaper is disabled if the flag was already set.;Fixes the issue by introducing a new MMF_OOM_KILLED mm flag and disabling the oom reaper if the flag was already set.;Contradicts;0.5890201926231384
Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;Contradicts;0.5009163618087769
Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.9569292068481445
Add a small printk prior to the task dump informing;that the memory units are actually memory _pages_;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6181504130363464
Add a small printk prior to the task dump informing;that the memory units are actually memory _pages_;Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.6082457304000854
Add a small printk prior to the task dump informing;that the memory units are actually memory _pages_;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6437039375305176
Add a small printk prior to the task dump informing;that the memory units are actually memory _pages_;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8392606377601624
Add a small printk prior to the task dump informing;that the memory units are actually memory _pages_;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5648545026779175
lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.7001520991325378
lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;make OOM detection in the freezer path raceless;raceless;Contradicts;0.5169991254806519
lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5053622722625732
lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5826014280319214
lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.530213475227356
lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Kill it and directly access;directly access;Contradicts;0.7062819004058838
lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7483444809913635
lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.513756513595581
lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;The oom killer does not want to defer in this case;there is no guarantee that thread will ever exit without intervention;Contradicts;0.5907673239707947
lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7283833026885986
lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.5736138224601746
lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.7788926362991333
Add comments describing oom_locks scope;describing oom_locks scope;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5503079295158386
Add comments describing oom_locks scope;describing oom_locks scope;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7764147520065308
Add comments describing oom_locks scope;describing oom_locks scope;Inform about the successful/failed oom_reaper attempts and dump all the held locks;to tell us more who is blocking the progress;Contradicts;0.5577956438064575
Rename page_counter_limit() to page_counter_set_max();The idea behind this renaming is to have the direct matching between memory cgroup knobs (low, high, max) and page_counters API;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.644758403301239
Rename page_counter_limit() to page_counter_set_max();The idea behind this renaming is to have the direct matching between memory cgroup knobs (low, high, max) and page_counters API;Kill it and directly access;directly access;Contradicts;0.5967257022857666
Rename page_counter_limit() to page_counter_set_max();The idea behind this renaming is to have the direct matching between memory cgroup knobs (low, high, max) and page_counters API;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6444911360740662
The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.6104104518890381
The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;Contradicts;0.8196431398391724
There is no clear decision in this sentence.;There is no clear rationale in this sentence.;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.531347930431366
There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Kill it and directly access;directly access;Contradicts;0.7621163129806519
There is no clear decision in this sentence.;There is no clear rationale in this sentence.;A kernel thread has been chosen;we need a reliable way of invocation so workqueue context is not appropriate because all the workers might be busy;Contradicts;0.6051508784294128
There is no clear decision in this sentence.;There is no clear rationale in this sentence.;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;Contradicts;0.5084049105644226
Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.6175389289855957
Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5823331475257874
Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.542204737663269
Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;Contradicts;0.6131740212440491
Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5073438286781311
Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Kill it and directly access;directly access;Contradicts;0.6365644335746765
Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5318734049797058
Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;Add a missing newline;missing;Contradicts;0.5690721869468689
Remove the CAP_SYS_ADMIN bias;so that all processes are treated equally;adds MM_SHMEMPAGES counter to mm_rss_stat;to account for shmem pages separately from MM_FILEPAGES;Contradicts;0.5027051568031311
It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.613804280757904
It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6308150291442871
It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.509364664554596
remove unnecessary locking in oom_enable();unnecessary locking in oom_enable();We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.5815238356590271
remove unnecessary locking in oom_enable();unnecessary locking in oom_enable();The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6806057691574097
remove unnecessary locking in oom_enable();unnecessary locking in oom_enable();Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.6368354558944702
fix typo in comment;typo in comment;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5355424880981445
The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.6170759797096252
The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.5667733550071716
The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7065311670303345
The patch addresses the issue by account PMD tables to the process the same way we account PTE;addresses the issue by account PMD tables to the process the same way we account PTE;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8355444669723511
make OOM detection in the freezer path raceless;raceless;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5175477862358093
oom_killer_disabled check is moved from the allocation path to the OOM level;to take oom_sem for reading for both the check and the whole OOM invocation;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.7305984497070312
oom_killer_disabled check is moved from the allocation path to the OOM level;to take oom_sem for reading for both the check and the whole OOM invocation;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5170135498046875
oom_killer_disabled check is moved from the allocation path to the OOM level;to take oom_sem for reading for both the check and the whole OOM invocation;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.743354320526123
oom_killer_disabled check is moved from the allocation path to the OOM level;to take oom_sem for reading for both the check and the whole OOM invocation;skip zombies when iterating tasklist;oom;Contradicts;0.5583233833312988
it would be better and more robust to not rely on freezing points here;We used to have freezing points deep in file system code which may be reachable from page fault;oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Contradicts;0.6048622131347656
it would be better and more robust to not rely on freezing points here;We used to have freezing points deep in file system code which may be reachable from page fault;"This is identical to the global oom killer and is done even before checking for panic_on_oom: a pending SIGKILL here while panic_on_oom is selected is guaranteed to have come from userspace; the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory.";the thread only needs access to memory reserves to exit and thus we dont unnecessarily panic the machine until the kernel has no last resort to free memory;Contradicts;0.539008617401123
it would be better and more robust to not rely on freezing points here;We used to have freezing points deep in file system code which may be reachable from page fault;make the oom_reaper thread freezable;In order to close this race;Contradicts;0.5258660316467285
We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Kill it and directly access;directly access;Contradicts;0.5320193767547607
oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.5090171098709106
oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;detect threads that are in the exit path, specifically those with PF_EXITING set;to prevent needlessly killing additional tasks;Contradicts;0.5172286629676819
oom_scan_process_thread doesnt need to care about freezer anymore;TIF_MEMDIE and freezer are excluded completely now;make the oom_reaper thread freezable;In order to close this race;Contradicts;0.7264402508735657
This patchset addresses a race;"which was described in the changelog for 5695be142e20 (""OOM, PM: OOM killed task shouldnt escape PM suspend"")";Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8475484251976013
mark_tsk_oom_victim is now called under task_lock;I think this should be OK because __thaw_task shouldnt interfere with any locking down wake_up_process;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5578623414039612
mark_tsk_oom_victim is now called under task_lock;I think this should be OK because __thaw_task shouldnt interfere with any locking down wake_up_process;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6507502198219299
reduce noise in show_mem for lowmem allocations;lowmem allocations;Reduce the ballast;Doesnt provide any relevant information;Contradicts;0.5881208777427673
reduce noise in show_mem for lowmem allocations;lowmem allocations;The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Contradicts;0.5040105581283569
reduce noise in show_mem for lowmem allocations;lowmem allocations;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5545421242713928
reduce noise in show_mem for lowmem allocations;lowmem allocations;Kill it and directly access;directly access;Contradicts;0.7567334771156311
reduce noise in show_mem for lowmem allocations;lowmem allocations;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5043671727180481
the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.7505906820297241
the oom reaper invocation can be dropped;Munlock code is no longer a problem and there shouldnt be any blocking operation before the memory is unmapped by exit_mmap;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.7574585676193237
Remove the oom_reaper from exit_mmap;make the code easier to read;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.8016742467880249
Remove the oom_reaper from exit_mmap;make the code easier to read;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5204801559448242
Remove the oom_reaper from exit_mmap;make the code easier to read;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7200504541397095
Remove the oom_reaper from exit_mmap;make the code easier to read;This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;Contradicts;0.6191675066947937
fix vm_oom_kill_table[];ifdeffery;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5977173447608948
removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;Kill it and directly access;directly access;Contradicts;0.5168602466583252
update locked_vm accounting according to the munmapped vmas when munmapping;There is still a need to perform this action;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6773815751075745
Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5660907030105591
The change prevents process_mrelease from calling;which can lead to waiting for IO completion in exit_aio.;Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;Contradicts;0.6952609419822693
Our container agent wants to know when a container exits if it was OOM killed or not;to report to the user;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5577144622802734
OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Contradicts;0.5579057335853577
OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.799543559551239
OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5473006367683411
OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.8739319443702698
OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;remove the prototype for the old function;the prototype still existed;Contradicts;0.5705015063285828
OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;Kill it and directly access;directly access;Contradicts;0.9405930638313293
OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.7611726522445679
OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.6814369559288025
OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;make the oom_reaper thread freezable;In order to close this race;Contradicts;0.6438871026039124
OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;Use a single linked list;Save a word in task_struct;Contradicts;0.8309371471405029
OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;Contradicts;0.6190518140792847
OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.6222272515296936
OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;adds MM_SHMEMPAGES counter to mm_rss_stat;to account for shmem pages separately from MM_FILEPAGES;Contradicts;0.7788538336753845
This patch adds a new oom_group_kill event;to allow userspace to cleanly identify when an entire cgroup is oom killed.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8136938810348511
Change __task_will_free_mem to test signal->core_state instead of the flag SIGNAL_GROUP_COREDUMP;In preparation for removing the flag SIGNAL_GROUP_COREDUMP;its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Contradicts;0.522804319858551
Change __task_will_free_mem to test signal->core_state instead of the flag SIGNAL_GROUP_COREDUMP;In preparation for removing the flag SIGNAL_GROUP_COREDUMP;Add a new flag PF_POSTCOREDUMP;so that tasks that have passed through coredump_task_exit can be recognized and ignored in zap_process;Contradicts;0.7347159385681152
Change __task_will_free_mem to test signal->core_state instead of the flag SIGNAL_GROUP_COREDUMP;In preparation for removing the flag SIGNAL_GROUP_COREDUMP;Kill it and directly access;directly access;Contradicts;0.7638440132141113
Change __task_will_free_mem to test signal->core_state instead of the flag SIGNAL_GROUP_COREDUMP;In preparation for removing the flag SIGNAL_GROUP_COREDUMP;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5045075416564941
Change __task_will_free_mem to test signal->core_state instead of the flag SIGNAL_GROUP_COREDUMP;In preparation for removing the flag SIGNAL_GROUP_COREDUMP;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8822046518325806
Change __task_will_free_mem to test signal->core_state instead of the flag SIGNAL_GROUP_COREDUMP;In preparation for removing the flag SIGNAL_GROUP_COREDUMP;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.838217556476593
Adding a set_freezable() call;will clear the PF_NOFREEZE flag and thus make the OOM reaper visible to the freezer;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6600924730300903
Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5697078108787537
Drop triggering out_of_memory from pagefault_out_of_memory;There is no legitimate reason ;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7468487620353699
This patch fixes the problem and should be backported into stable/LTS.;Fixes the problem, should be backported into stable/LTS.;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.5957701802253723
This patch fixes the problem and should be backported into stable/LTS.;Fixes the problem, should be backported into stable/LTS.;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.7741624712944031
Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.5747790336608887
Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;Kill it and directly access;directly access;Contradicts;0.7766308188438416
Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.9390047192573547
Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;skip zombies when iterating tasklist;oom;Contradicts;0.5057668089866638
Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8417239189147949
Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5830438137054443
This fix has considerable negative impact on process_mrelease performance;will likely need later optimization;Kill it and directly access;directly access;Contradicts;0.5068621039390564
Print the tasks cpuset name for informational purposes;for informational purposes;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.7662755250930786
Print the tasks cpuset name for informational purposes;for informational purposes;Kill it and directly access;directly access;Contradicts;0.9422451853752136
Print the tasks cpuset name for informational purposes;for informational purposes;skip zombies when iterating tasklist;oom;Contradicts;0.5289375185966492
its silly to unconditionally kill the faulting process at page fault time;With increasingly sophisticated oom behaviour;Kill it and directly access;directly access;Contradicts;0.8089017271995544
LSMs should use the new has_capability_noaudit() interface;The denials will not be recorded;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5242573022842407
LSMs should use the new has_capability_noaudit() interface;The denials will not be recorded;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.6779041886329651
dump task state information for thread group leaders;When /proc/sys/vm/oom_dump_tasks is enabled, its only necessary;skip zombies when iterating tasklist;oom;Contradicts;0.5966613292694092
dump task state information for thread group leaders;When /proc/sys/vm/oom_dump_tasks is enabled, its only necessary;considered a reasonable constrain;the overall system health is more important than debugability of a particular application;Contradicts;0.7755119204521179
Two of the instances of __capable() actually only act on current, and so have been changed to calls to capable();only act on current;cap_safe_nice() only ever saw current, so now uses capable();only ever saw current, capable();Contradicts;0.60219806432724
Two of the instances of __capable() actually only act on current, and so have been changed to calls to capable();only act on current;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.5143002867698669
The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6129467487335205
The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();A kernel thread has been chosen;we need a reliable way of invocation so workqueue context is not appropriate because all the workers might be busy;Contradicts;0.504116952419281
The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.7144358158111572
allow privileged processes to receive SIGIO on files theyre manipulating;privileged processes;Kill it and directly access;directly access;Contradicts;0.6562844514846802
allow privileged processes to receive SIGIO on files theyre manipulating;privileged processes;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5722489356994629
Introduce a struct zoneref to store a zone pointer and a zone index;Store a zone pointer and a zone index;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7923154830932617
Introduce a struct zoneref to store a zone pointer and a zone index;Store a zone pointer and a zone index;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.6202539801597595
fallback allocations when the target/preferred node has no free pages;target/preferred node has no free pages;Kill it and directly access;directly access;Contradicts;0.9018872976303101
fallback allocations when the target/preferred node has no free pages;target/preferred node has no free pages;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.6013736128807068
use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.586496114730835
use the newly added pidfd_get_task() helper;Instead of duplicating the same code in two places;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.6234500408172607
This fixes an unimportant bug where PIDTYPE_PID is used whereas PIDTYPE_TGID should have been used.;unimportant;Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;Contradicts;0.6542985439300537
This fixes an unimportant bug where PIDTYPE_PID is used whereas PIDTYPE_TGID should have been used.;unimportant;Kill it and directly access;directly access;Contradicts;0.8308591246604919
This fixes an unimportant bug where PIDTYPE_PID is used whereas PIDTYPE_TGID should have been used.;unimportant;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.6891096234321594
This fixes an unimportant bug where PIDTYPE_PID is used whereas PIDTYPE_TGID should have been used.;unimportant;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8414263129234314
This ensures that an accurate copy of the process can be captured in the coredump;no cleanup for the process happens before the coredump completes;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.7529974579811096
This ensures that an accurate copy of the process can be captured in the coredump;no cleanup for the process happens before the coredump completes;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7121864557266235
This ensures that an accurate copy of the process can be captured in the coredump;no cleanup for the process happens before the coredump completes;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5033921003341675
ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;Kill it and directly access;directly access;Contradicts;0.6416562795639038
ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.6490075588226318
ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8604398369789124
ensures that PTRACE_EVENT_EXIT will not be visited by any thread until the coredump is complete;This also;skip zombies when iterating tasklist;oom;Contradicts;0.5165637135505676
Add a new flag PF_POSTCOREDUMP;so that tasks that have passed through coredump_task_exit can be recognized and ignored in zap_process;remove the prototype for the old function;the prototype still existed;Contradicts;0.6295884847640991
Add a new flag PF_POSTCOREDUMP;so that tasks that have passed through coredump_task_exit can be recognized and ignored in zap_process;Kill it and directly access;directly access;Contradicts;0.5272482633590698
Add a new flag PF_POSTCOREDUMP;so that tasks that have passed through coredump_task_exit can be recognized and ignored in zap_process;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7223788499832153
Add a new flag PF_POSTCOREDUMP;so that tasks that have passed through coredump_task_exit can be recognized and ignored in zap_process;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.6316403150558472
"Replace ""may_ptrace_stop()"" with a simple test of ""current->ptrace""";"a simple test of ""current->ptrace"" is more efficient and clear";Kill it and directly access;directly access;Contradicts;0.5746737122535706
"Replace ""may_ptrace_stop()"" with a simple test of ""current->ptrace""";"a simple test of ""current->ptrace"" is more efficient and clear";The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.8193113803863525
This way the memory is freed in a more controllable way with CPU affinity and priority of the caller;more controllable way with CPU affinity and priority of the caller;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.655906081199646
introduce a dedicated system call to cover this use case;to cover this use case;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.7454710006713867
introduce a dedicated system call to cover this use case;to cover this use case;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5580883622169495
Rename the function to make that purpose explicit;The oom proper is the only existing user;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.6152234673500061
Drop the MPOL_INTERLEAVE;Those allocations never have a nodemask defined (see alloc_page_interleave), so this is a dead code and a confusing one because MPOL_INTERLEAVE is a hint rather than a hard requirement, so it shouldnt be considered during the OOM.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5422006249427795
The final code can be reduced to a check for MPOL_BIND;MPOL_BIND is the only memory policy that is a hard requirement and thus relevant to a constrained OOM logic;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5165365934371948
Fix typo in comment: kthead -> kthread;typo;delete the corresponding comment;it will be checked in oom_unkillable_task();Contradicts;0.5880420207977295
Fix typo in comment: kthead -> kthread;typo;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8515148162841797
fix typos in comments;typos in comments;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5079925656318665
Fix ~94 single-word typos in locking code comments, plus a few very obvious grammar mistakes.;Improve code quality and readability.;Kill it and directly access;directly access;Contradicts;0.6804373264312744
Fix ~94 single-word typos in locking code comments, plus a few very obvious grammar mistakes.;Improve code quality and readability.;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.8522428870201111
removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.5036665797233582
The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5048859715461731
Architectures that implement their own show_mem() actually dont do anything with the argument yet, but they could be made to filter nodes that arent allowed in the current context in the future just like the generic implementation.;They could be made to filter nodes that arent allowed in the current context in the future just like the generic implementation.;per-cpu pageset statistics are now suppressed;extremely verbose in oom killer output;Contradicts;0.5700886249542236
Architectures that implement their own show_mem() actually dont do anything with the argument yet, but they could be made to filter nodes that arent allowed in the current context in the future just like the generic implementation.;They could be made to filter nodes that arent allowed in the current context in the future just like the generic implementation.;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.5228818655014038
Architectures that implement their own show_mem() actually dont do anything with the argument yet, but they could be made to filter nodes that arent allowed in the current context in the future just like the generic implementation.;They could be made to filter nodes that arent allowed in the current context in the future just like the generic implementation.;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;Contradicts;0.5927456021308899
Architectures that implement their own show_mem() actually dont do anything with the argument yet, but they could be made to filter nodes that arent allowed in the current context in the future just like the generic implementation.;They could be made to filter nodes that arent allowed in the current context in the future just like the generic implementation.;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.7071848511695862
Find kill other threads that pin the same ->mm or find another task to kill.;Memory needs to be freed.;make the oom_reaper thread freezable;In order to close this race;Contradicts;0.6014081239700317
Find kill other threads that pin the same ->mm or find another task to kill.;Memory needs to be freed.;oom_reaper has to take mmap_sem on the target task for reading;the semaphore might be held or blocked for write but the probability is reduced considerably wrt;Contradicts;0.5770525336265564
Find kill other threads that pin the same ->mm or find another task to kill.;Memory needs to be freed.;avoid attempting to kill init sharing same memory;avoid attempting to kill init;Contradicts;0.7792028188705444
Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.6862335205078125
make the oom_reaper thread freezable;In order to close this race;A kernel thread has been chosen;we need a reliable way of invocation so workqueue context is not appropriate because all the workers might be busy;Contradicts;0.883894681930542
Use a single linked list;Save a word in task_struct;Kswapd which sounds like another good fit is not appropriate as well;it might get blocked on locks during reclaim as well;Contradicts;0.5233929753303528
This patch fixes the issue by introducing a new MMF_OOM_KILLED mm flag which is set in oom_kill_process atomically and oom reaper is disabled if the flag was already set.;Fixes the issue by introducing a new MMF_OOM_KILLED mm flag and disabling the oom reaper if the flag was already set.;This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;Contradicts;0.816350519657135
This patch fixes the issue by introducing a new MMF_OOM_KILLED mm flag which is set in oom_kill_process atomically and oom reaper is disabled if the flag was already set.;Fixes the issue by introducing a new MMF_OOM_KILLED mm flag and disabling the oom reaper if the flag was already set.;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.5249038934707642
This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;Add a missing newline;missing;Contradicts;0.5209917426109314
This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;avoid attempting to kill init sharing same memory;avoid attempting to kill init;Contradicts;0.9294247627258301
"Users of mmap_sem which need it for write should be carefully reviewed to use _killable waiting as much as possible and reduce allocations requests done with the lock held to absolute minimum
";to reduce the risk even further;adds MM_SHMEMPAGES counter to mm_rss_stat;to account for shmem pages separately from MM_FILEPAGES;Contradicts;0.5286574959754944
