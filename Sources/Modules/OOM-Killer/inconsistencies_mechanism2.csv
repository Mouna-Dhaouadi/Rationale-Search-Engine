Decision1;Rationale1;Decision2;Rationale2;Relationship;Alpha;similarity_rationales
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);Contradicts;0.994510531425476;0.3513171672821045
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Contradicts;0.9556928277015686;0.6442734003067017
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;Contradicts;0.9155578017234802;0.533965528011322
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();remove redundant task_in_mem_cgroup() check;redundant;Contradicts;0.917155921459198;0.5130186080932617
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;Contradicts;0.9238361716270448;0.5783705115318298
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.9981389045715332;0.48734551668167114
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Remove the count;Its better to remove the count;Contradicts;0.9986255168914796;0.7172040939331055
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Lets get rid of the signal_struct counter;We do not need it anymore;Contradicts;0.9806713461875916;0.5560683012008667
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.9362782835960388;0.5510857701301575
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;Contradicts;0.9122530221939088;0.5657375454902649
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.9121739268302916;0.5375957489013672
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.9694297909736632;0.7433531284332275
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.9510989189147948;0.44353100657463074
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9982798099517822;0.5074784755706787
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.9411827921867372;0.6612657904624939
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();remove task_t, convert to struct task_struct;cleanup, remove;Contradicts;0.9311471581459044;0.6042991280555725
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.95354425907135;0.6710247993469238
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.9218712449073792;0.501911997795105
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Remove the parameter @mem;removed since v2.6.26;Contradicts;0.9767622351646424;0.5243174433708191
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();Kill it and directly access;directly access;Contradicts;0.972334623336792;0.5001663565635681
"This patch adds a counter to signal_struct for tracking how many TIF_MEMDIE threads are in a given thread group, and check it at oom_scan_process_thread()
";so that select_bad_process() can use for_each_process() rather than for_each_process_thread();The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.9572837948799132;0.5501887202262878
strive for making this context as reliable and independent on other subsystems;as much as possible;Kill it and directly access;directly access;Contradicts;0.9396885633468628;0.7918394207954407
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);Contradicts;0.9966832995414734;0.625108540058136
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;ruling out the OOM killer;lockup machine in most of the cases;Contradicts;0.9638046622276306;0.2073611468076706
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;Contradicts;0.9203083515167236;0.6393542885780334
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Remove this dubious PF_EXITING check;dubious;Contradicts;0.9507530331611632;0.15803541243076324
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.9361679553985596;0.47325125336647034
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;Contradicts;0.9911165237426758;0.4035516381263733
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.9738510847091676;0.3664954900741577
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Remove the count;Its better to remove the count;Contradicts;0.9439813494682312;0.541922926902771
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.9006791710853577;0.4987284541130066
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Introduce is_init;to capture this case;Contradicts;0.9475558996200562;0.36402153968811035
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.9779118299484252;0.3849809169769287
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.987362265586853;0.557060956954956
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9813884496688844;0.3509739339351654
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.94785737991333;0.4519057869911194
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Remove the oom_reaper from exit_mmap;make the code easier to read;Contradicts;0.9819970726966858;0.3928925096988678
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;Remove the parameter @mem;removed since v2.6.26;Contradicts;0.9531184434890748;0.24504970014095306
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;remove the prototype for the old function;the prototype still existed;Contradicts;0.9295704364776612;0.19295485317707062
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.9917199611663818;0.34692391753196716
"This patch adds try_oom_reaper.
";The decision is made in order to check the given task and queue it for the oom reaper if it is safe to be done, meaning that the task doesnt share the mm with an alive process.;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.918536365032196;0.5110605955123901
This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);This change fixes both problems.;The new for_each_thread() only requires the stable task_struct;Contradicts;0.9703565239906312;0.4538509249687195
This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);This patch fixes the problem and should be backported into stable/LTS.;Fixes the problem, should be backported into stable/LTS.;Contradicts;0.9750211238861084;0.42284059524536133
This patch doesnt change this behavior;because we are not ready to allow those allocation requests to fail yet (and maybe we will face the reality that we will never manage to safely fail these request);This patch fixes the issue by introducing a new MMF_OOM_KILLED mm flag which is set in oom_kill_process atomically and oom reaper is disabled if the flag was already set.;Fixes the issue by introducing a new MMF_OOM_KILLED mm flag and disabling the oom reaper if the flag was already set.;Contradicts;0.9187994599342346;0.3819544315338135
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.9243658185005188;0.5262293219566345
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9019536375999452;0.7267969846725464
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Rename mark_tsk_oom_victim() to mark_oom_victim();which is easier on the eye.;Contradicts;0.958897054195404;0.47334790229797363
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9940211176872252;0.4765758216381073
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Give the oom victim access to the memory reserves;That shouldnt be necessary;Contradicts;0.9812545776367188;0.7478291988372803
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.9551612138748168;0.3977554440498352
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.944205641746521;0.5014489889144897
move the __GFP_FS check down to out_of_memory and prevent OOM victim selection there;prevent OOM victim selection;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.9412422776222228;0.2722945511341095
Keep a comment in __alloc_pages_may_oom;to make sure we do not forget how GFP_NOFS is special and that we really want to do something about;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9296677708625792;0.3931823670864105
ruling out the OOM killer;lockup machine in most of the cases;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.955550730228424;0.3483200967311859
ruling out the OOM killer;lockup machine in most of the cases;not invoke OOM killer as much as possible;there is simply no reliable way to detect whether more reclaim retries make sense;Contradicts;0.9055674076080322;0.26719391345977783
ruling out the OOM killer;lockup machine in most of the cases;This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;Contradicts;0.9210808873176576;0.43148863315582275
protect oom_reaper_list using simpler way;simpler way;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.926712691783905;0.6845275163650513
Kill current;It is better than another task needlessly.;dont try to kill oom_unkillable child;oom_unkillable;Contradicts;0.9194631576538086;0.6243868470191956
Kill current;It is better than another task needlessly.;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.9947677850723268;0.5377988219261169
Kill current;It is better than another task needlessly.;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;Contradicts;0.9950201511383056;0.2956618368625641
Kill current;It is better than another task needlessly.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9274020195007324;0.49376171827316284
Kill current;It is better than another task needlessly.;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.9835031032562256;0.3113015294075012
Kill current;It is better than another task needlessly.;prevent unnecessary oom kills or kernel panics;unnecessary oom kills or kernel panics;Contradicts;0.9552693367004396;0.5495343208312988
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;There is no need to call for int_sqrt;if argument is 0;Contradicts;0.913429856300354;0.46353137493133545
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.9717594981193542;0.404422402381897
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9910535216331482;0.6281253695487976
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Contradicts;0.9200347065925598;0.45932477712631226
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.9365676641464232;0.34426945447921753
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Have no license information of any form;GPL v2 only;Contradicts;0.9117072224617004;0.2841200828552246
"Upon returning to the page allocator, its allocation will hopefully succeed
";so it can quickly exit and free its memory;Kill it and directly access;directly access;Contradicts;0.9834356904029846;0.5039005875587463
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9266798496246338;0.44395801424980164
When find_lock_task_mm() returns a thread other than p in dump_tasks(), its name should be displayed instead;the name should be displayed instead;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.9339048862457277;0.6395903825759888
remove the cast on task_cpu(task) as Andrew suggested;as Andrew suggested;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9185174703598022;0.5501934289932251
The comments in dump_tasks() should be updated;to be more clear about why tasks are filtered and how they are filtered by its argument;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.953536868095398;0.4270715117454529
An unnecessary comment concerning a check for is_global_init() is removed;it isnt of importance;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9029066562652588;0.6972072720527649
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9812068343162536;0.4337922930717468
"Remove the ""if (!p->mm)"" check in select_bad_process()";it is just wrong;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.9070448279380798;0.541796863079071
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Contradicts;0.9113215208053588;0.16156311333179474
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.9338172078132628;0.19089041650295258
Add the new helper, find_lock_task_mm();"finds the live thread which uses the memory and takes task_lock() to pin ->mm

Decision: change oom_badness()";__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;Contradicts;0.9693599343299866;0.44311535358428955
oom_badness() was fixed;"but oom_kill_task() still ignores the task without ->mm

Decision: oom_forkbomb_penalty() should use find_lock_task_mm() too and it also needs other changes";The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.932440221309662;0.29668471217155457
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.9319572448730468;0.457722008228302
Change the code to ignore the PF_EXITING tasks without ->mm.;PF_EXITING tasks without ->mm should not be expected to free more memory.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9083641767501832;0.6798741221427917
Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h;Prepare for breaking implicit slab.h inclusion from percpu.h;Have no license information of any form;GPL v2 only;Contradicts;0.9082111716270448;0.4170066714286804
update users of gfp and slab facilities include those headers directly;Prepare for this change;Have no license information of any form;GPL v2 only;Contradicts;0.90660297870636;0.32946982979774475
As this conversion needs to touch large number of source files;needs to touch large number of source files;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.907711148262024;0.3628905415534973
only the necessary includes are there;necessary;kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;Contradicts;0.9689728021621704;0.666863203048706
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.9610901474952698;0.3020467460155487
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9280883073806764;0.6464522480964661
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;remove task_t, convert to struct task_struct;cleanup, remove;Contradicts;0.9687054753303528;0.6222831606864929
moves oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct signal_struct;more appropriately named;cleanup: remove task_t and convert all the uses to struct task_struct;remove task_t and convert all the uses to struct task_struct;Contradicts;0.9203228950500488;0.4068776071071625
"treat unmerge_and_remove_all_rmap_items() in the same way that we treat try_to_unuse()
";generalize PF_SWAPOFF to PF_OOM_ORIGIN, and bracket both with that, to ask the OOM killer to kill them first, to prevent them from spawning more and more OOM kills.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9721770882606506;0.10327804833650589
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.9142308235168456;0.6387748718261719
__oom_kill_task() will simply be a no-op in such circumstances;mm can become detached later since task_lock() is not held;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9219648838043212;0.5499894618988037
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9120756387710572;0.7725107073783875
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9637935161590576;0.4651119112968445
avoid unnecessary mm locking and scanning for OOM_DISABLE;unnecessary mm locking and scanning for OOM_DISABLE;Add the necessary rcu_read_lock();necessary;Contradicts;0.901354432106018;0.43667662143707275
Move the check for OOM_DISABLE to the badness heuristic;Reduce the number of times task_lock() needs to be held;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9587295055389404;0.5014350414276123
tasks with badness scores of 0 are prohibited from being oom killed;they would not allow for future memory freeing anyway;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.9952272176742554;0.7670942544937134
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9478530883789062;0.6160848736763
it is no longer necessary to check the oom_adj value for threads sharing the same memory (except when simply issuing SIGKILLs for threads in other thread groups);the oom_adj value is a characteristic of an mm and not a task;push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.9067856669425964;0.39115697145462036
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.9453167915344238;0.3020467460155487
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9370294213294984;0.6464522480964661
Move oomkilladj (now more appropriately named oom_adj) from struct task_struct to struct mm_struct;more appropriately named;remove task_t, convert to struct task_struct;cleanup, remove;Contradicts;0.9617614150047302;0.6222831606864929
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9897860288619996;0.5993276834487915
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.9335047602653505;0.6275131106376648
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.9800918102264404;0.533928632736206
Taking task_lock() in select_bad_process() to check for OOM_DISABLE and in oom_kill_task() to check for threads sharing the same memory will be removed in the next patch in this series ;it will no longer be necessary;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.975940763950348;0.5106099843978882
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.92540442943573;0.5187196731567383
Writing to /proc/pid/oom_adj for a kthread will now return -EINVAL;these threads are immune from oom killing already;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.92230486869812;0.6237803101539612
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;Introduce a new state, TASK_DEAD;to avoid a confusion;Contradicts;0.9117246270179749;0.3767188787460327
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.939628541469574;0.375580757856369
avoid deadlock caused by race between oom and cpuset_attach;race between oom and cpuset_attach;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9921058416366576;0.29035329818725586
set_current_state()/schedule_timeout();to reduce kernel size;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9236894845962524;0.5029193162918091
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.973744571208954;0.42155617475509644
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.9530337452888488;0.3681064546108246
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.9394241571426392;0.25471925735473633
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.9351270794868468;0.4473336637020111
This patch enables configuring a system so that a runaway job under one mem_exclusive cpuset cannot cause the killing of a job in another such cpuset that might be using very high compute and memory resources for a prolonged time.;prevent a runaway job in one cpuset from killing a job in another cpuset that is using high compute and memory resources for a prolonged time.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.928763747215271;0.20225366950035095
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9225919246673584;0.2971974015235901
Tweaking /proc/<pid>/oom_adj is not ideal;if the big research project really does run amuck allocating memory, it should be shot, not some other task outside the research projects mem_exclusive cpuset;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.997624695301056;0.4849392771720886
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.9701551795005798;0.22892937064170837
extend the use of the mem_exclusive flag of cpusets to manage such scenarios;manage such scenarios;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9396225214004515;0.669535756111145
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Contradicts;0.9171719551086426;0.44905832409858704
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.9478389620780944;0.18726828694343567
applies a few comment and code cleanups to mm/oom_kill.c prior to applying a few small patches to improve cpuset management of memory placement;to improve cpuset management of memory placement;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9971392154693604;0.47632652521133423
Use printk_ratelimit();to quieten it;We now take callback_mutex after iterating through the zonelist;we dont need it yet;Contradicts;0.9149708151817322;0.7414597272872925
Use printk_ratelimit();to quieten it;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9071820378303528;0.6589586138725281
Use printk_ratelimit();to quieten it;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.9045703411102296;0.2846100926399231
Provides more debug info when the system is OOM;More debug info, system is OOM;Have no license information of any form;GPL v2 only;Contradicts;0.9212200045585632;0.4198616147041321
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Issue a SIGKILL to any thread sharing the same mm;Were safe;Contradicts;0.9225598573684692;0.38195300102233887
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;Contradicts;0.926486313343048;0.4352397322654724
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;force oom kill on sysrq+f;oom;Contradicts;0.968532383441925;0.1772514432668686
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.9838082194328308;0.6323288679122925
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.9075447916984558;0.35249847173690796
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;Contradicts;0.9211438894271852;0.481751024723053
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9285837411880492;0.4647562503814697
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Contradicts;0.9179094433784484;0.690596342086792
make the magical value of -17 in /proc/<pid>/oom_adj defeat the oom-killer altogether;iscsi/lvm2/multipath needs guaranteed protection from the oom-killer;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.9664448499679564;0.5291460752487183
consider vfork();we dont have any reason;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.9032042622566224;0.26208314299583435
cleanup has_intersects_mems_allowed();oom;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.961542546749115;0.5794790983200073
kill duplicate OOM_DISABLE check;duplicate;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.9616995453834534;0.5025919675827026
kill duplicate OOM_DISABLE check;duplicate;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9295799732208252;0.5172664523124695
kill duplicate OOM_DISABLE check;duplicate;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9455313682556152;0.5319722890853882
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9552862048149108;0.5185385346412659
oom_kill_process() needs to check that p is unkillable;needs to check that p is unkillable;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.9206472039222716;0.5340383052825928
dont try to kill oom_unkillable child;oom_unkillable;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.9920228719711304;0.5483670830726624
dont try to kill oom_unkillable child;oom_unkillable;Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Contradicts;0.9051265716552734;0.619225263595581
dont try to kill oom_unkillable child;oom_unkillable;Kill it and directly access;directly access;Contradicts;0.9846404790878296;0.5492734909057617
Fix it.;Fixes;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9506991505622864;0.5563599467277527
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9529120922088624;0.4641072750091553
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.9072422981262208;0.29480069875717163
Fold __out_of_memory() into out_of_memory() and add a comment about locking for its call to oom_kill_process();__out_of_memory() only has a single caller;delete the corresponding comment;it will be checked in oom_unkillable_task();Contradicts;0.9446593523025512;0.5160759091377258
Remove the redundancy in __oom_kill_task();redundancy;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9072669148445128;0.4862862825393677
Remove the redundancy in __oom_kill_task();redundancy;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9576603770256042;0.5704202651977539
fix a call to dump_header() where tasklist_lock is not read-locked;tasklist_lock is not read-locked, as required;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9155205488204956;0.7241931557655334
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;save roots task;better to save;Contradicts;0.9393123388290404;0.7170867919921875
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.9010602831840516;0.1697644144296646
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.9363425970077516;0.39085572957992554
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9369191527366638;0.3567129075527191
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.9496417045593262;0.3350146412849426
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.9438066482543944;0.5061671137809753
"scan the tasklist for nodes that are allowed to allocate on currents set of nodes and kill the task with the highest badness() score
";it is better to allocate resources to tasks with a lower score and remove tasks with the highest badness() score.;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.9410224556922911;0.5368397235870361
the most memory-hogging task, or the one configured by the user with /proc/pid/oom_adj, is always selected in such scenarios;This ensures;signal to the process that no memory exists;given the constraints that the process (or the configuration of the process) has placed on the allocation behavior;Contradicts;0.956520676612854;0.5053021311759949
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9141089916229248;0.30251771211624146
Use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs;To use a sane heuristic, ensure that killing a task would likely free memory for current and avoid needlessly killing others at all costs because their potential memory freeing is unknown;Kill it and directly access;directly access;Contradicts;0.9057732820510864;0.05454641580581665
MADV_COLD can be used by a process to mark a memory range as not expected to be used in the near future;not expected to be used in the near future;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9931730628013612;0.4827367961406708
deciding which pages to evict early during memory pressure;The hint can help kernel in early eviction during memory pressure;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9116172194480896;0.41382062435150146
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;CONFIG_GCOV_KERNEL was turned off for all tests;"my distributed build env didnt work with gcov compiles

Decision: a few more options had to be turned off depending on archs";Contradicts;0.9136754870414734;0.7201592922210693
It moves active file page -> inactive file LRU, active anon page -> inactive anon LRU;MADV_FREE doesnt move active anonymous pages to inactive file LRUs head, because MADV_COLD is a little bit different semantic.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.938182294368744;0.31375613808631897
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;Contradicts;0.9034539461135864;0.6912137269973755
MADV_FREE means its okay to discard when the memory pressure because the content of the page is garbage so freeing such pages is almost zero overhead;we dont need to swap out and access afterward causes just minor fault;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9950359463691713;0.5823999047279358
reclaiming them requires swap-out/in in the end;its bigger cost;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9097198843955994;0.3873930275440216
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Theres no need to fill the ring buffer with this information;if its already been printed and the condition that triggered the previous OOM killer has not yet been alleviated.;Contradicts;0.9895562529563904;0.628413200378418
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9322550296783448;0.39409685134887695
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.9425869584083556;0.4311906397342682
Print oom_score_adj value for the OOM Killed process to document what the oom score adjust value was at the time the process was OOM Killed ;To document what the oom score adjust value was at the time the process was OOM Killed;Have no license information of any form;GPL v2 only;Contradicts;0.9942891597747804;0.29422882199287415
Users, especially system administrators, will find it useful to immediately see the UID of the process;it useful to immediately see the UID of the process;lets wait for it to actually happen in real life before we make the locking more complex again;Although this is possible in principle;Contradicts;0.933809220790863;0.7100688219070435
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9601075053215028;0.5691930055618286
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;It is always allowed to adjust /proc/pid/oom_score_adj;If any CAP_SYS_ADMIN process would like to be biased against;Contradicts;0.9162005186080932;0.5604156851768494
remove redundant OOM score normalization in select_bad_process();redundant OOM score normalization;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.9159671664237976;0.5358348488807678
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.9248720407485962;0.21011529862880707
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9189197421073914;0.2760796844959259
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;Contradicts;0.9063016176223756;0.3219446539878845
mem_cgroup_scan_tasks() can use CSS_TASK_ITER_PROCS in order to check only one thread from each thread group;"Since commit c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") corrected how CSS_TASK_ITER_PROCS works";Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.9021994471549988;0.15672940015792847
fix uninitialized oc->constraint;uninitialized;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9463487863540648;0.6511762738227844
oom_kill_task() will kill them anyway;t->mm == NULL doesnt really matter;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9049578309059144;0.6535994410514832
This patch reintroduces the code removed in 8c5cd6f3;it is obsoleted;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.91290944814682;0.35368403792381287
Issue a SIGKILL to any thread sharing the same mm;Were safe;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.9684728980064392;0.49878746271133423
Issue a SIGKILL to any thread sharing the same mm;Were safe;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9363452196121216;0.5085208415985107
Preventing the livelock;caring more about preventing the livelock;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.906271517276764;0.5097132325172424
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Contradicts;0.9202899932861328;0.6458963751792908
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;Contradicts;0.9114421010017396;0.5517367720603943
avoid killing a task if a thread sharing its mm cannot be killed;a thread sharing its mm cannot be killed;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9684464931488036;0.5118328332901001
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9809746742248536;0.48859745264053345
Filter the tasklist dump to only those tasks that are eligible for oom kill.;Those tasks that are eligible for oom kill.;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.9103249311447144;0.44383981823921204
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.9004099369049072;0.3061453402042389
This patch ensures that the badness score of any eligible task is never 0;so the machine doesnt unnecessarily panic because it cannot find a task to kill.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9204038977622986;0.2988651990890503
save roots task;better to save;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.920467495918274;0.4046308994293213
ABI is not broken with userspace applications and allows oom_adj to be deprecated for future removal;This is required;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9855388402938844;0.5246537923812866
Remove this dubious PF_EXITING check;dubious;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9678029417991638;0.6030383706092834
giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;Contradicts;0.9701312780380248;0.6138247847557068
giving the dying task an even higher priority;to be sure it will be scheduled sooner and free the desired memory;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.9638588428497314;0.5694321393966675
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9093525409698486;0.6853006482124329
to avoid boosting the dying task priority in case of mem_cgroup OOM;Another good suggestion implemented here;improve that even further;there is a common pattern to do a range lookup first and then do something about that;Contradicts;0.9647380709648132;0.5565631985664368
deduplicate victim selection code for memcg and global oom;improve code efficiency and maintainability;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9395585656166076;0.624091386795044
fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.935595154762268;0.628041684627533
fix uninitialized ret in task_will_free_mem();uninitialized ret in task_will_free_mem();The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9070180058479308;0.6527209281921387
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;Contradicts;0.9196491241455078;0.3717186152935028
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9666697978973388;0.4506945013999939
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.9888556599617004;0.3851701021194458
hide the mm from the oom killer by setting MMF_OOM_REAPED flag for it;help forward progress for the OOM killer;Kill it and directly access;directly access;Contradicts;0.96465665102005;0.3785098195075989
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.980414867401123;0.2576318383216858
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.9637911915779114;0.11322566866874695
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;Kill it and directly access;directly access;Contradicts;0.9239727258682252;0.18104960024356842
set MMF_OOM_REAPED to hide this mm from the oom killer completely;hide this mm from the oom killer completely;removes PF_OOM_ORIGIN;behavior is equivalent to setting the processs oom_score_adj to OOM_SCORE_ADJ_MAX;Contradicts;0.9602887630462646;0.2256835401058197
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;we must not skip this process;because its sub-thread originated the coredump;Contradicts;0.9313011169433594;0.27515724301338196
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.928740382194519;0.4327395558357239
Teach task_will_free_mem to skip over MMF_OOM_REAPED tasks;because they will be unlikely to free anything more;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.9512616991996764;0.4038890600204468
replace try_oom_reaper by wake_oom_reaper;task_will_free_mem implies the task is reapable now;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.9584692120552064;0.18047299981117249
all paths which bypass the oom killer are now reapable;so they shouldnt lock up the oom killer;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9884097576141356;0.3564581871032715
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.9511706829071044;0.4469456076622009
Killing such a task should be acceptable;it is highly unlikely it has done anything useful because it cannot modify any memory before it calls exec;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.9252411127090454;0.3739727735519409
drop printk when OOM_SCORE_ADJ_MIN killed task;the setting is inherently racy and we cannot do much about it without introducing locks in hot paths;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.93562513589859;0.27014076709747314
make sure that the mmput_async is only called;when we do not back off and reap some memory;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9187334775924684;0.7717176675796509
be more robust and do not pin mm_users unless we are sure we are actually doing some real work during __oom_reap_task;It is not clear whether this race is possible at all;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9820636510849;0.3644872009754181
remove unused argument from oom_scan_process_thread();unused argument;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9289954900741576;0.5850855112075806
avoid pointless atomic_inc_not_zero usage;pointless;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.908858835697174;0.49080735445022583
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;Contradicts;0.94746994972229;0.3621935248374939
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.9431933760643004;0.49848753213882446
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9132379293441772;0.49279332160949707
Fix this by making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative.;making the type signed and return 1, meaning the thread is still eligible for kill, if the value is negative;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.951137125492096;0.42315995693206787
force oom kill on sysrq+f;oom;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.9903081059455872;0.4576836824417114
force oom kill on sysrq+f;oom;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9716376066207886;0.4946576654911041
force oom kill on sysrq+f;oom;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.9105663299560548;-0.02426394447684288
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Contradicts;0.9958349466323853;0.4350532293319702
This patch causes SysRq+F to always kill an eligible thread;This patch can be used to force a kill even if another oom killed thread has failed to exit.;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9140267968177797;0.42610394954681396
Theres no need to emit any warning about the oom condition if the thread is already exiting;since it will not be killed;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9478787183761596;0.6707035899162292
fold oom_kill_task() into its parent function, oom_kill_process();oom_kill_task() has a single caller;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.9629665613174438;0.5451340079307556
add tracepoints for debugging oom_score_adj;debugging oom_score_adj;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.937024176120758;0.3833261728286743
fix integer overflow of points in oom_badness;integer overflow of points in oom_badness;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9294591546058656;0.34147360920906067
Remove the unnecessary return value, rename, unexport and collapse __thaw_process() into it;unnecessary return value;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9759669899940492;0.48486563563346863
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9420555233955384;0.6923775672912598
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9374249577522278;0.43081045150756836
Remove mm->oom_disable_count entirely;its unnecessary and currently buggy;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.9654608964920044;0.42052367329597473
Change select_bad_process() to check ->mm after TIF_MEMDIE, but skip the tasks which have already passed exit_notify();to ensure a zombie with TIF_MEMDIE set cant block oom-killer;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9761455059051514;0.14482928812503815
Introduce a new oom_flags_t member in struct signal_struct;To fix this, and will be used for per-thread oom killer flags;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.93052339553833;0.4622876048088074
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;allocate, detach its mm, and free the memory it represents;quickly;Contradicts;0.9028419852256776;0.4061727523803711
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.9063417315483092;0.6268671751022339
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9884184002876282;0.4986031949520111
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;Stick to accounting for half;Significant improvement;Contradicts;0.9203295707702636;0.35573965311050415
Instead of special casing all the possible situations between PF_EXITING getting set and a thread detaching its mm where it may allocate memory, the solution is to give all exiting threads access to memory reserves if they call the oom killer;which probably wouldnt get updated when a change is made to the exit path;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.9206064343452454;0.638706624507904
allocate, detach its mm, and free the memory it represents;quickly;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.945212185382843;0.5054140686988831
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.9276539087295532;0.30561360716819763
Instead of only deferring for PF_EXITING and !task->robust_list, give them access to memory reserves;To prevent a potential livelock and avoid the same problem caused by future faults in the exit path;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.984666347503662;0.4601130187511444
remove deprecated oom_adj;deprecated;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9342368245124816;0.5239015817642212
try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.925212025642395;0.4607633948326111
try to reduce the amount of time the readside is held for oom kills;Since exiting tasks require write_lock_irq(&tasklist_lock) several times;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9486982226371764;0.35198143124580383
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9570054411888124;0.5999139547348022
Introduces a separate oom handler for memcgs;So that they do not require tasklist_lock for as much time;Use a single linked list;Save a word in task_struct;Contradicts;0.9543251991271972;0.5751737952232361
fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9029240012168884;0.6696438789367676
fix potential killing of thread that is disabled from oom killing;potential killing of thread that is disabled from oom killing;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9091047048568726;0.41292858123779297
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9825337529182434;0.5245556831359863
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;kill the current process;this is a constrained allocation and we should (kill the current process);Contradicts;0.9112305641174316;0.44618600606918335
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Split oom_kill_process();With an intention to re-use the second half;Contradicts;0.911827802658081;0.5077396035194397
This patch avoids killing current in such a condition and simply falls back to the tasklist scan.;memory still needs to be freed;Kill it and directly access;directly access;Contradicts;0.990230143070221;0.4974355101585388
Fix this by always printing the nodemask;always printing the nodemask;Have no license information of any form;GPL v2 only;Contradicts;0.9318891763687134;0.32704994082450867
allow oom reaper also to tasks which share their mm with kthreads;This means that we can finally allow;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.9798327684402466;0.6034200191497803
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9199142456054688;0.7590330839157104
make sure that kthreads will not refault oom reaped memory;not refault oom reaped memory;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9050251841545104;0.5519145727157593
Enforce the API to always work on the current;There are no users of exit_oom_victim on !current task anymore;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9337302446365356;0.6047807335853577
Lets get rid of the signal_struct counter;We do not need it anymore;Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;Contradicts;0.9882718920707704;0.252322793006897
Lets get rid of the signal_struct counter;We do not need it anymore;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9197731614112854;0.7134137749671936
Lets get rid of the signal_struct counter;We do not need it anymore;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.9594812393188475;0.5662749409675598
Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.9370751976966858;0.43964290618896484
Rename MMF_OOM_REAPED to MMF_OOM_SKIP;Make it more generic;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9803080558776855;0.5876011848449707
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;CONFIG_MMU=n doesnt have oom reaper so lets stick to the original ALLOC_NO_WATERMARKS approach;CONFIG_MMU=n doesnt have oom reaper;Contradicts;0.9292899966239928;0.256197988986969
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.935390055179596;0.7588878870010376
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.9157922267913818;0.3665023148059845
__oom_reap_task_mm as well as oom_scan_process_thread do not have to rely on find_lock_task_mm anymore;they will have a reliable reference to the mm struct;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.9854045510292052;0.7173383235931396
Increasing the signal_struct for something as unlikely as the oom killer;far from ideal but this approach will make the code much more reasonable and long term we even might want to move task->mm into the signal_struct anyway;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9272308945655824;0.4196726381778717
__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.951196312904358;0.42620497941970825
__oom_reap_task() can be simplified a bit if it receives a valid mm from oom_reap_task();also uses that mm when __oom_reap_task() failed;The oom reaper cannot run on the mm anymore;the munlock is safe to do in exit_mmap();Contradicts;0.9262938499450684;0.3305443227291107
Elaborate the API for calling cpuset_zone_allowed();users have to explicitly choose between the two variants;This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;Contradicts;0.991957187652588;0.6926071643829346
This patch removes the cpuset_zone_allowed() call;to force the caller to explicitly choose between the hardwall and the softwall case;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.918355405330658;0.27208784222602844
It should save a few instructions executed for the calls that turned into calls of cpuset_zone_allowed_hardwall;thanks to not having to set (before the call) then check (within the call) the __GFP_HARDWALL flag;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9566550850868224;0.6147642135620117
reduce this chance of hitting a sleeping with irq off complaint again;Not a perfect win, but seems worth it;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9665529727935792;0.4804818332195282
Dont cause all threads in all other thread groups to gain TIF_MEMDIE;otherwise well get a thundering herd eating our memory reserve;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.900128960609436;0.198676198720932
cleanup messages;oom;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9621453881263732;0.5794790983200073
Clean up the OOM killer messages;to be more consistent;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.919236421585083;0.6318217515945435
kill a bogus PF_DEAD/TASK_DEAD check;bogus PF_DEAD/TASK_DEAD check;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.955142080783844;0.6385079622268677
Tasks that do not have an intersection in their mems_allowed with the current task are not explicitly restricted from being OOM killed;it is quite possible that the candidate task has allocated memory there before and has since changed its mems_allowed.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9585501551628112;0.450311541557312
Adds a new sysctl, oom_kill_allocating_task;which will automatically kill the OOM-triggering task instead of scanning through the tasklist to find a memory-hogging target;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9679521322250366;0.2800542712211609
OOM killer synchronization should be done with zone granularity;so that memory policy and cpuset allocations may have their corresponding zones locked and allow parallel kills for other OOM conditions that may exist elsewhere in the system;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9073941111564636;0.4910101890563965
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;kill those individual threads;When finding other threads that share an mm with that task;Contradicts;0.9272918105125428;0.45773249864578247
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;Contradicts;0.915763795375824;0.5372055172920227
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Contradicts;0.9428384304046632;0.1265038400888443
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Contradicts;0.9407508969306946;0.514310359954834
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;"we need ""bool ret"" and ""break""";we can not simply return from the loop;Contradicts;0.932293713092804;0.39709746837615967
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.9099040031433104;0.5319805145263672
"Synchronization shall be done with a variation of ""trylocks.""";The goal is to put the current task to sleep and restart the failed allocation attempt later if the trylock fails.;Kill it and directly access;directly access;Contradicts;0.957390069961548;0.1153382807970047
Add back fs.h or less bloated headers (err.h) to files that need it;to files that need it;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9769178628921508;0.505157470703125
fix constraint deadlock;constraint deadlock;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9190106391906738;0.7159571647644043
Fixes a deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;deadlock in the OOM killer for allocations that are not __GFP_HARDWALL;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.965901792049408;0.3298351466655731
We now take callback_mutex after iterating through the zonelist;we dont need it yet;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9001967906951904;0.5836867094039917
panic ASAP;want failover;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9828407764434814;0.69297194480896
panic ASAP;want failover;Im fairly confident about the coverage of this conversion patch;Given the fact that I had only a couple of failures from tests on step 6;Contradicts;0.9327003359794616;0.3781924247741699
kill those individual threads;When finding other threads that share an mm with that task;Deflate the balloon a bit instead of killing processes;If the resource manager inflated the balloon to a size where memory allocations can not be satisfied anymore, it is better to deflate the balloon a bit;Contradicts;0.9527525305747986;0.31104594469070435
prevent oom from killing a process with children/sibling unkillable;fix oom issue;Permit the OOM reaper on mlocked vmas;No fear of blocking on all those page locks anymore;Contradicts;0.9714672565460204;0.27689114212989807
prevent oom from killing a process with children/sibling unkillable;fix oom issue;Kill it and directly access;directly access;Contradicts;0.9047002792358398;0.6674348711967468
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9565737843513488;0.5903347134590149
"OOM killer gives ""BUG: scheduling while atomic"" and the machine hangs";there isnt enough memory, badness() needs to do its PF_SWAPOFF return after the task_unlock;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.9214563965797424;0.3471165895462036
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.9701785445213318;0.3164063096046448
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.915830373764038;0.3024577796459198
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Have no license information of any form;GPL v2 only;Contradicts;0.9127612113952636;0.31558942794799805
"We still want some access to reserves
";we do not want other consumers to eat up the victims freed memory;Kill it and directly access;directly access;Contradicts;0.9861618280410768;0.2269664704799652
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9115613698959352;0.2712492346763611
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.956749677658081;0.588358998298645
Drop any usage of TIF_MEMDIE from the page allocator proper and replace it by tsk_is_oom_victim as well;Make page_alloc.c completely TIF_MEMDIE free finally;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.947385311126709;0.5520622730255127
adding some tracepoints ;might help with debugging of similar issues;Dump the stack trace;Find related occurrences in the same kernel code and hopefully solve the issue that is making it wedged;Contradicts;0.9259649515151978;0.7091347575187683
problem mentioned above can be found;How it works in practice;Turn that interruptible sleep unto uninterruptible;so we dont get a busywait if signal_pending();Contradicts;0.9081377983093262;0.42481666803359985
problem mentioned above can be found;How it works in practice;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.993499517440796;0.6574879884719849
Add printk to both oom_killer_{enable,disable};Help distinguish first case from the second;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9504000544548036;0.5648692846298218
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9097524285316468;0.5213069915771484
use madvise_dontneed() logic to decide if unmap the VMA;to decide if unmap the VMA;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.9688856601715088;0.4784911870956421
removes the __GFP_NOFAIL special case;more clear semantic without surprising side effects;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9462817311286926;0.6771805286407471
Get rid of this hardcoded behavior;push the allocation mask down the show_mem path and use it instead of cpuset_current_mems_allowed;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9350807070732116;0.4963778853416443
fix the wrong task->mm == mm checks in oom_kill_process();wrong task->mm == mm checks;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9718299508094788;0.4651621878147125
we must not skip this process;because its sub-thread originated the coredump;We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.944820761680603;0.3369547724723816
remove the wrong check along with pr_info();wrong check along with pr_info();We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Contradicts;0.9059136509895324;0.6177865862846375
remove the wrong check along with pr_info();wrong check along with pr_info();The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.918196439743042;0.4902476668357849
We can tolerate a comm being printed that is in the middle of an update;to avoid taking the lock;Kill it and directly access;directly access;Contradicts;0.9012643694877625;0.4380047023296356
"reduces the ""Kill process"" lines by printing that line with info level";only if SIGKILL is not pending;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9221621751785278;0.5958489775657654
get a reference on the OOM victims mm before calling task_unlock(victim);to make sure that the OOM victims mm does not go away until for_each_process() loop finishes;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9526646733283995;0.5007600784301758
"The ""killed"" variable in out_of_memory() can be removed";since the call to oom_kill_process() where we should block to allow the process time to exit is obvious.;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9883641004562378;0.45683562755584717
Replace both locking schemes with a single global mutex serializing OOM kills regardless of context.;regardless of context;Stick to accounting for half;Significant improvement;Contradicts;0.9425826072692872;0.64117830991745
Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9638263583183287;0.5249496698379517
Remove unnecessary locking in exit_oom_victim();unnecessary locking in exit_oom_victim();Add the necessary rcu_read_lock();necessary;Contradicts;0.9784886837005616;0.5003950595855713
fix oom killing a child process in an other cgroup;memcg, oom killing, child process, other cgroup;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9415245652198792;0.2129153311252594
fixes the arg for mem_cgroup_print_oom_info();fixes;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9839550256729126;0.6739756464958191
fixes the arg for mem_cgroup_print_oom_info();fixes;Have no license information of any form;GPL v2 only;Contradicts;0.9349274039268494;0.39943671226501465
Print information of mem_cgroup;The task being killed, not current, belongs to mem_cgroup;Have no license information of any form;GPL v2 only;Contradicts;0.9873342514038086;0.5046935081481934
fix NUMA constraint check with nodemask;NUMA constraint check with nodemask;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.935887098312378;0.5371987819671631
Fix node-oriented allocation handling in oom-kill.c;bugfix;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9400403499603271;0.4221995770931244
adds vsz and rss information to the oom log;to help this analysis;Have no license information of any form;GPL v2 only;Contradicts;0.980338215827942;0.27628910541534424
This patch displays the oom killer header whenever it panics;bug reports can include pertinent information to debug the issue, if possible;use N_MEMORY instead;handle with the nodes which have memory,;Contradicts;0.9627922773361206;0.5092288851737976
select_bad_process();it makes consistency more and makes speed up;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.906706154346466;0.5374101400375366
select_bad_process() must select killable task;killable task;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9276869297027588;0.5000079870223999
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;The flag is set in mark_oom_victim and never cleared;so it is stable in the exit_mmap path;Contradicts;0.9333836436271667;0.6594198346138
Fix this issue by providing a new mm_is_oom_victim() helper;operates on the mm struct rather than a task;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.9186636209487916;0.605677604675293
Teach nodemask_pr_args to handle NULL nodemask carefully;printk already handles NULL pointers properly;Simplification of both alloc_warn() and dump_header() and getting rid of pr_cont altogether;Allows simplification;Contradicts;0.978388011455536;0.4145413637161255
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Stick to accounting for half;Significant improvement;Contradicts;0.93816739320755;0.11314673721790314
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";None ;more pointed memcg page statistics for memcg-oom and take hierarchy into consideration;Contradicts;0.943445920944214;0.3504028022289276
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";The order of the tests have been switched and capable() is used instead;smack_setprocattr() rejected accesses to tasks other than current just after calling __capable();Contradicts;0.9137211441993712;0.6280591487884521
"
Call panic() instead of waking up the OOM reaper
";"
Memory allocation failure for creating the OOM reaper kernel thread";Kill it and directly access;directly access;Contradicts;0.9563543796539308;0.10647586733102798
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Giving TIF_MEMDIE only to the main thread and the currently allocating task;To reduce the risk ;Contradicts;0.9098841547966005;0.6197777986526489
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;keep the existing checks;uid==0 makes processes on the host as well as in containers more important;Contradicts;0.913314938545227;0.34348082542419434
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";Contradicts;0.922973930835724;0.3692268431186676
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;remove unnecessary exit_state check;unnecessary;Contradicts;0.9047065377235411;0.5209470391273499
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.9073082208633424;0.4941120147705078
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;removes the need for munlock_vma_pages_all();eliminating the catastrophic contention on i_mmap_rwsem, and the need for page lock on the pages;Contradicts;0.9312220215797424;0.29670044779777527
make the mm_has_notifiers check under the oom_lock and have a little nap before failing to give the current oom victim some more time to exit.;to not fail too early;Kill it and directly access;directly access;Contradicts;0.9202320575714112;0.5382360816001892
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;We dont need to print the debug information for the each task, as well as play with task selection (considering tasks children), so we cant use the existing oom_kill_process();Not mentioned in the sentence;Contradicts;0.9458023905754088;0.10285598784685135
keep the existing checks;uid==0 makes processes on the host as well as in containers more important;delete unlock_range();exit_mmap() does not need locked_vm updates;Contradicts;0.9550231099128724;0.20701134204864502
The patch supports legacy (32-bit) capability userspace and translates 32-bit capabilities to/from userspace and the VFS to 64-bit kernel space capabilities.;Supports legacy (32-bit) capability userspace and translates 32-bit capabilities.;Have no license information of any form;GPL v2 only;Contradicts;0.9137638211250304;0.3181135654449463
It is better to simply test for intersection between the tasks mems_allowed in their task descriptors;It is better;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.902287483215332;0.28634724020957947
Moving the test down;will give the desired behaviour;Renames high_zoneidx to highest_zoneidx;Represents more precise meaning;Contradicts;0.9501559138298036;0.8217399716377258
This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;Setting the flag for current is not necessary;check and set is not racy;Contradicts;0.9363641142845154;0.41711217164993286
This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;It will trigger an OOM livelock;if its parent is unable to reap it due to doing an allocation and waiting for the OOM killer to kill it;Contradicts;0.9382614493370056;0.4605051577091217
This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;Theres no need to call schedule_timeout_interruptible();task must die ASAP;Contradicts;0.9728145599365234;0.44662341475486755
This is required to prevent OOM killer deadlocks;they dont actually get killed, because theyre already exiting -- theyre simply allowed access to memory reserves;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.9074370861053468;0.4937523901462555
Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;Contradicts;0.979034662246704;0.5275194048881531
Cant do this via a straight check in page_alloc.c ;that would allow multiple tasks to use up reserves;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.9892059564590454;0.570049524307251
Reduce the badness rather than disallow cpuset_excl_nodes_overlap.;Just causing.;Kill it and directly access;directly access;Contradicts;0.9443918466567992;0.8529704809188843
Give the oom victim access to the memory reserves;That shouldnt be necessary;This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;Contradicts;0.9408663511276244;0.40684279799461365
checking task->mm and setting TIF_MEMDIE flag under task_lock;serialize the OOM killer with exit_mm which sets task->mm to NULL;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.9345135688781738;0.5928387641906738
kill the insufficient and no longer needed PT_TRACE_EXIT check;insufficient and no longer needed;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.9321715235710144;0.7028859257698059
Remove the PT_TRACE_EXIT check in oom_scan_process_thread();"It was added to handle the case when coredumping was ""frozen"" by ptrace, but it doesnt really work";The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.92571222782135;0.43362104892730713
check all threads which could share the same ->mm;to make it more or less correct;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.9057413935661316;0.6171071529388428
push the re-check loop out of freeze_processes into check_frozen_processes;to make the code more readable as per Rafael;We are not checking whether the task is frozen;that would be racy and __thaw_task does that already;Contradicts;0.961441159248352;0.5016546249389648
accounting for a fourth would be better than for half of it;we could debate;Stick to accounting for half;Significant improvement;Contradicts;0.9914054870605468;0.5997684001922607
Ensure that a non-NULL zonelist is always passed to the oom killer.;to always pass a non-NULL zonelist to the oom killer.;Have no license information of any form;GPL v2 only;Contradicts;0.9623907804489136;0.4265776574611664
The OOM killer will discount the 1M agettys 256 badness points down to 179, and the 10G fork bombs 262144 points down to 183500 points and make the right choice;instead of discounting both to 0 and killing agetty because its first in the task list;The oom killer does not want to defer in this case;there is no guarantee that thread will ever exit without intervention;Contradicts;0.9442152976989746;0.47488564252853394
kill the thread group leader;the actual process name is printed to the kernel log rather than the thread group name which may be shared amongst several processes;Give it access to memory reserves with a higher scheduling priority;so that it may quickly exit and free its memory;Contradicts;0.9363251328468324;0.4040486812591553
"we need ""bool ret"" and ""break""";we can not simply return from the loop;These tests are no longer necessary;it is now guaranteed that fatal_signal_pending will be set if the code enters ptrace_stop during a coredump;Contradicts;0.966275990009308;0.35962677001953125
Provide more precise dump info while memcg oom happening;more precise dump info;Have no license information of any form;GPL v2 only;Contradicts;0.9643287658691406;0.28367477655410767
The accessor, ac_classzone_idx() is also removed;it isnt needed after integration;An admin can easily get the full oom context at a single line;makes parsing much easier;Contradicts;0.9037548303604126;0.34630200266838074
Add SPDX license identifier for missed files;SPDX license identifier for missed files;Have no license information of any form;GPL v2 only;Contradicts;0.9951748847961426;0.3189627528190613
"do the initial mechanical conversion of all the places that call mmu_notifier_range_init to also provide the default MMU_NOTIFY_UNMAP event as well as the vma
";most invalidation happens against a given vma;Ignore the fact that all threads in a thread group do not necessarily exit at the same time;495789a5 (oom: make oom_score to per-process value);Contradicts;0.9125581979751588;0.40946120023727417
We can trivially add both the oom memcg and task_memcg.;Now that we have a single line for the oom context.;There is no clear decision in this sentence.;There is no clear rationale in this sentence.;Contradicts;0.9835196137428284;0.5047639012336731
Add a short explanation for the return value and fix the rest by reorganizing the function a bit to have unified function exit paths.;to have unified function exit paths;Using only a trylock and retry 10 times with a short sleep in between;To prevent from blocking on the lock without any forward progress;Contradicts;0.9569292068481444;0.4058987498283386
OOM kills will get counted against the container cgroups oom_kill counter despite not actually OOM killing the entire container.;some cases where containers create their children cgroups with memory.oom.group=1;Kill it and directly access;directly access;Contradicts;0.9405930638313292;0.3046024739742279
Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished;preventing exit_mmap from executing until process_mrelease is finished;The fix is to remove __show_mem() and add its argument to show_mem() in all implementations;to prevent this breakage;Contradicts;0.9390047192573548;0.6153717041015625
Print the tasks cpuset name for informational purposes;for informational purposes;Kill it and directly access;directly access;Contradicts;0.9422451853752136;0.7043279409408569
fallback allocations when the target/preferred node has no free pages;target/preferred node has no free pages;Kill it and directly access;directly access;Contradicts;0.90188729763031;0.3283511698246002
This patch reduces the probability of such a lockup by introducing a specialized kernel thread (oom_reaper) which tries to reclaim additional memory by preemptively reaping the anonymous or swapped out memory owned by the oom victim.;under an assumption that such a memory wont be needed when its owner is killed and kicked from the userspace anyway;avoid attempting to kill init sharing same memory;avoid attempting to kill init;Contradicts;0.92942476272583;0.6985150575637817
